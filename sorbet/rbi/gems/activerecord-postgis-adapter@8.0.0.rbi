# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `activerecord-postgis-adapter` gem.
# Please instead update this file by running `bin/tapioca gem activerecord-postgis-adapter`.

# :startdoc:
module ActiveRecord
  extend ::ActiveSupport::Autoload

  class << self
    def action_on_strict_loading_violation; end
    def action_on_strict_loading_violation=(_arg0); end
    def application_record_class; end
    def application_record_class=(_arg0); end
    def async_query_executor; end
    def async_query_executor=(_arg0); end
    def default_timezone; end
    def default_timezone=(default_timezone); end
    def dump_schema_after_migration; end
    def dump_schema_after_migration=(_arg0); end
    def dump_schemas; end
    def dump_schemas=(_arg0); end
    def eager_load!; end
    def error_on_ignored_order; end
    def error_on_ignored_order=(_arg0); end
    def gem_version; end
    def global_executor_concurrency; end
    def global_executor_concurrency=(global_executor_concurrency); end
    def global_thread_pool_async_query_executor; end
    def index_nested_attribute_errors; end
    def index_nested_attribute_errors=(_arg0); end
    def lazily_load_schema_cache; end
    def lazily_load_schema_cache=(_arg0); end
    def legacy_connection_handling; end
    def legacy_connection_handling=(_arg0); end
    def maintain_test_schema; end
    def maintain_test_schema=(_arg0); end
    def query_transformers; end
    def query_transformers=(_arg0); end
    def queues; end
    def queues=(_arg0); end
    def reading_role; end
    def reading_role=(_arg0); end
    def schema_cache_ignored_tables; end
    def schema_cache_ignored_tables=(_arg0); end
    def schema_format; end
    def schema_format=(_arg0); end
    def suppress_multiple_database_warning; end
    def suppress_multiple_database_warning=(_arg0); end
    def timestamped_migrations; end
    def timestamped_migrations=(_arg0); end
    def verbose_query_logs; end
    def verbose_query_logs=(_arg0); end
    def verify_foreign_keys_for_fixtures; end
    def verify_foreign_keys_for_fixtures=(_arg0); end
    def version; end
    def warn_on_records_fetched_greater_than; end
    def warn_on_records_fetched_greater_than=(_arg0); end
    def writing_role; end
    def writing_role=(_arg0); end
  end
end

module ActiveRecord::ConnectionAdapters
  extend ::ActiveSupport::Autoload
end

class ActiveRecord::ConnectionAdapters::AddColumnDefinition < ::Struct
  def column; end
  def column=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefinition < ::Struct
  def column; end
  def column=(_); end
  def name; end
  def name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class ActiveRecord::ConnectionAdapters::CheckConstraintDefinition < ::Struct
  def export_name_on_schema_dump?; end
  def expression; end
  def expression=(_); end
  def name; end
  def options; end
  def options=(_); end
  def table_name; end
  def table_name=(_); end
  def validate?; end
  def validated?; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class ActiveRecord::ConnectionAdapters::ColumnDefinition < ::Struct
  def aliased_types(name, fallback); end
  def collation; end
  def collation=(value); end
  def comment; end
  def comment=(value); end
  def default; end
  def default=(value); end
  def limit; end
  def limit=(value); end
  def name; end
  def name=(_); end
  def null; end
  def null=(value); end
  def options; end
  def options=(_); end
  def precision; end
  def precision=(value); end
  def primary_key?; end
  def scale; end
  def scale=(value); end
  def sql_type; end
  def sql_type=(_); end
  def type; end
  def type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class ActiveRecord::ConnectionAdapters::CreateIndexDefinition < ::Struct
  def algorithm; end
  def algorithm=(_); end
  def if_not_exists; end
  def if_not_exists=(_); end
  def index; end
  def index=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class ActiveRecord::ConnectionAdapters::ForeignKeyDefinition < ::Struct
  def column; end
  def custom_primary_key?; end
  def deferrable; end
  def defined_for?(to_table: T.unsafe(nil), validate: T.unsafe(nil), **options); end
  def export_name_on_schema_dump?; end
  def from_table; end
  def from_table=(_); end
  def name; end
  def on_delete; end
  def on_update; end
  def options; end
  def options=(_); end
  def primary_key; end
  def to_table; end
  def to_table=(_); end
  def validate?; end
  def validated?; end

  private

  def default_primary_key; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

module ActiveRecord::ConnectionAdapters::PostGIS; end

module ActiveRecord::ConnectionAdapters::PostGIS::ColumnDefinitionUtils
  class << self
    def default_srid(options); end
    def geo_type(type = T.unsafe(nil)); end
    def limit_from_options(type, options = T.unsafe(nil)); end
  end
end

module ActiveRecord::ConnectionAdapters::PostGIS::ColumnMethods
  def geography(name, options = T.unsafe(nil)); end
  def geometry(name, options = T.unsafe(nil)); end
  def geometry_collection(name, options = T.unsafe(nil)); end
  def line_string(name, options = T.unsafe(nil)); end
  def multi_line_string(name, options = T.unsafe(nil)); end
  def multi_point(name, options = T.unsafe(nil)); end
  def multi_polygon(name, options = T.unsafe(nil)); end
  def spatial(name, options = T.unsafe(nil)); end
  def st_point(name, options = T.unsafe(nil)); end
  def st_polygon(name, options = T.unsafe(nil)); end
end

module ActiveRecord::ConnectionAdapters::PostGIS::DatabaseStatements
  def truncate_tables(*table_names); end
end

module ActiveRecord::ConnectionAdapters::PostGIS::OID; end

# OID used to represent geometry/geography database types and attributes.
#
# Accepts `geo_type`, `srid`, `has_z`, `has_m`, and `geographic` as parameters.
# Responsible for parsing sql_types returned from the database and WKT features.
class ActiveRecord::ConnectionAdapters::PostGIS::OID::Spatial < ::ActiveModel::Type::Value
  # @return [Spatial] a new instance of Spatial
  def initialize(geo_type: T.unsafe(nil), srid: T.unsafe(nil), has_z: T.unsafe(nil), has_m: T.unsafe(nil), geographic: T.unsafe(nil)); end

  # support setting an RGeo object or a WKT string
  def serialize(value); end

  # @return [Boolean]
  def spatial?; end

  def spatial_factory; end
  def type; end

  private

  # @return [Boolean]
  def binary_string?(string); end

  def cast_value(value); end
  def factory_attrs; end

  # convert WKT string into RGeo object
  def parse_wkt(string); end

  def wkt_parser(string); end

  class << self
    # sql_type: geometry, geometry(Point), geometry(Point,4326), ...
    #
    # returns [geo_type, srid, has_z, has_m]
    #   geo_type: geography, geometry, point, line_string, polygon, ...
    #   srid:     1234
    #   has_z:    false
    #   has_m:    false
    def parse_sql_type(sql_type); end
  end
end

module ActiveRecord::ConnectionAdapters::PostGIS::SchemaStatements
  # override
  def create_table_definition(*args, **kwargs); end

  # override
  def native_database_types; end

  # override
  # https://github.com/rails/rails/blob/6-0-stable/activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb#L624
  # Create a SpatialColumn instead of a PostgreSQL::Column
  def new_column_from_field(table_name, field); end

  # memoize hash of column infos for tables
  def spatial_column_info(table_name); end

  # override
  # https://github.com/rails/rails/blob/master/activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb#L544
  #
  # returns Postgresql sql type string
  # examples:
  #   "geometry(Point,4326)"
  #   "geography(Point,4326)"
  #
  # note: type alone is not enough to detect the sql type,
  # so `limit` is used to pass the additional information. :(
  #
  # type_to_sql(:geography, limit: "Point,4326")
  # => "geography(Point,4326)"
  def type_to_sql(type, limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil), array: T.unsafe(nil), **_arg5); end
end

class ActiveRecord::ConnectionAdapters::PostGIS::SpatialColumn < ::ActiveRecord::ConnectionAdapters::PostgreSQL::Column
  # sql_type examples:
  #   "Geometry(Point,4326)"
  #   "Geography(Point,4326)"
  #
  # @return [SpatialColumn] a new instance of SpatialColumn
  def initialize(name, default, sql_type_metadata = T.unsafe(nil), null = T.unsafe(nil), default_function = T.unsafe(nil), collation: T.unsafe(nil), comment: T.unsafe(nil), serial: T.unsafe(nil), spatial: T.unsafe(nil)); end

  # Returns the value of attribute geographic.
  def geographic; end

  # Returns the value of attribute geographic.
  def geographic?; end

  # Returns the value of attribute geometric_type.
  def geometric_type; end

  # Returns the value of attribute has_m.
  def has_m; end

  # Returns the value of attribute has_m.
  def has_m?; end

  # Returns the value of attribute has_z.
  def has_z; end

  # Returns the value of attribute has_z.
  def has_z?; end

  def limit; end

  # @return [Boolean]
  def spatial?; end

  # Returns the value of attribute srid.
  def srid; end

  private

  def build_from_sql_type(sql_type); end
  def set_geometric_type_from_name(name); end
  def to_type_name(geometric_type); end
end

# Do spatial sql queries for column info and memoize that info.
class ActiveRecord::ConnectionAdapters::PostGIS::SpatialColumnInfo
  # @return [SpatialColumnInfo] a new instance of SpatialColumnInfo
  def initialize(adapter, table_name); end

  def all; end

  # do not query the database for non-spatial columns/tables
  def get(column_name, type); end
end

class ActiveRecord::ConnectionAdapters::PostGIS::TableDefinition < ::ActiveRecord::ConnectionAdapters::PostgreSQL::TableDefinition
  include ::ActiveRecord::ConnectionAdapters::PostGIS::ColumnMethods

  # super: https://github.com/rails/rails/blob/master/activerecord/lib/active_record/connection_adapters/abstract/schema_definitions.rb
  def new_column_definition(name, type, **options); end
end

module ActiveRecord::ConnectionAdapters::PostGIS::Type
  # Look for :postgis types first, then check for :postgresql
  # types to simulate a kind of Type inheritance.
  def lookup(*args, adapter: T.unsafe(nil), **kwargs); end
end

ActiveRecord::ConnectionAdapters::PostGIS::VERSION = T.let(T.unsafe(nil), String)

class ActiveRecord::ConnectionAdapters::PostGISAdapter < ::ActiveRecord::ConnectionAdapters::PostgreSQLAdapter
  include ::ActiveRecord::ConnectionAdapters::PostGIS::SchemaStatements
  include ::ActiveRecord::ConnectionAdapters::PostGIS::DatabaseStatements

  def arel_visitor; end
  def default_srid; end
  def postgis_lib_version; end
  def quote(value); end
  def quote_default_expression(value, column); end
  def srs_database_columns; end

  class << self
    def initialize_type_map(map = T.unsafe(nil)); end
    def spatial_column_options(key); end
  end
end

ActiveRecord::ConnectionAdapters::PostGISAdapter::ADAPTER_NAME = T.let(T.unsafe(nil), String)

# http://postgis.17.x6.nabble.com/Default-SRID-td5001115.html
ActiveRecord::ConnectionAdapters::PostGISAdapter::DEFAULT_SRID = T.let(T.unsafe(nil), Integer)

ActiveRecord::ConnectionAdapters::PostGISAdapter::SPATIAL_COLUMN_OPTIONS = T.let(T.unsafe(nil), Hash)
ActiveRecord::ConnectionAdapters::PostgreSQLColumn = ActiveRecord::ConnectionAdapters::PostgreSQL::Column
ActiveRecord::ConnectionAdapters::PostgreSQLTypeMetadata = ActiveRecord::ConnectionAdapters::PostgreSQL::TypeMetadata

class ActiveRecord::ConnectionAdapters::PrimaryKeyDefinition < ::Struct
  def name; end
  def name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

module ActiveRecord::ConnectionHandling
  def clear_active_connections!(*_arg0, **_arg1, &_arg2); end
  def clear_all_connections!(*_arg0, **_arg1, &_arg2); end
  def clear_cache!; end
  def clear_query_caches_for_current_thread; end
  def clear_reloadable_connections!(*_arg0, **_arg1, &_arg2); end
  def connected?; end
  def connected_to(role: T.unsafe(nil), shard: T.unsafe(nil), prevent_writes: T.unsafe(nil), &blk); end
  def connected_to?(role:, shard: T.unsafe(nil)); end
  def connected_to_many(*classes, role:, shard: T.unsafe(nil), prevent_writes: T.unsafe(nil)); end
  def connecting_to(role: T.unsafe(nil), shard: T.unsafe(nil), prevent_writes: T.unsafe(nil)); end
  def connection; end
  def connection_db_config; end
  def connection_pool; end
  def connection_specification_name; end
  def connection_specification_name=(_arg0); end
  def connects_to(database: T.unsafe(nil), shards: T.unsafe(nil)); end
  def establish_connection(config_or_env = T.unsafe(nil)); end
  def flush_idle_connections!(*_arg0, **_arg1, &_arg2); end
  def lookup_connection_handler(handler_key); end

  # Based on the default <tt>postgresql_connection</tt> definition from ActiveRecord.
  # https://github.com/rails/rails/blob/master/activerecord/lib/active_record/connection_adapters/postgresql_adapter.rb
  # FULL REPLACEMENT because we need to create a different class.
  def postgis_connection(config); end

  def postgresql_connection(config); end
  def primary_class?; end
  def prohibit_shard_swapping(enabled = T.unsafe(nil)); end
  def remove_connection(name = T.unsafe(nil)); end
  def retrieve_connection; end
  def shard_swapping_prohibited?; end
  def while_preventing_writes(enabled = T.unsafe(nil), &block); end

  private

  def append_to_connected_to_stack(entry); end
  def clear_on_handler(handler); end
  def resolve_config_for_connection(config_or_env); end
  def swap_connection_handler(handler, &blk); end
  def with_handler(handler_key, &blk); end
  def with_role_and_shard(role, shard, prevent_writes); end
end

ActiveRecord::ConnectionHandling::DEFAULT_ENV = T.let(T.unsafe(nil), Proc)
ActiveRecord::ConnectionHandling::RAILS_ENV = T.let(T.unsafe(nil), Proc)

class ActiveRecord::MigrationProxy < ::Struct
  def initialize(name, version, filename, scope); end

  def announce(*_arg0, **_arg1, &_arg2); end
  def basename; end
  def disable_ddl_transaction(*_arg0, **_arg1, &_arg2); end
  def filename; end
  def filename=(_); end
  def migrate(*_arg0, **_arg1, &_arg2); end
  def name; end
  def name=(_); end
  def scope; end
  def scope=(_); end
  def version; end
  def version=(_); end
  def write(*_arg0, **_arg1, &_arg2); end

  private

  def load_migration; end
  def migration; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class ActiveRecord::Point < ::Struct
  def x; end
  def x=(_); end
  def y; end
  def y=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

module ActiveRecord::Type
  extend ::ActiveRecord::ConnectionAdapters::PostGIS::Type

  class << self
    def adapter_name_from(model); end
    def add_modifier(*_arg0, **_arg1, &_arg2); end
    def default_value; end
    def register(type_name, klass = T.unsafe(nil), **options, &block); end
    def registry; end
    def registry=(_arg0); end

    private

    def current_adapter_name; end
  end
end

ActiveRecord::Type::BigInteger = ActiveModel::Type::BigInteger
ActiveRecord::Type::Binary = ActiveModel::Type::Binary
ActiveRecord::Type::Boolean = ActiveModel::Type::Boolean
ActiveRecord::Type::Decimal = ActiveModel::Type::Decimal
ActiveRecord::Type::Float = ActiveModel::Type::Float
ActiveRecord::Type::ImmutableString = ActiveModel::Type::ImmutableString
ActiveRecord::Type::Integer = ActiveModel::Type::Integer
ActiveRecord::Type::String = ActiveModel::Type::String
ActiveRecord::Type::Value = ActiveModel::Type::Value
ActiveRecord::UnknownAttributeError = ActiveModel::UnknownAttributeError

module Arel
  class << self
    def arel_node?(value); end
    def fetch_attribute(value, &block); end
    def spatial(arg); end
    def sql(raw_sql); end
    def star; end
  end
end

Arel::Attribute = Arel::Attributes::Attribute
Arel::VERSION = T.let(T.unsafe(nil), String)
module Arel::Visitors; end

class Arel::Visitors::PostGIS < ::Arel::Visitors::PostgreSQL
  include ::RGeo::ActiveRecord::SpatialToSql
  include ::RGeo::ActiveRecord::SpatialToPostGISSql
end

# Different super-class under JRuby JDBC adapter.
Arel::Visitors::PostGISSuperclass = Arel::Visitors::PostgreSQL

module RGeo; end

module RGeo::ActiveRecord
  class << self
    def geometric_type_from_name(name); end
    def spatial_expressions_supported?; end
  end
end

# Extend rgeo-activerecord visitors to use PostGIS specific functionality
module RGeo::ActiveRecord::SpatialToPostGISSql
  def visit_in_spatial_context(node, collector); end
end

RGeo::ActiveRecord::VERSION = T.let(T.unsafe(nil), String)
RGeo::VERSION = T.let(T.unsafe(nil), String)
