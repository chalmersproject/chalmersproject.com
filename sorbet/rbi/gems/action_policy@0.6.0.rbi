# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `action_policy` gem.
# Please instead update this file by running `bin/tapioca gem action_policy`.

# ActionPolicy is an authorization framework for Ruby/Rails applications.
#
# It provides a way to write access policies and helpers to check these policies
# in your application.
module ActionPolicy
  class << self
    # Returns the value of attribute cache_store.
    def cache_store; end

    # Sets the attribute cache_store
    def cache_store=(_arg0); end

    # Returns the value of attribute enforce_predicate_rules_naming.
    def enforce_predicate_rules_naming; end

    # Sets the attribute enforce_predicate_rules_naming
    def enforce_predicate_rules_naming=(_arg0); end

    # Find a policy class for a target
    def lookup(target, allow_nil: T.unsafe(nil), default: T.unsafe(nil), **options); end
  end
end

class ActionPolicy::AuthorizationContextMissing < ::ActionPolicy::Error
  def initialize(id); end

  def message; end
end

ActionPolicy::AuthorizationContextMissing::MESSAGE_TEMPLATE = T.let(T.unsafe(nil), String)

# The main purpose of this module is to extact authorize actions
# from everything else to make it easily testable.
module ActionPolicy::Authorizer
  class << self
    def authorize(policy, rule); end

    # Performs authorization, raises an exception when check failed.
    def call(policy, rule); end

    # Applies scope to the target
    def scopify(target, policy, **options); end
  end
end

# Base class for application policies.
class ActionPolicy::Base
  include ::ActionPolicy::Behaviours::PolicyFor
  include ::ActionPolicy::Policy::Core
  include ::ActionPolicy::Policy::Authorization
  include ::ActionPolicy::Policy::PreCheck
  include ::ActionPolicy::Policy::Reasons
  include ::ActionPolicy::Policy::Aliases
  include ::ActionPolicy::Behaviours::Scoping
  include ::ActionPolicy::Policy::Scoping
  include ::ActionPolicy::Policy::Cache
  include ::ActionPolicy::Policy::CachedApply
  include ::ActionPolicy::Policy::Defaults
  extend ::ActionPolicy::Policy::Core::ClassMethods
  extend ::ActionPolicy::Policy::Authorization::ClassMethods
  extend ::ActionPolicy::Policy::PreCheck::ClassMethods
  extend ::ActionPolicy::Policy::Aliases::ClassMethods
  extend ::ActionPolicy::Policy::Scoping::ClassMethods
  extend ::ActionPolicy::Policy::Cache::ClassMethods

  def user; end
end

class ActionPolicy::Base::APR < ::ActionPolicy::Policy::ExecutionResult
  include ::ActionPolicy::Policy::ResultFailureReasons
end

# Provides `authorize!` and `allowed_to?` methods and
# `authorize` class method to define authorization context.
#
# Could be included anywhere to perform authorization.
module ActionPolicy::Behaviour
  include ::ActionPolicy::Behaviours::PolicyFor
  include ::ActionPolicy::Behaviours::Scoping

  mixes_in_class_methods ::ActionPolicy::Behaviour::ClassMethods

  # Returns the authorization result object after applying a specified rule to a record.
  def allowance_to(rule, record = T.unsafe(nil), **options); end

  # Checks that an activity is allowed for the current context (e.g. user).
  #
  # Returns true of false.
  def allowed_to?(rule, record = T.unsafe(nil), **options); end

  def authorization_context; end

  # Check that rule is defined for policy,
  # otherwise fallback to :manage? rule.
  def authorization_rule_for(policy, rule); end

  # Authorize action against a policy.
  #
  # Policy is inferred from record
  # (unless explicitly specified through `with` option).
  #
  # Raises `ActionPolicy::Unauthorized` if check failed.
  def authorize!(record = T.unsafe(nil), to:, **options); end

  def lookup_authorization_policy(record, **options); end

  class << self
    def included(base); end
  end
end

module ActionPolicy::Behaviour::ClassMethods
  def authorization_targets; end

  # Configure authorization context.
  #
  # For example:
  #
  # class ApplicationController < ActionController::Base
  # # Pass the value of `current_user` to authorization as `user`
  # authorize :user, through: :current_user
  # end
  #
  # # Assuming that in your ApplicationPolicy
  # class ApplicationPolicy < ActionPolicy::Base
  # authorize :user
  # end
  def authorize(key, through: T.unsafe(nil)); end
end

module ActionPolicy::Behaviours; end

# Per-instance memoization for policies.
#
# Used by `policy_for` to re-use policy object for records.
#
# Example:
#
# include ActionPolicy::Behaviour
# include ActionPolicy::Memoized
#
# record = User.first
# policy = policy_for(record)
# policy2 = policy_for(record)
#
# policy.equal?(policy) #=> true
#
# policy.equal?(policy_for(record, with: CustomPolicy)) #=> false
module ActionPolicy::Behaviours::Memoized
  def __policies_cache__; end
  def __policy_memoize__(record, **options); end

  class << self
    def included(base); end
    def prepended(base); end
  end
end

module ActionPolicy::Behaviours::Memoized::InstanceMethods
  def policy_for(record:, **opts); end
end

# Adds an ability to lookup policies from current _context_ (namespace):
#
# module Admin
# class UsersController < ApplictionController
# def index
# # uses Admin::UserPolicy if any, otherwise fallbacks to UserPolicy
# authorize!
# end
# end
# end
#
# Modules nesting is also supported:
#
# module Admin
# module Client
# class UsersController < ApplictionController
# def index
# # lookup for Admin::Client::UserPolicy -> Admin::UserPolicy -> UserPolicy
# authorize!
# end
# end
# end
# end
#
# NOTE: in order to support namespaced lookup for non-inferrable resources,
# you should specify `policy_name` at a class level
# (instead of `policy_class`, which doesn't take into account namespaces):
#
# class Guest < User
# def self.policy_name
# "UserPolicy"
# end
# end
#
# NOTE: by default, we use class's name as a policy name; so, for namespaced
# resources the namespace part is also included:
#
# class Admin
# class User
# end
# end
#
# # search for Admin::UserPolicy, but not for UserPolicy
# authorize! Admin::User.new
#
# You can access the current authorization namespace through `authorization_namespace` method.
#
# You can also define your own namespacing logic by overriding `authorization_namespace`:
#
# def authorization_namespace
# return ::Admin if current_user.admin?
# return ::Staff if current_user.staff?
# # fallback to current namespace
# super
# end
module ActionPolicy::Behaviours::Namespaced
  class << self
    def included(base); end
    def prepended(base); end
  end
end

module ActionPolicy::Behaviours::Namespaced::InstanceMethods
  def authorization_namespace; end
end

module ActionPolicy::Behaviours::PolicyFor
  def authorization_context; end
  def authorization_namespace; end
  def authorization_strict_namespace; end
  def default_authorization_policy_class; end
  def implicit_authorization_target; end
  def implicit_authorization_target!; end
  def policy_for(record:, with: T.unsafe(nil), namespace: T.unsafe(nil), context: T.unsafe(nil), allow_nil: T.unsafe(nil), default: T.unsafe(nil), strict_namespace: T.unsafe(nil)); end
  def policy_for_cache_key(record:, with: T.unsafe(nil), namespace: T.unsafe(nil), context: T.unsafe(nil), **_arg4); end
end

module ActionPolicy::Behaviours::Scoping
  def authorization_scope_type_for(policy, target); end
  def authorized(target, type: T.unsafe(nil), as: T.unsafe(nil), scope_options: T.unsafe(nil), **options); end
  def authorized_scope(target, type: T.unsafe(nil), as: T.unsafe(nil), scope_options: T.unsafe(nil), **options); end
end

# Per-thread memoization for policies.
#
# Used by `policy_for` to re-use policy object for records.
#
# NOTE: don't forget to clear thread cache with ActionPolicy::PerThreadCache.clear_all
module ActionPolicy::Behaviours::ThreadMemoized
  def __policy_thread_memoize__(record, **options); end

  class << self
    def included(base); end
    def prepended(base); end
  end
end

module ActionPolicy::Behaviours::ThreadMemoized::InstanceMethods
  def policy_for(record:, **opts); end
end

# By default cache namespace (or prefix) contains major and minor version of the gem
ActionPolicy::CACHE_NAMESPACE = T.let(T.unsafe(nil), String)

# Channel concern.
# Add `authorize!` and `allowed_to?` methods.
module ActionPolicy::Channel
  include ::ActionPolicy::Behaviours::Namespaced::InstanceMethods
  include ::ActionPolicy::Behaviours::PolicyFor
  include ::ActionPolicy::Behaviours::Scoping
  include ::ActionPolicy::Behaviour
  include ::ActionPolicy::Behaviours::Namespaced
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionPolicy::Channel::ClassMethods
end

module ActionPolicy::Channel::ClassMethods
  include ::ActionPolicy::Behaviour::ClassMethods
end

# Controller concern.
# Add `authorize!` and `allowed_to?` methods,
# provide `verify_authorized` hook.
module ActionPolicy::Controller
  include ::ActionPolicy::Behaviours::ThreadMemoized::InstanceMethods
  include ::ActionPolicy::Behaviours::Memoized::InstanceMethods
  include ::ActionPolicy::Behaviours::Namespaced::InstanceMethods
  include ::ActionPolicy::Behaviours::PolicyFor
  include ::ActionPolicy::Behaviours::Scoping
  include ::ActionPolicy::Behaviour
  include ::ActionPolicy::Behaviours::ThreadMemoized
  include ::ActionPolicy::Behaviours::Memoized
  include ::ActionPolicy::Behaviours::Namespaced
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionPolicy::Controller::ClassMethods

  # Authorize action against a policy.
  #
  # Policy is inferred from record
  # (unless explicitly specified through `with` option).
  #
  # If action is not provided, it's inferred from `action_name`.
  #
  # If record is not provided, tries to infer the resource class
  # from controller name (i.e. `controller_name.classify.safe_constantize`).
  #
  # Raises `ActionPolicy::Unauthorized` if check failed.
  def authorize!(record = T.unsafe(nil), to: T.unsafe(nil), **options); end

  def authorize_count; end

  # Tries to infer the resource class from controller name
  # (i.e. `controller_name.classify.safe_constantize`).
  def implicit_authorization_target; end

  def skip_verify_authorized!; end
  def verify_authorized; end
end

module ActionPolicy::Controller::ClassMethods
  include ::ActionPolicy::Behaviour::ClassMethods

  def skip_verify_authorized(**options); end
  def verify_authorized(**options); end
end

class ActionPolicy::Error < ::StandardError; end
module ActionPolicy::Ext; end

# Add Module#namespace method
module ActionPolicy::Ext::ModuleNamespace; end

module ActionPolicy::Ext::ModuleNamespace::Ext
  def namespace; end
end

# Adds #_policy_cache_key method to Object,
# which just call #policy_cache_key or #cache_key
# or #object_id (if `use_object_id` parameter is set to true).
#
# For other core classes returns string representation.
#
# Raises ArgumentError otherwise.
module ActionPolicy::Ext::PolicyCacheKey; end

module ActionPolicy::Ext::PolicyCacheKey::ObjectExt
  def _policy_cache_key(use_object_id: T.unsafe(nil)); end
end

# Add `camelize` to Symbol
module ActionPolicy::Ext::SymbolCamelize; end

module ActionPolicy::I18n
  class << self
    def full_message(policy_class, rule, details = T.unsafe(nil)); end

    private

    def candidates_for(policy_class, rule); end
  end
end

ActionPolicy::I18n::DEFAULT_UNAUTHORIZED_MESSAGE = T.let(T.unsafe(nil), String)

# LookupChain contains _resolvers_ to determine a policy
# for a record (with additional options).
#
# You can modify the `LookupChain.chain` (for example, to add
# custom resolvers).
module ActionPolicy::LookupChain
  class << self
    def call(record, **opts); end

    # Returns the value of attribute chain.
    def chain; end

    # Sets the attribute chain
    def chain=(_arg0); end

    # Returns the value of attribute namespace_cache_enabled.
    def namespace_cache_enabled; end

    # Sets the attribute namespace_cache_enabled
    def namespace_cache_enabled=(_arg0); end

    # Returns the value of attribute namespace_cache_enabled.
    def namespace_cache_enabled?; end

    private

    def lookup_within_namespace(policy_name, namespace, strict: T.unsafe(nil)); end
    def policy_class_name_for(record); end
  end
end

# (Optional) Infer using String#classify if available
ActionPolicy::LookupChain::CLASSIFY_SYMBOL_LOOKUP = T.let(T.unsafe(nil), Proc)

# By record's class `policy_class` method
ActionPolicy::LookupChain::CLASS_POLICY_CLASS = T.let(T.unsafe(nil), Proc)

# Infer from class name
ActionPolicy::LookupChain::INFER_FROM_CLASS = T.let(T.unsafe(nil), Proc)

# By self `policy_class` method
ActionPolicy::LookupChain::INSTANCE_POLICY_CLASS = T.let(T.unsafe(nil), Proc)

# Cache namespace resolving result for policies.
class ActionPolicy::LookupChain::NamespaceCache
  class << self
    def clear; end
    def fetch(namespace, policy, strict:, &block); end
    def put_if_absent(scope, namespace, policy); end

    # Returns the value of attribute store.
    def store; end
  end
end

# Infer from passed symbol
ActionPolicy::LookupChain::SYMBOL_LOOKUP = T.let(T.unsafe(nil), Proc)

class ActionPolicy::NonPredicateRule < ::ActionPolicy::UnknownRule
  def initialize(policy, rule); end
end

# Raised when Action Policy fails to find a policy class for a record.
class ActionPolicy::NotFound < ::ActionPolicy::Error
  def initialize(target, message = T.unsafe(nil)); end

  # Returns the value of attribute message.
  def message; end

  # Returns the value of attribute target.
  def target; end
end

module ActionPolicy::PerThreadCache
  class << self
    def clear_all; end

    # Sets the attribute enabled
    def enabled=(_arg0); end

    def enabled?; end
    def fetch(key); end
  end
end

ActionPolicy::PerThreadCache::CACHE_KEY = T.let(T.unsafe(nil), String)
module ActionPolicy::Policy; end

# Adds rules aliases support and ability to specify
# the default rule.
#
# class ApplicationPolicy
# include ActionPolicy::Policy::Core
# include ActionPolicy::Policy::Aliases
#
# # define which rule to use if `authorize!` called with
# # unknown rule
# default_rule :manage?
#
# alias_rule :publish?, :unpublish?, to: :update?
# end
#
# Aliases are used only during `authorize!` call (and do not act like _real_ aliases).
#
# Aliases useful when combined with `CachedApply` (since we can cache only the target rule).
module ActionPolicy::Policy::Aliases
  mixes_in_class_methods ::ActionPolicy::Policy::Aliases::ClassMethods

  def resolve_rule(activity); end

  private

  def check_rule_naming(activity); end

  class << self
    def included(base); end
  end
end

module ActionPolicy::Policy::Aliases::ClassMethods
  def alias_rule(*rules, to:); end
  def default_rule(val); end
  def lookup_alias(rule); end
  def lookup_default_rule; end
  def method_added(name); end
  def rules_aliases; end
end

ActionPolicy::Policy::Aliases::DEFAULT = T.let(T.unsafe(nil), Symbol)

module ActionPolicy::Policy::Authorization
  mixes_in_class_methods ::ActionPolicy::Policy::Authorization::ClassMethods

  def initialize(record = T.unsafe(nil), **params); end

  def authorization_context; end

  class << self
    def included(base); end
  end
end

module ActionPolicy::Policy::Authorization::ClassMethods
  def authorization_targets; end
  def authorize(*ids, allow_nil: T.unsafe(nil), optional: T.unsafe(nil)); end
end

# Provides long-lived cache through ActionPolicy.cache_store.
#
# NOTE: if cache_store is nil then we silently skip all the caching.
module ActionPolicy::Policy::Cache
  mixes_in_class_methods ::ActionPolicy::Policy::Cache::ClassMethods

  def apply(rule); end
  def apply_with_cache(rule); end
  def cache(*parts, **options); end
  def cache_key(*parts); end
  def cache_namespace; end
  def context_cache_key; end
  def rule_cache_key(rule); end

  class << self
    def included(base); end
  end
end

module ActionPolicy::Policy::Cache::ClassMethods
  def cache(*rules, **options); end
  def cached_rules; end
end

# Per-policy cache for applied rules.
#
# When you call `apply` twice on the same policy and for the same rule,
# the check (and pre-checks) is only called once.
module ActionPolicy::Policy::CachedApply
  def apply(rule); end
end

# Core policy API
module ActionPolicy::Policy::Core
  include ::ActionPolicy::Behaviours::PolicyFor

  mixes_in_class_methods ::ActionPolicy::Policy::Core::ClassMethods

  # NEXT_RELEASE: deprecate `record` arg, migrate to `record: nil`
  def initialize(record = T.unsafe(nil), *_arg1); end

  # This method performs the rule call.
  # Override or extend it to provide custom functionality
  # (such as caching, pre checks, etc.)
  def __apply__(rule); end

  def allow!; end

  # Returns a result of applying the specified rule to the specified record.
  # Under the hood a policy class for record is resolved
  # (unless it's explicitly set through `with` option).
  #
  # If record is `nil` then we uses the current policy.
  def allowed_to?(rule, record = T.unsafe(nil), **options); end

  # Returns a result of applying the specified rule (true of false).
  # Unlike simply calling a predicate rule (`policy.manage?`),
  # `apply` also calls pre-checks.
  def apply(rule); end

  # An alias for readability purposes
  def check?(*args, **hargs); end

  def deny!; end

  # Return annotated source code for the rule
  # NOTE: require "method_source" and "unparser" gems to be installed.
  # Otherwise returns empty string.
  def inspect_rule(rule); end

  # Helper for printing the annotated rule source.
  # Useful for debugging: type `pp :show?` within the context of the policy
  # to preview the rule.
  def pp(rule); end

  # Returns the value of attribute record.
  def record; end

  # Returns a rule name (policy method name) for activity.
  #
  # By default, rule name is equal to activity name.
  #
  # Raises ActionPolicy::UknownRule when rule is not found in policy.
  def resolve_rule(activity); end

  # Returns the value of attribute result.
  def result; end

  # Wrap code that could modify result
  # to prevent the current result modification
  def with_clean_result; end

  class << self
    def included(base); end
  end
end

module ActionPolicy::Policy::Core::ClassMethods
  def identifier; end

  # Sets the attribute identifier
  def identifier=(_arg0); end

  def result_class; end
end

# Create default rules and aliases:
# - `index?` (=`false`)
# - `create?` (=`false`)
# - `new?` as an alias for `create?`
# - `manage?` as a fallback for all unspecified rules (default rule)
module ActionPolicy::Policy::Defaults
  def create?; end
  def index?; end
  def manage?; end

  class << self
    def included(base); end
  end
end

# Result of applying a policy rule
#
# This class could be extended by some modules to provide
# additional functionality
class ActionPolicy::Policy::ExecutionResult
  def initialize(policy, rule); end

  def cached!; end
  def cached?; end
  def fail?; end
  def inspect; end

  # Populate the final value
  def load(value); end

  # Returns the value of attribute policy.
  def policy; end

  # Returns the value of attribute rule.
  def rule; end

  def success?; end

  # Returns the value of attribute value.
  def value; end
end

# Failures reasons store
class ActionPolicy::Policy::FailureReasons
  def initialize; end

  def add(policy_or_class, rule, details = T.unsafe(nil)); end

  # Return Hash of the form:
  # { policy_identifier => [rules, ...] }
  def details; end

  def empty?; end
  def merge(other); end
  def present?; end

  # Returns the value of attribute reasons.
  def reasons; end

  private

  def add_detailed_reason(store, detailed_rule); end
  def add_non_detailed_reason(store, rule); end
  def with_details(rule, details); end
end

# Adds callback-style checks to policies to
# extract common checks from rules.
#
# class ApplicationPolicy < ActionPolicy::Base
# authorize :user
# pre_check :allow_admins
#
# private
# # Allow every action for admins
# def allow_admins
# allow! if user.admin?
# end
# end
#
# You can specify conditional pre-checks (through `except` / `only`) options
# and skip already defined pre-checks if necessary.
#
# class UserPolicy < ApplicationPolicy
# skip_pre_check :allow_admins, only: :destroy?
#
# def destroy?
# user.admin? && !record.admin?
# end
# end
module ActionPolicy::Policy::PreCheck
  mixes_in_class_methods ::ActionPolicy::Policy::PreCheck::ClassMethods

  def __apply__(rule); end
  def run_pre_checks(rule); end

  class << self
    def included(base); end
  end
end

# Single pre-check instance.
#
# Implements filtering logic.
class ActionPolicy::Policy::PreCheck::Check
  def initialize(policy, name, except: T.unsafe(nil), only: T.unsafe(nil)); end

  def applicable?(rule); end
  def call(policy); end
  def dup; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute policy_class.
  def policy_class; end

  def skip!(except: T.unsafe(nil), only: T.unsafe(nil)); end

  private

  # Returns the value of attribute blacklist.
  def blacklist; end

  # Returns the value of attribute filter.
  def filter; end

  def rebuild_filter; end

  # Returns the value of attribute whitelist.
  def whitelist; end
end

module ActionPolicy::Policy::PreCheck::ClassMethods
  def pre_check(*names, **options); end
  def pre_checks; end
  def skip_pre_check(*names, **options); end
end

# Provides failure reasons tracking functionality.
# That allows you to distinguish between the reasons why authorization was rejected.
#
# It's helpful when you compose policies (i.e. use one policy within another).
#
# For example:
#
# class ApplicantPolicy < ApplicationPolicy
# def show?
# user.has_permission?(:view_applicants) &&
# allowed_to?(:show?, object.stage)
# end
# end
#
# Now when you receive an exception, you have a reasons object, which contains additional
# information about the failure:
#
# rescue_from ActionPolicy::Unauthorized do |ex|
# ex.policy #=> ApplicantPolicy
# ex.rule #=> :show?
# ex.result.reasons.details  #=> {stage: [:show?]}
# end
#
# NOTE: the reason key (`stage`) is a policy identifier (underscored class name by default).
# For namespaced policies it has a form of:
#
# class Admin::UserPolicy < ApplicationPolicy
# # ..
# end
#
# reasons.details #=> {:"admin/user" => [:show?]}
#
#
# You can also wrap _local_ rules into `allowed_to?` to populate reasons:
#
# class ApplicantPolicy < ApplicationPolicy
# def show?
# allowed_to?(:view_applicants?) &&
# allowed_to?(:show?, object.stage)
# end
#
# def view_applicants?
# user.has_permission?(:view_applicants)
# end
# end
#
# NOTE: there is `check?` alias for `allowed_to?`.
#
# You can provide additional details to your failure reasons by using
# a `details: { ... }` option:
#
# class ApplicantPolicy < ApplicationPolicy
# def show?
# allowed_to?(:show?, object.stage)
# end
# end
#
# class StagePolicy < ApplicationPolicy
# def show?
# # Add stage title to the failure reason (if any)
# # (could be used by client to show more descriptive message)
# details[:title] = record.title
#
# # then perform the checks
# user.stages.where(id: record.id).exists?
# end
# end
#
# # when accessing the reasons
# p ex.result.reasons.details #=> { stage: [{show?: {title: "Onboarding"}] }
#
# NOTE: when using detailed reasons, the `details` array contains as the last element
# a hash with ALL details reasons for the policy (in a form of <rule> => <details>).
module ActionPolicy::Policy::Reasons
  def allowed_to?(rule, record = T.unsafe(nil), inline_reasons: T.unsafe(nil), **options); end
  def deny!(reason = T.unsafe(nil)); end

  # Add additional details to the failure reason
  def details; end

  class << self
    def included(base); end
  end
end

# Extend ExecutionResult with `reasons` method
module ActionPolicy::Policy::ResultFailureReasons
  # Returns all the details merged together
  def all_details; end

  def clear_details; end

  # Returns the value of attribute details.
  def details; end

  # Sets the attribute details
  def details=(_arg0); end

  # Add reasons to inspect
  def inspect; end

  def reasons; end
end

# Scoping is used to modify the _object under authorization_.
#
# The most common situation is when you want to _scope_ the collection depending
# on the current user permissions.
#
# For example:
#
# class ApplicationPolicy < ActionPolicy::Base
# # Scoping only makes sense when you have the authorization context
# authorize :user
#
# # :relation here is a scoping type
# scope_for :relation do |relation|
# # authorization context is available within a scope
# if user.admin?
# relation
# else
# relation.publicly_visible
# end
# end
# end
#
# base_scope = User.all
# authorized_scope = ApplicantPolicy.new(user: user)
# .apply_scope(base_scope, type: :relation)
module ActionPolicy::Policy::Scoping
  include ::ActionPolicy::Behaviours::Scoping

  mixes_in_class_methods ::ActionPolicy::Policy::Scoping::ClassMethods

  # Pass target to the scope handler of the specified type and name.
  # If `name` is not specified then `:default` name is used.
  # If `type` is not specified then we try to infer the type from the
  # target class.
  def apply_scope(target, type:, name: T.unsafe(nil), scope_options: T.unsafe(nil)); end

  def lookup_type_from_target(target); end
  def resolve_scope_type(target); end

  class << self
    def included(base); end
  end
end

module ActionPolicy::Policy::Scoping::ClassMethods
  # Register a new scoping method for the `type`
  def scope_for(type, name = T.unsafe(nil), &block); end

  # Define scope type matcher.
  #
  # Scope matcher is an object that implements `#===` (_case equality_) or a Proc.
  #
  # When no type is provided when applying a scope we try to infer a type
  # from the target object by calling matchers one by one until we find a matching
  # type (i.e. there is a matcher which returns `true` when applying it to the target).
  def scope_matcher(type, class_or_proc); end

  def scope_matchers; end
  def scoping_handlers; end
end

module ActionPolicy::PrettyPrint
  class << self
    def available?; end
    def colorize(val); end
    def ignore_expressions; end
    def ignore_expressions=(_arg0); end
    def print_method(object, method_name); end
  end
end

ActionPolicy::PrettyPrint::FALSE = T.let(T.unsafe(nil), String)
ActionPolicy::PrettyPrint::TRUE = T.let(T.unsafe(nil), String)

class ActionPolicy::PrettyPrint::Visitor
  def initialize(object); end

  def collect(ast); end
  def eval_exp(exp); end
  def expression_with_result(sexp); end
  def ignore_exp?(exp); end
  def indent; end
  def indent=(_arg0); end
  def indented(str); end
  def lines; end
  def object; end
  def visit_and(ast); end
  def visit_begin(ast); end
  def visit_missing(ast); end
  def visit_node(ast); end
  def visit_or(ast); end
end

class ActionPolicy::Railtie < ::Rails::Railtie; end

# Provides Rails-specific configuration,
# accessible through `Rails.application.config.action_policy`
module ActionPolicy::Railtie::Config
  class << self
    # Define whether we need to include ActionCable::Channel::Base
    # with the default authorization logic
    def auto_inject_into_channel; end

    # Define whether we need to include ActionCable::Channel::Base
    # with the default authorization logic
    def auto_inject_into_channel=(_arg0); end

    # Define whether we need to extend ApplicationController::Base
    # with the default authorization logic
    def auto_inject_into_controller; end

    # Define whether we need to extend ApplicationController::Base
    # with the default authorization logic
    def auto_inject_into_controller=(_arg0); end

    def cache_store=(store); end

    # Define whether we want to specify `current_user` as
    # the default authorization context in channels
    def channel_authorize_current_user; end

    # Define whether we want to specify `current_user` as
    # the default authorization context in channels
    def channel_authorize_current_user=(_arg0); end

    # Define whether we want to specify `current_user` as
    # the default authorization context in controller
    def controller_authorize_current_user; end

    # Define whether we want to specify `current_user` as
    # the default authorization context in controller
    def controller_authorize_current_user=(_arg0); end

    # Define whether to include instrumentation functionality.
    # Enabled by default.
    def instrumentation_enabled; end

    # Define whether to include instrumentation functionality.
    # Enabled by default.
    def instrumentation_enabled=(_arg0); end

    # Define whether to cache namespaced policy resolution
    # result (e.g. in controllers).
    # Enabled only in production by default.
    def namespace_cache_enabled; end

    # Define whether to cache namespaced policy resolution
    # result (e.g. in controllers).
    # Enabled only in production by default.
    def namespace_cache_enabled=(_arg0); end
  end
end

# Adds `suggest` method which uses did_you_mean
# to generate a suggestion message
module ActionPolicy::SuggestMessage
  def suggest(needle, heystack); end
end

# Raised when `authorize!` check fails
class ActionPolicy::Unauthorized < ::ActionPolicy::Error
  def initialize(policy, rule); end

  # Returns the value of attribute policy.
  def policy; end

  # Returns the value of attribute result.
  def result; end

  # Returns the value of attribute rule.
  def rule; end
end

# Raised when `authorize!` hasn't been called for action
class ActionPolicy::UnauthorizedAction < ::ActionPolicy::Error
  def initialize(controller, action); end
end

class ActionPolicy::UnknownNamedScope < ::ActionPolicy::Error
  include ::ActionPolicy::SuggestMessage

  def initialize(policy_class, type, name); end

  # Returns the value of attribute message.
  def message; end
end

ActionPolicy::UnknownNamedScope::MESSAGE_TEMPLATE = T.let(T.unsafe(nil), String)

# Raised when `resolve_rule` failed to find an approriate
# policy rule method for the activity
class ActionPolicy::UnknownRule < ::ActionPolicy::Error
  include ::ActionPolicy::SuggestMessage

  def initialize(policy, rule); end

  # Returns the value of attribute message.
  def message; end

  # Returns the value of attribute policy.
  def policy; end

  # Returns the value of attribute rule.
  def rule; end
end

class ActionPolicy::UnknownScopeType < ::ActionPolicy::Error
  include ::ActionPolicy::SuggestMessage

  def initialize(policy_class, type); end

  # Returns the value of attribute message.
  def message; end
end

ActionPolicy::UnknownScopeType::MESSAGE_TEMPLATE = T.let(T.unsafe(nil), String)

class ActionPolicy::UnrecognizedScopeTarget < ::ActionPolicy::Error
  def initialize(target); end

  # Returns the value of attribute message.
  def message; end
end

ActionPolicy::UnrecognizedScopeTarget::MESSAGE_TEMPLATE = T.let(T.unsafe(nil), String)
ActionPolicy::VERSION = T.let(T.unsafe(nil), String)
