# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `amazing_print` gem.
# Please instead update this file by running `bin/tapioca gem amazing_print`.

module AmazingPrint
  class << self
    def console?; end

    # Returns the value of attribute defaults.
    def defaults; end

    # Sets the attribute defaults
    def defaults=(_arg0); end

    def diet_rb; end

    # Returns the value of attribute force_colors.
    def force_colors; end

    # Class accessor to force colorized output (ex. forked subprocess where TERM
    # might be dumb).
    # ---------------------------------------------------------------------------
    def force_colors!(colors: T.unsafe(nil)); end

    # Sets the attribute force_colors
    def force_colors=(_arg0); end

    def irb!; end
    def pry!; end
    def rails_console?; end

    # Reload the cached custom configurations.
    def reload!; end

    def usual_rb; end
    def version; end

    private

    # Takes a value and returns true unless it is false or nil
    # This is an alternative to the less readable !!(value)
    # https://github.com/bbatsov/ruby-style-guide#no-bang-bang
    def boolean(value); end
  end
end

module AmazingPrint::ActionView
  # Use HTML colors and add default "debug_dump" class to the resulting HTML.
  def ap(object, options = T.unsafe(nil)); end

  # Use HTML colors and add default "debug_dump" class to the resulting HTML.
  def ap_debug(object, options = T.unsafe(nil)); end
end

module AmazingPrint::ActiveRecord
  # Add ActiveRecord class names to the dispatcher pipeline.
  # ------------------------------------------------------------------------------
  def cast_with_active_record(object, type); end

  private

  # Format ActiveModel error object.
  # ------------------------------------------------------------------------------
  def awesome_active_model_error(object); end

  # Format ActiveRecord class object.
  # ------------------------------------------------------------------------------
  def awesome_active_record_class(object); end

  # Format ActiveRecord instance object.
  #
  # NOTE: by default only instance attributes (i.e. columns) are shown. To format
  # ActiveRecord instance as regular object showing its instance variables and
  # accessors use :raw => true option:
  #
  # ap record, :raw => true
  #
  # ------------------------------------------------------------------------------
  def awesome_active_record_instance(object); end

  class << self
    def included(base); end
  end
end

module AmazingPrint::ActiveSupport
  # Format ActiveSupport::TimeWithZone as standard Time.
  # ------------------------------------------------------------------------------
  def awesome_active_support_time(object); end

  # Format HashWithIndifferentAccess as standard Hash.
  # ------------------------------------------------------------------------------
  def awesome_hash_with_indifferent_access(object); end

  def cast_with_active_support(object, type); end

  class << self
    def included(base); end
  end
end

module AmazingPrint::Colorize
  # Pick the color and apply it to the given string as necessary.
  # ------------------------------------------------------------------------------
  def colorize(str, type); end
end

class AmazingPrint::Formatter
  include ::AmazingPrint::Colorize
  include ::AmazingPrint::ActiveRecord
  include ::AmazingPrint::ActiveSupport
  include ::AmazingPrint::Nokogiri
  include ::AmazingPrint::OpenStruct

  def initialize(inspector); end

  # Hook this when adding custom formatters. Check out lib/amazing_print/ext
  # directory for custom formatters that ship with amazing_print.
  # ------------------------------------------------------------------------------
  def cast(object, type); end

  def cast_without_active_record(_object, type); end
  def cast_without_active_support(object, type); end
  def cast_without_nokogiri(object, type); end
  def cast_without_ostruct(object, type); end

  # Main entry point to format an object.
  # ------------------------------------------------------------------------------
  def format(object, type = T.unsafe(nil)); end

  # Returns the value of attribute inspector.
  def inspector; end

  # Returns the value of attribute options.
  def options; end

  private

  def awesome_array(a); end
  def awesome_bigdecimal(n); end
  def awesome_class(c); end
  def awesome_dir(d); end
  def awesome_file(f); end
  def awesome_hash(h); end
  def awesome_method(m); end
  def awesome_object(o); end
  def awesome_rational(n); end

  # Catch all method to format an arbitrary object.
  # ------------------------------------------------------------------------------
  def awesome_self(object, type); end

  def awesome_set(s); end
  def awesome_simple(o, type, inspector = T.unsafe(nil)); end
  def awesome_struct(s); end
  def awesome_unboundmethod(m); end

  # Utility methods.
  # ------------------------------------------------------------------------------
  def convert_to_hash(object); end
end

AmazingPrint::Formatter::CORE_FORMATTERS = T.let(T.unsafe(nil), Array)
module AmazingPrint::Formatters; end

class AmazingPrint::Formatters::ArrayFormatter < ::AmazingPrint::Formatters::BaseFormatter
  def initialize(array, inspector); end

  # Returns the value of attribute array.
  def array; end

  def format; end

  # Returns the value of attribute inspector.
  def inspector; end

  # Returns the value of attribute options.
  def options; end

  private

  def array_prefix(iteration, width); end
  def find_method(name); end
  def generate_printable_array; end
  def generate_printable_tuples; end
  def generate_tuple(name); end
  def generic_prefix(iteration, width, padding = T.unsafe(nil)); end
  def methods_array; end
  def methods_array?; end
  def multiline_array; end
  def name_and_args_width; end
  def simple_array; end
  def tuple_prefix(iteration, width); end
  def tuple_template(item); end
  def tuples; end
  def width(items); end
end

class AmazingPrint::Formatters::BaseFormatter
  include ::AmazingPrint::Colorize

  def align(value, width); end
  def get_limit_size; end
  def indent(n = T.unsafe(nil)); end

  # Indentation related methods
  # -----------------------------------------
  def indentation; end

  def indented(&blk); end
  def limited(data, width, is_hash: T.unsafe(nil)); end
  def method_tuple(method); end
  def outdent; end

  # To support limited output, for example:
  #
  # ap ('a'..'z').to_a, :limit => 3
  # [
  # [ 0] "a",
  # [ 1] .. [24],
  # [25] "z"
  # ]
  #
  # ap (1..100).to_a, :limit => true # Default limit is 7.
  # [
  # [ 0] 1,
  # [ 1] 2,
  # [ 2] 3,
  # [ 3] .. [96],
  # [97] 98,
  # [98] 99,
  # [99] 100
  # ]
  # ------------------------------------------------------------------------------
  def should_be_limited?; end
end

AmazingPrint::Formatters::BaseFormatter::DEFAULT_LIMIT_SIZE = T.let(T.unsafe(nil), Integer)

# precompute common indentations
AmazingPrint::Formatters::BaseFormatter::INDENT_CACHE = T.let(T.unsafe(nil), Array)

class AmazingPrint::Formatters::ClassFormatter < ::AmazingPrint::Formatters::BaseFormatter
  def initialize(klass, inspector); end

  def format; end

  # Returns the value of attribute inspector.
  def inspector; end

  # Returns the value of attribute klass.
  def klass; end

  # Returns the value of attribute options.
  def options; end
end

class AmazingPrint::Formatters::DirFormatter < ::AmazingPrint::Formatters::BaseFormatter
  def initialize(dir, inspector); end

  # Returns the value of attribute dir.
  def dir; end

  def format; end

  # Returns the value of attribute inspector.
  def inspector; end

  # Returns the value of attribute options.
  def options; end
end

class AmazingPrint::Formatters::FileFormatter < ::AmazingPrint::Formatters::BaseFormatter
  def initialize(file, inspector); end

  # Returns the value of attribute file.
  def file; end

  def format; end

  # Returns the value of attribute inspector.
  def inspector; end

  # Returns the value of attribute options.
  def options; end
end

class AmazingPrint::Formatters::HashFormatter < ::AmazingPrint::Formatters::BaseFormatter
  def initialize(hash, inspector); end

  def format; end

  # Returns the value of attribute hash.
  def hash; end

  # Returns the value of attribute inspector.
  def inspector; end

  # Returns the value of attribute options.
  def options; end

  private

  def empty_hash; end
  def left_width(keys); end
  def max_key_width(keys); end
  def multiline_hash; end
  def multiline_hash?; end
  def plain_single_line; end
  def pre_ruby19_syntax(key, value, width); end
  def printable_hash; end
  def printable_keys; end
  def ruby19_syntax(key, value, width); end
  def simple_hash; end
  def symbol?(key); end
end

class AmazingPrint::Formatters::MethodFormatter < ::AmazingPrint::Formatters::BaseFormatter
  def initialize(method, inspector); end

  def format; end

  # Returns the value of attribute inspector.
  def inspector; end

  # Returns the value of attribute method.
  def method; end

  # Returns the value of attribute options.
  def options; end
end

class AmazingPrint::Formatters::ObjectFormatter < ::AmazingPrint::Formatters::BaseFormatter
  def initialize(object, inspector); end

  def format; end

  # Returns the value of attribute inspector.
  def inspector; end

  # Returns the value of attribute object.
  def object; end

  # Returns the value of attribute options.
  def options; end

  # Returns the value of attribute variables.
  def variables; end

  private

  def awesome_instance; end
  def left_aligned; end
  def valid_instance_var?(variable_name); end
end

class AmazingPrint::Formatters::SimpleFormatter < ::AmazingPrint::Formatters::BaseFormatter
  def initialize(string, type, inspector); end

  def format; end

  # Returns the value of attribute inspector.
  def inspector; end

  # Returns the value of attribute options.
  def options; end

  # Returns the value of attribute string.
  def string; end

  # Returns the value of attribute type.
  def type; end
end

class AmazingPrint::Formatters::StructFormatter < ::AmazingPrint::Formatters::BaseFormatter
  def initialize(struct, inspector); end

  def format; end

  # Returns the value of attribute inspector.
  def inspector; end

  # Returns the value of attribute options.
  def options; end

  # Returns the value of attribute struct.
  def struct; end

  # Returns the value of attribute variables.
  def variables; end

  private

  def awesome_instance; end
  def left_aligned; end
end

class AmazingPrint::Indentator
  def initialize(indentation); end

  def indent; end

  # Returns the value of attribute indentation.
  def indentation; end

  # Returns the value of attribute shift_width.
  def shift_width; end
end

class AmazingPrint::Inspector
  def initialize(options = T.unsafe(nil)); end

  # Dispatcher that detects data nesting and invokes object-aware formatter.
  # ---------------------------------------------------------------------------
  def awesome(object); end

  # Return true if we are to colorize the output.
  # ---------------------------------------------------------------------------
  def colorize?; end

  def current_indentation; end
  def increase_indentation(&blk); end

  # Returns the value of attribute indentator.
  def indentator; end

  # Sets the attribute indentator
  def indentator=(_arg0); end

  # Returns the value of attribute options.
  def options; end

  # Sets the attribute options
  def options=(_arg0); end

  private

  def dotfile_readable?(dotfile); end
  def find_dotfile; end

  # This method needs to be mocked during testing so that it always loads
  # predictable values
  # ---------------------------------------------------------------------------
  def load_dotfile; end

  # Load ~/.aprc file with custom defaults that override default options.
  # ---------------------------------------------------------------------------
  def merge_custom_defaults!; end

  # Update @options by first merging the :color hash and then the remaining
  # keys.
  # ---------------------------------------------------------------------------
  def merge_options!(options = T.unsafe(nil)); end

  # Format nested data, for example:
  # arr = [1, 2]; arr << arr
  # => [1,2, [...]]
  # hash = { :a => 1 }; hash[:b] = hash
  # => { :a => 1, :b => {...} }
  # ---------------------------------------------------------------------------
  def nested(object); end

  # Turn class name into symbol, ex: Hello::World => :hello_world. Classes
  # that inherit from Array, Hash, File, Dir, and Struct are treated as the
  # base class.
  # ---------------------------------------------------------------------------
  def printable(object); end

  # ---------------------------------------------------------------------------
  def unnested(object); end

  class << self
    # Unload the cached dotfile and load it again.
    def reload_dotfile; end
  end
end

AmazingPrint::Inspector::AP = T.let(T.unsafe(nil), Symbol)

module AmazingPrint::Logger
  # Add ap method to logger
  # ------------------------------------------------------------------------------
  def ap(object, options = T.unsafe(nil)); end
end

module AmazingPrint::Nokogiri
  # ------------------------------------------------------------------------------
  def awesome_nokogiri_xml_node(object); end

  # Add Nokogiri XML Node and NodeSet names to the dispatcher pipeline.
  # ------------------------------------------------------------------------------
  def cast_with_nokogiri(object, type); end

  class << self
    def included(base); end
  end
end

module AmazingPrint::OpenStruct
  def awesome_open_struct_instance(object); end
  def cast_with_ostruct(object, type); end

  class << self
    def included(base); end
  end
end

module AwesomeMethodArray
  def &(other); end
  def -(other); end

  # Intercepting Array#grep needs a special treatment since grep accepts
  # an optional block.
  def grep(pattern, &blk); end
end

module Kernel
  def ai(options = T.unsafe(nil)); end
  def amazing_print(object, options = T.unsafe(nil)); end
  def awesome_inspect(options = T.unsafe(nil)); end

  private

  def ap(object, options = T.unsafe(nil)); end

  class << self
    def ap(object, options = T.unsafe(nil)); end
  end
end

class String
  include ::Comparable
  include ::JSON::Ext::Generator::GeneratorMethods::String
  include ::MessagePack::CoreExt
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend

  def blue(html = T.unsafe(nil), *_arg1); end
  def blueish(html = T.unsafe(nil), *_arg1); end
  def cyan(html = T.unsafe(nil), *_arg1); end
  def cyanish(html = T.unsafe(nil), *_arg1); end
  def gray(html = T.unsafe(nil), *_arg1); end
  def grayish(html = T.unsafe(nil), *_arg1); end
  def green(html = T.unsafe(nil), *_arg1); end
  def greenish(html = T.unsafe(nil), *_arg1); end
  def purple(html = T.unsafe(nil), *_arg1); end
  def purpleish(html = T.unsafe(nil), *_arg1); end
  def red(html = T.unsafe(nil), *_arg1); end
  def redish(html = T.unsafe(nil), *_arg1); end

  # Remove ANSI color codes.
  def uncolor; end

  def white(html = T.unsafe(nil), *_arg1); end
  def whiteish(html = T.unsafe(nil), *_arg1); end
  def yellow(html = T.unsafe(nil), *_arg1); end
  def yellowish(html = T.unsafe(nil), *_arg1); end
end

String::BLANK_RE = T.let(T.unsafe(nil), Regexp)
String::ENCODED_BLANKS = T.let(T.unsafe(nil), Concurrent::Map)
