# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ffi` gem.
# Please instead update this file by running `bin/tapioca gem ffi`.

module FFI
  class << self
    # Add a definition type to type definitions.
    def add_typedef(old, add); end

    def errno; end
    def errno=(error); end

    # Find a type in +type_map+ ({FFI::TypeDefs}, by default) from
    # a type objet, a type name (symbol). If +name+ is a {DataConverter},
    # a new {Type::Mapped} is created.
    def find_type(name, type_map = T.unsafe(nil)); end

    # Transform a generic library name to a platform library name
    def map_library_name(lib); end

    # Get +type+ size, in bytes.
    def type_size(type); end

    # Add a definition type to type definitions.
    def typedef(old, add); end
  end
end

class FFI::AbstractMemory
  def [](_arg0); end
  def __copy_from__(_arg0, _arg1); end
  def clear; end
  def get(_arg0, _arg1); end
  def get_array_of_char(_arg0, _arg1); end
  def get_array_of_double(_arg0, _arg1); end
  def get_array_of_float(_arg0, _arg1); end
  def get_array_of_float32(_arg0, _arg1); end
  def get_array_of_float64(_arg0, _arg1); end
  def get_array_of_int(_arg0, _arg1); end
  def get_array_of_int16(_arg0, _arg1); end
  def get_array_of_int32(_arg0, _arg1); end
  def get_array_of_int64(_arg0, _arg1); end
  def get_array_of_int8(_arg0, _arg1); end
  def get_array_of_long(_arg0, _arg1); end
  def get_array_of_long_long(_arg0, _arg1); end
  def get_array_of_pointer(_arg0, _arg1); end
  def get_array_of_short(_arg0, _arg1); end
  def get_array_of_string(*_arg0); end
  def get_array_of_uchar(_arg0, _arg1); end
  def get_array_of_uint(_arg0, _arg1); end
  def get_array_of_uint16(_arg0, _arg1); end
  def get_array_of_uint32(_arg0, _arg1); end
  def get_array_of_uint64(_arg0, _arg1); end
  def get_array_of_uint8(_arg0, _arg1); end
  def get_array_of_ulong(_arg0, _arg1); end
  def get_array_of_ulong_long(_arg0, _arg1); end
  def get_array_of_ushort(_arg0, _arg1); end
  def get_bytes(_arg0, _arg1); end
  def get_char(_arg0); end
  def get_double(_arg0); end
  def get_float(_arg0); end
  def get_float32(_arg0); end
  def get_float64(_arg0); end
  def get_int(_arg0); end
  def get_int16(_arg0); end
  def get_int32(_arg0); end
  def get_int64(_arg0); end
  def get_int8(_arg0); end
  def get_long(_arg0); end
  def get_long_long(_arg0); end
  def get_pointer(_arg0); end
  def get_short(_arg0); end
  def get_string(*_arg0); end
  def get_uchar(_arg0); end
  def get_uint(_arg0); end
  def get_uint16(_arg0); end
  def get_uint32(_arg0); end
  def get_uint64(_arg0); end
  def get_uint8(_arg0); end
  def get_ulong(_arg0); end
  def get_ulong_long(_arg0); end
  def get_ushort(_arg0); end
  def put(_arg0, _arg1, _arg2); end
  def put_array_of_char(_arg0, _arg1); end
  def put_array_of_double(_arg0, _arg1); end
  def put_array_of_float(_arg0, _arg1); end
  def put_array_of_float32(_arg0, _arg1); end
  def put_array_of_float64(_arg0, _arg1); end
  def put_array_of_int(_arg0, _arg1); end
  def put_array_of_int16(_arg0, _arg1); end
  def put_array_of_int32(_arg0, _arg1); end
  def put_array_of_int64(_arg0, _arg1); end
  def put_array_of_int8(_arg0, _arg1); end
  def put_array_of_long(_arg0, _arg1); end
  def put_array_of_long_long(_arg0, _arg1); end
  def put_array_of_pointer(_arg0, _arg1); end
  def put_array_of_short(_arg0, _arg1); end
  def put_array_of_uchar(_arg0, _arg1); end
  def put_array_of_uint(_arg0, _arg1); end
  def put_array_of_uint16(_arg0, _arg1); end
  def put_array_of_uint32(_arg0, _arg1); end
  def put_array_of_uint64(_arg0, _arg1); end
  def put_array_of_uint8(_arg0, _arg1); end
  def put_array_of_ulong(_arg0, _arg1); end
  def put_array_of_ulong_long(_arg0, _arg1); end
  def put_array_of_ushort(_arg0, _arg1); end
  def put_bytes(*_arg0); end
  def put_char(_arg0, _arg1); end
  def put_double(_arg0, _arg1); end
  def put_float(_arg0, _arg1); end
  def put_float32(_arg0, _arg1); end
  def put_float64(_arg0, _arg1); end
  def put_int(_arg0, _arg1); end
  def put_int16(_arg0, _arg1); end
  def put_int32(_arg0, _arg1); end
  def put_int64(_arg0, _arg1); end
  def put_int8(_arg0, _arg1); end
  def put_long(_arg0, _arg1); end
  def put_long_long(_arg0, _arg1); end
  def put_pointer(_arg0, _arg1); end
  def put_short(_arg0, _arg1); end
  def put_string(_arg0, _arg1); end
  def put_uchar(_arg0, _arg1); end
  def put_uint(_arg0, _arg1); end
  def put_uint16(_arg0, _arg1); end
  def put_uint32(_arg0, _arg1); end
  def put_uint64(_arg0, _arg1); end
  def put_uint8(_arg0, _arg1); end
  def put_ulong(_arg0, _arg1); end
  def put_ulong_long(_arg0, _arg1); end
  def put_ushort(_arg0, _arg1); end
  def read_array_of_char(_arg0); end
  def read_array_of_double(_arg0); end
  def read_array_of_float(_arg0); end
  def read_array_of_int(_arg0); end
  def read_array_of_int16(_arg0); end
  def read_array_of_int32(_arg0); end
  def read_array_of_int64(_arg0); end
  def read_array_of_int8(_arg0); end
  def read_array_of_long(_arg0); end
  def read_array_of_long_long(_arg0); end
  def read_array_of_pointer(_arg0); end
  def read_array_of_short(_arg0); end
  def read_array_of_uchar(_arg0); end
  def read_array_of_uint(_arg0); end
  def read_array_of_uint16(_arg0); end
  def read_array_of_uint32(_arg0); end
  def read_array_of_uint64(_arg0); end
  def read_array_of_uint8(_arg0); end
  def read_array_of_ulong(_arg0); end
  def read_array_of_ulong_long(_arg0); end
  def read_array_of_ushort(_arg0); end
  def read_bytes(_arg0); end
  def read_char; end
  def read_double; end
  def read_float; end
  def read_int; end
  def read_int16; end
  def read_int32; end
  def read_int64; end
  def read_int8; end
  def read_long; end
  def read_long_long; end
  def read_pointer; end
  def read_short; end
  def read_uchar; end
  def read_uint; end
  def read_uint16; end
  def read_uint32; end
  def read_uint64; end
  def read_uint8; end
  def read_ulong; end
  def read_ulong_long; end
  def read_ushort; end
  def size; end

  # Return +true+ if +self+ has a size limit.
  def size_limit?; end

  def total; end
  def type_size; end
  def write_array_of_char(_arg0); end
  def write_array_of_double(_arg0); end
  def write_array_of_float(_arg0); end
  def write_array_of_int(_arg0); end
  def write_array_of_int16(_arg0); end
  def write_array_of_int32(_arg0); end
  def write_array_of_int64(_arg0); end
  def write_array_of_int8(_arg0); end
  def write_array_of_long(_arg0); end
  def write_array_of_long_long(_arg0); end
  def write_array_of_pointer(_arg0); end
  def write_array_of_short(_arg0); end
  def write_array_of_uchar(_arg0); end
  def write_array_of_uint(_arg0); end
  def write_array_of_uint16(_arg0); end
  def write_array_of_uint32(_arg0); end
  def write_array_of_uint64(_arg0); end
  def write_array_of_uint8(_arg0); end
  def write_array_of_ulong(_arg0); end
  def write_array_of_ulong_long(_arg0); end
  def write_array_of_ushort(_arg0); end
  def write_bytes(*_arg0); end
  def write_char(_arg0); end
  def write_double(_arg0); end
  def write_float(_arg0); end
  def write_int(_arg0); end
  def write_int16(_arg0); end
  def write_int32(_arg0); end
  def write_int64(_arg0); end
  def write_int8(_arg0); end
  def write_long(_arg0); end
  def write_long_long(_arg0); end
  def write_pointer(_arg0); end
  def write_short(_arg0); end
  def write_uchar(_arg0); end
  def write_uint(_arg0); end
  def write_uint16(_arg0); end
  def write_uint32(_arg0); end
  def write_uint64(_arg0); end
  def write_uint8(_arg0); end
  def write_ulong(_arg0); end
  def write_ulong_long(_arg0); end
  def write_ushort(_arg0); end
end

FFI::AbstractMemory::LONG_MAX = T.let(T.unsafe(nil), Integer)

class FFI::ArrayType < ::FFI::Type
  def initialize(_arg0, _arg1); end

  def elem_type; end
  def length; end
end

class FFI::AutoPointer < ::FFI::Pointer
  extend ::FFI::DataConverter

  def initialize(ptr, proc = T.unsafe(nil), &block); end

  # Set +autorelease+ property. See {Pointer Autorelease section at Pointer}.
  def autorelease=(autorelease); end

  # Get +autorelease+ property. See {Pointer Autorelease section at Pointer}.
  def autorelease?; end

  # Free the pointer.
  def free; end

  class << self
    # Create a new AutoPointer.
    #
    # Override {DataConverter#from_native}.
    def from_native(val, ctx); end

    # Return native type of AutoPointer.
    #
    # Override {DataConverter#native_type}.
    def native_type; end
  end
end

# CallableReleaser is a {Releaser} used when an {AutoPointer} is defined with a
# Proc or a Method.
class FFI::AutoPointer::CallableReleaser < ::FFI::AutoPointer::Releaser
  # Release +ptr+ by using Proc or Method defined at +ptr+
  # {AutoPointer#initialize initialization}.
  def release(ptr); end
end

# DefaultReleaser is a {Releaser} used when an {AutoPointer} is defined
# without Proc or Method. In this case, the pointer to release must be of
# a class derived from AutoPointer with a {release} class method.
class FFI::AutoPointer::DefaultReleaser < ::FFI::AutoPointer::Releaser
  # Release +ptr+ using the {release} class method of its class.
  def release(ptr); end
end

# A releaser is an object in charge of release an {AutoPointer}.
class FFI::AutoPointer::Releaser
  # A new instance of Releaser.
  def initialize(ptr, proc); end

  # Returns the value of attribute autorelease.
  def autorelease; end

  # Sets the attribute autorelease
  def autorelease=(_arg0); end

  # Release pointer if +autorelease+ is set.
  def call(*args); end

  # Free pointer.
  def free; end
end

# Represents a C enum whose values are power of 2
#
# Contrary to classical enums, bitmask values are usually combined
# when used.
class FFI::Bitmask < ::FFI::Enum
  def initialize(*args); end

  # Get a symbol list or a value from the bitmask
  def [](*query); end

  def from_native(val, ctx); end

  # Get the native value of a bitmask
  def to_native(query, ctx); end
end

class FFI::Buffer < ::FFI::AbstractMemory
  def initialize(*_arg0); end

  def +(_arg0); end
  def inspect; end
  def length; end
  def order(*_arg0); end
  def slice(_arg0, _arg1); end

  private

  def initialize_copy(_arg0); end

  class << self
    def alloc_in(*_arg0); end
    def alloc_inout(*_arg0); end
    def alloc_out(*_arg0); end
    def new_in(*_arg0); end
    def new_inout(*_arg0); end
    def new_out(*_arg0); end
  end
end

FFI::CURRENT_PROCESS = T.let(T.unsafe(nil), Object)
FFI::CallbackInfo = FFI::FunctionType

# This module is used to extend somes classes and give then a common API.
#
# Most of methods defined here must be overriden.
module FFI::DataConverter
  # Convert from a native type.
  def from_native(value, ctx); end

  # Get native type.
  def native_type(type = T.unsafe(nil)); end

  # Convert to a native type.
  def to_native(value, ctx); end
end

class FFI::DynamicLibrary
  def initialize(_arg0, _arg1); end

  def find_function(_arg0); end
  def find_symbol(_arg0); end
  def find_variable(_arg0); end
  def last_error; end
  def name; end

  class << self
    def last_error; end
    def open(_arg0, _arg1); end
  end
end

FFI::DynamicLibrary::RTLD_ALL_MASK = T.let(T.unsafe(nil), Integer)
FFI::DynamicLibrary::RTLD_BINDING_MASK = T.let(T.unsafe(nil), Integer)
FFI::DynamicLibrary::RTLD_DEEPBIND = T.let(T.unsafe(nil), Integer)
FFI::DynamicLibrary::RTLD_FIRST = T.let(T.unsafe(nil), Integer)
FFI::DynamicLibrary::RTLD_GLOBAL = T.let(T.unsafe(nil), Integer)
FFI::DynamicLibrary::RTLD_LAZY = T.let(T.unsafe(nil), Integer)
FFI::DynamicLibrary::RTLD_LOCAL = T.let(T.unsafe(nil), Integer)
FFI::DynamicLibrary::RTLD_LOCATION_MASK = T.let(T.unsafe(nil), Integer)
FFI::DynamicLibrary::RTLD_MEMBER = T.let(T.unsafe(nil), Integer)
FFI::DynamicLibrary::RTLD_NODELETE = T.let(T.unsafe(nil), Integer)
FFI::DynamicLibrary::RTLD_NOLOAD = T.let(T.unsafe(nil), Integer)
FFI::DynamicLibrary::RTLD_NOW = T.let(T.unsafe(nil), Integer)

class FFI::DynamicLibrary::Symbol < ::FFI::Pointer
  def inspect; end

  private

  def initialize_copy(_arg0); end
end

# Represents a C enum.
#
# For a C enum:
# enum fruits {
# apple,
# banana,
# orange,
# pineapple
# };
# are defined this vocabulary:
# * a _symbol_ is a word from the enumeration (ie. _apple_, by example);
# * a _value_ is the value of a symbol in the enumeration (by example, apple has value _0_ and banana _1_).
class FFI::Enum
  include ::FFI::DataConverter

  def initialize(*args); end

  # Get a symbol or a value from the enum.
  def [](query); end

  # Get a symbol or a value from the enum.
  def find(query); end

  def from_native(val, ctx); end

  # Returns the value of attribute native_type.
  def native_type; end

  # Get the symbol map.
  def symbol_map; end

  def symbols; end

  # Returns the value of attribute tag.
  def tag; end

  # Get the symbol map.
  def to_h; end

  # Get the symbol map.
  def to_hash; end

  def to_native(val, ctx); end
end

# An instance of this class permits to manage {Enum}s. In fact, Enums is a collection of {Enum}s.
class FFI::Enums
  def initialize; end

  # Add an {Enum} to the collection.
  def <<(enum); end

  def __map_symbol(symbol); end

  # Find a {Enum} in collection.
  def find(query); end
end

class FFI::Function < ::FFI::Pointer
  def initialize(*_arg0); end

  def attach(_arg0, _arg1); end
  def autorelease; end
  def autorelease=(_arg0); end
  def autorelease?; end
  def call(*_arg0); end
  def free; end

  private

  def initialize_copy(_arg0); end
end

FFI::FunctionInfo = FFI::FunctionType

class FFI::FunctionType < ::FFI::Type
  def initialize(*_arg0); end

  def param_types; end
  def result_type; end
end

# This module implements a couple of class methods to play with IO.
module FFI::IO
  class << self
    # Synonym for IO::for_fd.
    def for_fd(fd, mode = T.unsafe(nil)); end

    # A version of IO#read that reads data from an IO and put then into a native buffer.
    #
    # This will be optimized at some future time to eliminate the double copy.
    def native_read(io, buf, len); end
  end
end

module FFI::LastError
  private

  def error; end
  def error=(_arg0); end

  class << self
    def error; end
    def error=(_arg0); end
  end
end

# This module is the base to use native functions.
#
# A basic usage may be:
# require 'ffi'
#
# module Hello
# extend FFI::Library
# ffi_lib FFI::Library::LIBC
# attach_function 'puts', [ :string ], :int
# end
#
# Hello.puts("Hello, World")
module FFI::Library
  # Attach C function +func+ to this module.
  def attach_function(name, func, args, returns = T.unsafe(nil), options = T.unsafe(nil)); end

  # Attach C variable +cname+ to this module.
  def attach_variable(mname, a1, a2 = T.unsafe(nil)); end

  # Create a new FFI::Bitmask
  def bitmask(*args); end

  def callback(*args); end

  # Create a new {FFI::Enum}.
  def enum(*args); end

  # Find an enum by name.
  def enum_type(name); end

  # Find an enum by a symbol it contains.
  def enum_value(symbol); end

  # Set the calling convention for {#attach_function} and {#callback}
  def ffi_convention(convention = T.unsafe(nil)); end

  # Load native libraries.
  def ffi_lib(*names); end

  # Sets library flags for {#ffi_lib}.
  def ffi_lib_flags(*flags); end

  # Get FFI libraries loaded using {#ffi_lib}.
  def ffi_libraries; end

  # Find a type definition.
  def find_type(t); end

  # This function returns a list of possible names to lookup.
  def function_names(name, arg_types); end

  # Register or get an already registered type definition.
  #
  # To register a new type definition, +old+ should be a {FFI::Type}. +add+
  # is in this case the type definition.
  #
  # If +old+ is a {DataConverter}, a {Type::Mapped} is returned.
  #
  # If +old+ is +:enum+
  # * and +add+ is an +Array+, a call to {#enum} is made with +add+ as single parameter;
  # * in others cases, +info+ is used to create a named enum.
  #
  # If +old+ is a key for type map, #typedef get +old+ type definition.
  def typedef(old, add, info = T.unsafe(nil)); end

  private

  # Generic enum builder
  # @param [Class] klass can be one of FFI::Enum or FFI::Bitmask
  # @param args (see #enum or #bitmask)
  def generic_enum(klass, *args); end

  class << self
    # Test if extended object is a Module. If not, raise RuntimeError.
    def extended(mod); end
  end
end

FFI::Library::CURRENT_PROCESS = T.let(T.unsafe(nil), Object)

# Flags used in {#ffi_lib}.
#
# This map allows you to supply symbols to {#ffi_lib_flags} instead of
# the actual constants.
FFI::Library::FlagsMap = T.let(T.unsafe(nil), Hash)

FFI::Library::LIBC = T.let(T.unsafe(nil), String)

# FFI::ManagedStruct allows custom garbage-collection of your FFI::Structs.
#
# The typical use case would be when interacting with a library
# that has a nontrivial memory management design, such as a linked
# list or a binary tree.
#
# When the {Struct} instance is garbage collected, FFI::ManagedStruct will
# invoke the class's release() method during object finalization.
class FFI::ManagedStruct < ::FFI::Struct
  # A new instance of FFI::ManagedStruct.
  def initialize(pointer = T.unsafe(nil)); end
end

class FFI::MemoryPointer < ::FFI::Pointer
  def initialize(*_arg0); end

  class << self
    def from_string(_arg0); end
  end
end

FFI::NativeLibrary = FFI::DynamicLibrary
module FFI::NativeType; end
FFI::NativeType::BOOL = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::BUFFER_IN = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::BUFFER_INOUT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::BUFFER_OUT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::FLOAT32 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::FLOAT64 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::INT16 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::INT32 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::INT64 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::INT8 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::LONG = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::LONGDOUBLE = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::POINTER = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::STRING = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::UINT16 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::UINT32 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::UINT64 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::UINT8 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::ULONG = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::VARARGS = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::NativeType::VOID = T.let(T.unsafe(nil), FFI::Type::Builtin)

# Exception raised when a function is not found in libraries
class FFI::NotFoundError < ::LoadError
  def initialize(function, *libraries); end
end

class FFI::NullPointerError < ::RuntimeError; end

# This module defines different constants and class methods to play with
# various platforms.
module FFI::Platform
  class << self
    # Test if current OS is a *BSD (include MAC)
    def bsd?; end

    # Test if current OS is +os+.
    def is_os(os); end

    # Test if current OS is Mac OS
    def mac?; end

    # Test if current OS is Solaris (Sun OS)
    def solaris?; end

    # Test if current OS is a unix OS
    def unix?; end

    # Test if current OS is Windows
    def windows?; end
  end
end

FFI::Platform::ADDRESS_ALIGN = T.let(T.unsafe(nil), Integer)
FFI::Platform::ADDRESS_SIZE = T.let(T.unsafe(nil), Integer)
FFI::Platform::ARCH = T.let(T.unsafe(nil), String)
FFI::Platform::BIG_ENDIAN = T.let(T.unsafe(nil), Integer)
FFI::Platform::BYTE_ORDER = T.let(T.unsafe(nil), Integer)
FFI::Platform::CONF_DIR = T.let(T.unsafe(nil), String)
FFI::Platform::CPU = T.let(T.unsafe(nil), String)
FFI::Platform::DOUBLE_ALIGN = T.let(T.unsafe(nil), Integer)
FFI::Platform::DOUBLE_SIZE = T.let(T.unsafe(nil), Integer)
FFI::Platform::FLOAT_ALIGN = T.let(T.unsafe(nil), Integer)
FFI::Platform::FLOAT_SIZE = T.let(T.unsafe(nil), Integer)
FFI::Platform::GNU_LIBC = T.let(T.unsafe(nil), String)
FFI::Platform::INT16_ALIGN = T.let(T.unsafe(nil), Integer)
FFI::Platform::INT16_SIZE = T.let(T.unsafe(nil), Integer)
FFI::Platform::INT32_ALIGN = T.let(T.unsafe(nil), Integer)
FFI::Platform::INT32_SIZE = T.let(T.unsafe(nil), Integer)
FFI::Platform::INT64_ALIGN = T.let(T.unsafe(nil), Integer)
FFI::Platform::INT64_SIZE = T.let(T.unsafe(nil), Integer)
FFI::Platform::INT8_ALIGN = T.let(T.unsafe(nil), Integer)
FFI::Platform::INT8_SIZE = T.let(T.unsafe(nil), Integer)
FFI::Platform::IS_GNU = T.let(T.unsafe(nil), String)
FFI::Platform::IS_LINUX = T.let(T.unsafe(nil), TrueClass)
FFI::Platform::LIBC = T.let(T.unsafe(nil), String)
FFI::Platform::LIBPREFIX = T.let(T.unsafe(nil), String)
FFI::Platform::LIBSUFFIX = T.let(T.unsafe(nil), String)
FFI::Platform::LITTLE_ENDIAN = T.let(T.unsafe(nil), Integer)
FFI::Platform::LONG_ALIGN = T.let(T.unsafe(nil), Integer)
FFI::Platform::LONG_DOUBLE_ALIGN = T.let(T.unsafe(nil), Integer)
FFI::Platform::LONG_DOUBLE_SIZE = T.let(T.unsafe(nil), Integer)
FFI::Platform::LONG_SIZE = T.let(T.unsafe(nil), Integer)

# 64-bit inodes
FFI::Platform::NAME = T.let(T.unsafe(nil), String)

FFI::Platform::OS = T.let(T.unsafe(nil), String)
FFI::Platform::OSVERSION = T.let(T.unsafe(nil), Integer)
class FFI::PlatformError < ::LoadError; end

class FFI::Pointer < ::FFI::AbstractMemory
  def initialize(*_arg0); end

  def +(_arg0); end
  def ==(_arg0); end
  def address; end
  def autorelease=(_arg0); end
  def autorelease?; end
  def free; end
  def inspect; end
  def null?; end
  def order(*_arg0); end

  # Read pointer's contents as +type+
  #
  # Same as:
  # ptr.get(type, 0)
  def read(type); end

  # Read an array of +type+ of length +length+.
  def read_array_of_type(type, reader, length); end

  # Read pointer's contents as a string, or the first +len+ bytes of the
  # equivalent string if +len+ is not +nil+.
  def read_string(len = T.unsafe(nil)); end

  # Read the first +len+ bytes of pointer's contents as a string.
  #
  # Same as:
  # ptr.read_string(len)  # with len not nil
  def read_string_length(len); end

  # Read pointer's contents as a string.
  #
  # Same as:
  # ptr.read_string  # with no len
  def read_string_to_null; end

  def slice(_arg0, _arg1); end
  def to_i; end
  def to_ptr; end
  def to_s; end
  def type_size; end

  # Write +value+ of type +type+ to pointer's content
  #
  # Same as:
  # ptr.put(type, 0)
  def write(type, value); end

  # Write +ary+ in pointer's contents as +type+.
  def write_array_of_type(type, writer, ary); end

  # Write +str+ in pointer's contents, or first +len+ bytes if
  # +len+ is not +nil+.
  def write_string(str, len = T.unsafe(nil)); end

  # Write +len+ first bytes of +str+ in pointer's contents.
  #
  # Same as:
  # ptr.write_string(str, len)   # with len not nil
  def write_string_length(str, len); end

  private

  def initialize_copy(_arg0); end

  class << self
    # Return the size of a pointer on the current platform, in bytes
    def size; end
  end
end

FFI::Pointer::NULL = T.let(T.unsafe(nil), FFI::Pointer)

# Pointer size
FFI::Pointer::SIZE = T.let(T.unsafe(nil), Integer)

FFI::SizeTypes = T.let(T.unsafe(nil), Hash)

# This will convert a pointer to a Ruby string (just like `:string`), but
# also allow to work with the pointer itself. This is useful when you want
# a Ruby string already containing a copy of the data, but also the pointer
# to the data for you to do something with it, like freeing it, in case the
# library handed the memory off to the caller (Ruby-FFI).
#
# It's {typedef}'d as +:strptr+.
class FFI::StrPtrConverter
  extend ::FFI::DataConverter

  class << self
    # Returns a [ String, Pointer ] tuple so the C memory for the string can be freed
    def from_native(val, ctx); end
  end
end

class FFI::Struct
  def initialize(*_arg0); end

  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def align; end
  def alignment; end

  # Clear the struct content.
  def clear; end

  def layout; end
  def members; end
  def null?; end

  # Get the offset of a field.
  def offset_of(name); end

  # Get an array of tuples (field name, offset of the field).
  def offsets; end

  def order(*_arg0); end
  def pointer; end

  # Get struct size
  def size; end

  # Get {Pointer} to struct content.
  def to_ptr; end

  # Get array of values from Struct fields.
  def values; end

  private

  def initialize_copy(_arg0); end
  def layout=(_arg0); end
  def pointer=(_arg0); end

  class << self
    def alignment; end
    def alloc_in(*_arg0); end
    def alloc_inout(*_arg0); end
    def alloc_out(*_arg0); end
    def auto_ptr; end
    def by_ref(flags = T.unsafe(nil)); end
    def by_value; end
    def in; end
    def layout(*spec); end
    def members; end
    def new_in(*_arg0); end
    def new_inout(*_arg0); end
    def new_out(*_arg0); end

    # Get the offset of a field.
    def offset_of(name); end

    # Get an array of tuples (field name, offset of the field).
    def offsets; end

    def out; end
    def ptr(flags = T.unsafe(nil)); end

    # Get struct size
    def size; end

    # set struct size
    def size=(size); end

    def val; end

    protected

    def align(alignment = T.unsafe(nil)); end
    def aligned(alignment = T.unsafe(nil)); end
    def callback(params, ret); end
    def enclosing_module; end
    def find_field_type(type, mod = T.unsafe(nil)); end
    def find_type(type, mod = T.unsafe(nil)); end
    def pack(packed = T.unsafe(nil)); end
    def packed(packed = T.unsafe(nil)); end

    private

    # Add array +spec+ to +builder+.
    def array_layout(builder, spec); end

    # Add hash +spec+ to +builder+.
    def hash_layout(builder, spec); end
  end
end

class FFI::Struct::InlineArray
  include ::Enumerable

  def initialize(_arg0, _arg1); end

  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def each; end
  def size; end
  def to_a; end
  def to_ptr; end
end

class FFI::Struct::ManagedStructConverter < ::FFI::StructByReference
  def initialize(struct_class); end

  def from_native(ptr, ctx); end
end

# This class includes the {FFI::DataConverter} module.
class FFI::StructByReference
  include ::FFI::DataConverter

  def initialize(struct_class); end

  # Create a struct from content of memory +value+.
  def from_native(value, ctx); end

  # Always get {FFI::Type}::POINTER.
  def native_type; end

  # Returns the value of attribute struct_class.
  def struct_class; end

  def to_native(value, ctx); end
end

class FFI::StructByValue < ::FFI::Type
  def initialize(_arg0); end

  def layout; end
  def struct_class; end
end

class FFI::StructLayout < ::FFI::Type
  def initialize(_arg0, _arg1, _arg2); end

  def [](_arg0); end
  def __union!; end
  def fields; end
  def members; end

  # Get the offset of a field.
  def offset_of(field_name); end

  # Get an array of tuples (field name, offset of the field).
  def offsets; end

  def to_a; end
end

class FFI::StructLayout::Array < ::FFI::StructLayout::Field
  def get(_arg0); end
  def put(_arg0, _arg1); end
end

class FFI::StructLayout::CharArray < ::FFI::Struct::InlineArray
  def to_s; end
  def to_str; end
end

# An enum {Field} in a {StructLayout}.
class FFI::StructLayout::Enum < ::FFI::StructLayout::Field
  # Get an object of type {#type} from memory pointed by +ptr+.
  def get(ptr); end

  # Set +value+ into memory pointed by +ptr+.
  def put(ptr, value); end
end

class FFI::StructLayout::Field
  def initialize(*_arg0); end

  def alignment; end
  def get(_arg0); end
  def name; end
  def offset; end
  def put(_arg0, _arg1); end
  def size; end
  def type; end
end

class FFI::StructLayout::Function < ::FFI::StructLayout::Field
  def get(_arg0); end
  def put(_arg0, _arg1); end
end

class FFI::StructLayout::InnerStruct < ::FFI::StructLayout::Field
  def get(ptr); end
  def put(ptr, value); end
end

class FFI::StructLayout::Mapped < ::FFI::StructLayout::Field
  def initialize(name, offset, type, orig_field); end

  def get(ptr); end
  def put(ptr, value); end
end

class FFI::StructLayout::Number < ::FFI::StructLayout::Field; end
class FFI::StructLayout::Pointer < ::FFI::StructLayout::Field; end
class FFI::StructLayout::String < ::FFI::StructLayout::Field; end

# Build a {StructLayout struct layout}.
class FFI::StructLayoutBuilder
  def initialize; end

  # Add a field to the builder.
  def add(name, type, offset = T.unsafe(nil)); end

  # Add an array as a field to the builder.
  def add_array(name, type, count, offset = T.unsafe(nil)); end

  # Same as {#add}.
  def add_field(name, type, offset = T.unsafe(nil)); end

  # Add a struct as a field to the builder.
  def add_struct(name, type, offset = T.unsafe(nil)); end

  # Returns the value of attribute alignment.
  def alignment; end

  # Set alignment attribute with +align+ only if it is greater than attribute value.
  def alignment=(align); end

  # Build and return the struct layout.
  def build; end

  # Set packed attribute
  def packed=(packed); end

  # Returns the value of attribute size.
  def size; end

  # Set size attribute with +size+ only if +size+ is greater than attribute value.
  def size=(size); end

  # Set union attribute.
  # Set to +true+ to build a {Union} instead of a {Struct}.
  def union=(is_union); end

  # Building a {Union} or a {Struct} ?
  def union?; end

  private

  def align(offset, align); end
  def field_for_type(name, offset, type); end
end

# List of number types
FFI::StructLayoutBuilder::NUMBER_TYPES = T.let(T.unsafe(nil), Array)

FFI::TYPE_BOOL = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_BUFFER_IN = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_BUFFER_INOUT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_BUFFER_OUT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_FLOAT32 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_FLOAT64 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_INT16 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_INT32 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_INT64 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_INT8 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_LONG = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_LONGDOUBLE = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_POINTER = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_STRING = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_UINT16 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_UINT32 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_UINT64 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_UINT8 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_ULONG = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_VARARGS = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TYPE_VOID = T.let(T.unsafe(nil), FFI::Type::Builtin)

class FFI::Type
  def initialize(_arg0); end

  def alignment; end
  def inspect; end
  def size; end
end

FFI::Type::Array = FFI::ArrayType
FFI::Type::BOOL = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::BUFFER_IN = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::BUFFER_INOUT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::BUFFER_OUT = T.let(T.unsafe(nil), FFI::Type::Builtin)

class FFI::Type::Builtin < ::FFI::Type
  def inspect; end
end

FFI::Type::CHAR = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::DOUBLE = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::FLOAT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::FLOAT32 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::FLOAT64 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::Function = FFI::FunctionType
FFI::Type::INT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::INT16 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::INT32 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::INT64 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::INT8 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::LONG = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::LONGDOUBLE = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::LONG_LONG = T.let(T.unsafe(nil), FFI::Type::Builtin)

class FFI::Type::Mapped < ::FFI::Type
  def initialize(_arg0); end

  def from_native(*_arg0); end
  def native_type; end
  def to_native(*_arg0); end
  def type; end
end

FFI::Type::POINTER = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::SCHAR = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::SHORT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::SINT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::SLONG = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::SLONG_LONG = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::SSHORT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::STRING = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::Struct = FFI::StructByValue
FFI::Type::UCHAR = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::UINT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::UINT16 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::UINT32 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::UINT64 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::UINT8 = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::ULONG = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::ULONG_LONG = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::USHORT = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::VARARGS = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::Type::VOID = T.let(T.unsafe(nil), FFI::Type::Builtin)
FFI::TypeDefs = T.let(T.unsafe(nil), Hash)
FFI::USE_THIS_PROCESS_AS_LIBRARY = T.let(T.unsafe(nil), Object)

class FFI::Union < ::FFI::Struct
  class << self
    def builder; end
  end
end

FFI::VERSION = T.let(T.unsafe(nil), String)

class FFI::VariadicInvoker
  def initialize(_arg0, _arg1, _arg2, _arg3); end

  # Attach the invoker to module +mod+ as +mname+
  def attach(mod, mname); end

  def call(*args, &block); end
  def invoke(_arg0, _arg1); end
end
