# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `validate_url` gem.
# Please instead update this file by running `bin/tapioca gem validate_url`.

module ActiveModel
  extend ::ActiveSupport::Autoload

  class << self
    def eager_load!; end
    def gem_version; end
    def version; end
  end
end

ActiveModel::Callback = T.type_alias { T.any(Proc, String, Symbol, T.proc.void, T::Array[T.any(Proc, String, Symbol, T.proc.void)]) }

module ActiveModel::Validations
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::Validations::ClassMethods
  mixes_in_class_methods ::ActiveModel::Callbacks
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::ActiveModel::Translation
  mixes_in_class_methods ::ActiveModel::Validations::HelperMethods

  def errors; end
  def invalid?(context = T.unsafe(nil)); end
  def read_attribute_for_validation(*_arg0); end
  def valid?(context = T.unsafe(nil)); end
  def validate(context = T.unsafe(nil)); end
  def validate!(context = T.unsafe(nil)); end
  def validates_with(*args, &block); end

  private

  def initialize_dup(other); end
  def raise_validation_error; end
  def run_validations!; end

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _validators; end
    def _validators=(value); end
    def _validators?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def __callbacks?; end
    def _validators; end
    def _validators?; end
  end
end

module ActiveModel::Validations::ClassMethods
  def attribute_method?(attribute); end
  def clear_validators!; end
  def inherited(base); end

  sig { params(names: T.any(String, Symbol), on: T.any(String, Symbol, T::Array[T.any(String, Symbol)]), if: T.any(Proc, String, Symbol, T.proc.void, T::Array[T.any(Proc, String, Symbol, T.proc.void)]), unless: T.any(Proc, String, Symbol, T.proc.void, T::Array[T.any(Proc, String, Symbol, T.proc.void)]), prepend: T::Boolean).void }
  def validate(*names, on: T.unsafe(nil), if: T.unsafe(nil), unless: T.unsafe(nil), prepend: T.unsafe(nil)); end

  sig { params(attr_names: T.any(String, Symbol), acceptance: T.any(T::Boolean, T::Hash[Symbol, T.untyped]), comparison: T::Hash[Symbol, T.untyped], confirmation: T.any(T::Boolean, T::Hash[Symbol, T.untyped]), exclusion: T::Hash[Symbol, T.untyped], format: T::Hash[Symbol, T.untyped], inclusion: T::Hash[Symbol, T.untyped], length: T::Hash[Symbol, T.untyped], numericality: T.any(T::Boolean, T::Hash[Symbol, T.untyped]), presence: T.any(T::Boolean, T::Hash[Symbol, T.untyped]), absence: T.any(T::Boolean, T::Hash[Symbol, T.untyped]), uniqueness: T.any(T::Boolean, T::Hash[Symbol, T.untyped]), on: T.any(String, Symbol, T::Array[T.any(String, Symbol)]), if: T.any(Proc, String, Symbol, T.proc.void, T::Array[T.any(Proc, String, Symbol, T.proc.void)]), unless: T.any(Proc, String, Symbol, T.proc.void, T::Array[T.any(Proc, String, Symbol, T.proc.void)]), allow_blank: T::Boolean, allow_nil: T::Boolean, strict: T.any(T.class_of(Exception), T::Boolean), options: T.untyped).void }
  def validates(*attr_names, acceptance: T.unsafe(nil), comparison: T.unsafe(nil), confirmation: T.unsafe(nil), exclusion: T.unsafe(nil), format: T.unsafe(nil), inclusion: T.unsafe(nil), length: T.unsafe(nil), numericality: T.unsafe(nil), presence: T.unsafe(nil), absence: T.unsafe(nil), uniqueness: T.unsafe(nil), on: T.unsafe(nil), if: T.unsafe(nil), unless: T.unsafe(nil), allow_blank: T.unsafe(nil), allow_nil: T.unsafe(nil), strict: T.unsafe(nil), **options); end

  sig { params(attr_names: T.any(String, Symbol), acceptance: T.any(T::Boolean, T::Hash[Symbol, T.untyped]), comparison: T::Hash[Symbol, T.untyped], confirmation: T.any(T::Boolean, T::Hash[Symbol, T.untyped]), exclusion: T::Hash[Symbol, T.untyped], format: T::Hash[Symbol, T.untyped], inclusion: T::Hash[Symbol, T.untyped], length: T::Hash[Symbol, T.untyped], numericality: T.any(T::Boolean, T::Hash[Symbol, T.untyped]), presence: T.any(T::Boolean, T::Hash[Symbol, T.untyped]), absence: T.any(T::Boolean, T::Hash[Symbol, T.untyped]), uniqueness: T.any(T::Boolean, T::Hash[Symbol, T.untyped]), on: T.any(String, Symbol, T::Array[T.any(String, Symbol)]), if: T.any(Proc, String, Symbol, T.proc.void, T::Array[T.any(Proc, String, Symbol, T.proc.void)]), unless: T.any(Proc, String, Symbol, T.proc.void, T::Array[T.any(Proc, String, Symbol, T.proc.void)]), allow_blank: T::Boolean, allow_nil: T::Boolean, options: T.untyped).void }
  def validates!(*attr_names, acceptance: T.unsafe(nil), comparison: T.unsafe(nil), confirmation: T.unsafe(nil), exclusion: T.unsafe(nil), format: T.unsafe(nil), inclusion: T.unsafe(nil), length: T.unsafe(nil), numericality: T.unsafe(nil), presence: T.unsafe(nil), absence: T.unsafe(nil), uniqueness: T.unsafe(nil), on: T.unsafe(nil), if: T.unsafe(nil), unless: T.unsafe(nil), allow_blank: T.unsafe(nil), allow_nil: T.unsafe(nil), **options); end

  sig { params(attr_names: Symbol, block: T.proc.params(record: T.untyped, attr: Symbol, value: T.untyped).void).void }
  def validates_each(*attr_names, &block); end

  # Validates whether the value of the specified attribute is valid url.
  #
  # class Unicorn
  # include ActiveModel::Validations
  # attr_accessor :homepage, :ftpsite
  # validates_url :homepage, allow_blank: true
  # validates_url :ftpsite, schemes: ['ftp']
  # end
  # Configuration options:
  # * <tt>:message</tt> - A custom error message (default is: "is not a valid URL").
  # * <tt>:allow_nil</tt> - If set to true, skips this validation if the attribute is +nil+ (default is +false+).
  # * <tt>:allow_blank</tt> - If set to true, skips this validation if the attribute is blank (default is +false+).
  # * <tt>:schemes</tt> - Array of URI schemes to validate against. (default is +['http', 'https']+)
  def validates_url(*attr_names); end

  sig { params(classes: Class, options: T.untyped).void }
  def validates_with(*classes, **options); end

  def validators; end
  def validators_on(*attributes); end

  private

  def _parse_validates_options(options); end
  def _validates_default_keys; end
end

ActiveModel::Validations::ClassMethods::VALID_OPTIONS_FOR_VALIDATE = T.let(T.unsafe(nil), Array)
ActiveModel::Validations::Message = T.type_alias { T.any(String, T.proc.params(object: T.untyped, data: {model: String, attribute: String, value: T.untyped}).returns(String)) }
ActiveModel::Validations::Strict = T.type_alias { T.any(T.class_of(Exception), T::Boolean) }

class ActiveModel::Validations::UrlValidator < ::ActiveModel::EachValidator
  def initialize(options); end

  def validate_each(record, attribute, value); end

  protected

  def filtered_options(value); end
end

ActiveModel::Validations::UrlValidator::RESERVED_OPTIONS = T.let(T.unsafe(nil), Array)
