# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `premailer-rails` gem.
# Please instead update this file by running `bin/tapioca gem premailer-rails`.

class Premailer
  include ::HtmlToPlainText
  include ::CssParser
  include ::Premailer::Warnings

  # Create a new Premailer object.
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param html is the HTML data to process. It can be either an IO object, the URL of a
  #   remote file, a local path or a raw HTML string.  If passing an HTML string you
  #   must set the with_html_string option to true.
  # @param options [Hash] the options to handle html with.
  # @return [Premailer] a new instance of Premailer
  def initialize(html, options = T.unsafe(nil)); end

  def append_query_string(doc, qs); end

  # base directory used to resolve links for local files
  #
  # @return [String] base directory
  def base_dir; end

  # base URL used to resolve links
  def base_url; end

  # Check <tt>CLIENT_SUPPORT_FILE</tt> for any CSS warnings
  def check_client_support; end

  # Convert relative links to absolute links.
  #
  # Processes <tt>href</tt> <tt>src</tt> and <tt>background</tt> attributes
  # as well as CSS <tt>url()</tt> declarations found in inline <tt>style</tt> attributes.
  #
  # <tt>doc</tt> is a document and <tt>base_uri</tt> is either a string or a URI.
  #
  # Returns a document.
  def convert_inline_links(doc, base_uri); end

  # source HTML document (Nokogiri/Nokogumbo)
  def doc; end

  # URI of the HTML file used
  def html_file; end

  # Check for an XHTML doctype
  #
  # @return [Boolean]
  def is_xhtml?; end

  # @deprecated
  # @private
  # @return [Boolean]
  def local_uri?(uri); end

  # @private
  # @return [Boolean]
  def media_type_ok?(media_types); end

  # processed HTML document (Nokogiri/Nokogumbo)
  def processed_doc; end

  # unmergeable CSS rules to be preserved in the head (CssParser)
  def unmergable_rules; end

  # CSS warnings.
  #
  # @return [Array(Hash)] Array of warnings.
  def warnings; end

  protected

  # Load CSS included in <tt>style</tt> and <tt>link</tt> tags from an HTML document.
  def load_css_from_html!; end

  def load_css_from_local_file!(path); end

  # @private
  def load_css_from_options!; end

  def load_css_from_string(css_string); end

  class << self
    # from http://www.ruby-forum.com/topic/140101
    def canonicalize(uri); end

    # @private
    # @return [Boolean]
    def is_media_query?(media_types); end

    # Test the passed variable to see if we are in local or remote mode.
    #
    # IO objects return true, as do strings that look like URLs.
    #
    # @return [Boolean]
    def local_data?(data); end

    # @private
    def resolve_link(path, base_path); end
  end
end

Premailer::CLIENT_SUPPORT_FILE = T.let(T.unsafe(nil), String)

# list of HTMLEntities to fix
# source: http://stackoverflow.com/questions/2812781/how-to-convert-webpage-apostrophe-8217-to-ascii-39-in-ruby-1-
Premailer::HTML_ENTITIES = T.let(T.unsafe(nil), Hash)

# list of CSS attributes that can be rendered as HTML attributes
#
# @todo too much repetition
# @todo background=""
Premailer::RELATED_ATTRIBUTES = T.let(T.unsafe(nil), Hash)

# Reset selectors regexp.
Premailer::RE_RESET_SELECTORS = T.let(T.unsafe(nil), Regexp)

# Unmergable selectors regexp.
Premailer::RE_UNMERGABLE_SELECTORS = T.let(T.unsafe(nil), Regexp)

module Premailer::Rails
  class << self
    # Returns the value of attribute config.
    def config; end

    # Sets the attribute config
    #
    # @param value the value to set the attribute config to.
    def config=(_arg0); end

    def register_interceptors; end
  end
end

module Premailer::Rails::CSSHelper
  extend ::Premailer::Rails::CSSHelper

  # Returns the value of attribute cache.
  def cache; end

  # Sets the attribute cache
  #
  # @param value the value to set the attribute cache to.
  def cache=(_arg0); end

  # Returns all linked CSS files concatenated as string.
  def css_for_doc(doc); end

  def css_for_url(url); end

  private

  # @return [Boolean]
  def cache_enabled?; end

  def css_urls_in_doc(doc); end
  def find_strategy(key); end

  # @raise [FileNotFound]
  def load_css(url); end

  def load_css_with_cache(url); end
end

class Premailer::Rails::CSSHelper::FileNotFound < ::StandardError; end
module Premailer::Rails::CSSLoaders; end

module Premailer::Rails::CSSLoaders::AssetPipelineLoader
  extend ::Premailer::Rails::CSSLoaders::AssetPipelineLoader

  # @return [Boolean]
  def asset_pipeline_present?; end

  def file_name(url); end
  def load(url); end
end

module Premailer::Rails::CSSLoaders::FileSystemLoader
  extend ::Premailer::Rails::CSSLoaders::FileSystemLoader

  def asset_filename(filename); end
  def file_name(url); end
  def load(url); end
  def relative_url_root; end
end

module Premailer::Rails::CSSLoaders::NetworkLoader
  extend ::Premailer::Rails::CSSLoaders::NetworkLoader

  def asset_host(url); end

  # @return [Boolean]
  def asset_host_present?; end

  def load(url); end
  def uri_for_url(url); end
end

class Premailer::Rails::CustomizedPremailer < ::Premailer
  # @return [CustomizedPremailer] a new instance of CustomizedPremailer
  def initialize(html); end
end

class Premailer::Rails::Hook
  # @return [Hook] a new instance of Hook
  def initialize(message); end

  # Returns the value of attribute message.
  def message; end

  def perform; end

  private

  def generate_alternative_part; end
  def generate_html_part; end
  def generate_html_part_replacement; end
  def generate_text_part; end

  # @return [Boolean]
  def generate_text_part?; end

  def html_part; end

  # @return [Boolean]
  def message_contains_html?; end

  def premailer; end

  # Returns true if the message itself has a content type of text/html, thus
  # it does not contain other parts such as alternatives and attachments.
  #
  # @return [Boolean]
  def pure_html_message?; end

  def remove_skip_premailer_header; end
  def replace_html_part(new_part); end

  # If the new part is a pure text/html part, the body and its content type
  # are used for the message. If the new part is
  def replace_in_pure_html_message(new_part); end

  def replace_part_in_list(parts_list, old_part, new_part); end

  # @return [Boolean]
  def skip_premailer_header_present?; end

  class << self
    def delivering_email(message); end
    def perform(message); end
    def previewing_email(message); end
  end
end

class Premailer::Rails::Railtie < ::Rails::Railtie; end
Premailer::Rails::VERSION = T.let(T.unsafe(nil), String)

# Premailer version.
Premailer::VERSION = T.let(T.unsafe(nil), String)

# Waning level names
Premailer::WARN_LABEL = T.let(T.unsafe(nil), Array)
