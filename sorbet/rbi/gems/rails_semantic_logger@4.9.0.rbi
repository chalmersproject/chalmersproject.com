# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rails_semantic_logger` gem.
# Please instead update this file by running `bin/tapioca gem rails_semantic_logger`.

module ActiveSupport
  extend ::ActiveSupport::LazyLoadHooks
  extend ::ActiveSupport::Autoload

  def parse_json_times; end
  def parse_json_times=(val); end
  def test_order; end
  def test_order=(val); end
  def test_parallelization_threshold; end
  def test_parallelization_threshold=(val); end

  class << self
    def cache_format_version; end
    def cache_format_version=(value); end
    def eager_load!; end
    def error_reporter; end
    def error_reporter=(_arg0); end
    def escape_html_entities_in_json(*_arg0, &_arg1); end
    def escape_html_entities_in_json=(arg); end
    def gem_version; end
    def json_encoder(*_arg0, &_arg1); end
    def json_encoder=(arg); end
    def parse_json_times; end
    def parse_json_times=(val); end
    def test_order; end
    def test_order=(val); end
    def test_parallelization_threshold; end
    def test_parallelization_threshold=(val); end
    def time_precision(*_arg0, &_arg1); end
    def time_precision=(arg); end
    def to_time_preserves_timezone; end
    def to_time_preserves_timezone=(value); end
    def use_standard_json_time_format(*_arg0, &_arg1); end
    def use_standard_json_time_format=(arg); end
    def utc_to_local_returns_utc_offset_times; end
    def utc_to_local_returns_utc_offset_times=(value); end
    def version; end
  end
end

# More hacks to try and stop Rails from being it's own worst enemy.
class ActiveSupport::Logger < ::Logger
  include ::ActiveSupport::LoggerSilence
  include ::ActiveSupport::LoggerThreadSafeLevel

  def initialize(*args, **kwargs); end

  def silencer; end
  def silencer=(val); end

  class << self
    # Prevent broadcasting since SemanticLogger already supports multiple loggers
    def broadcast(logger); end

    # Prevent Console from trying to merge loggers
    def logger_outputs_to?(*args); end

    def new(*args, **kwargs); end
    def silencer; end
    def silencer=(val); end
  end
end

module RailsSemanticLogger
  class << self
    # Swap an existing subscriber with a new one
    def swap_subscriber(old_class, new_class, notifier); end

    private

    def subscriber_patterns(subscriber); end
    def unattach(subscriber); end
  end
end

module RailsSemanticLogger::ActionController; end

class RailsSemanticLogger::ActionController::LogSubscriber < ::ActiveSupport::LogSubscriber
  def exist_fragment?(event); end
  def expire_fragment(event); end
  def expire_page(event); end
  def halted_callback(event); end
  def process_action(event); end
  def read_fragment(event); end
  def redirect_to(event); end
  def send_data(event); end
  def send_file(event); end

  # Log as debug to hide Processing messages in production
  def start_processing(event); end

  def unpermitted_parameters(event); end
  def write_fragment(event); end
  def write_page(event); end

  private

  # Returns the logger for the supplied event.
  # Returns ActionController::Base.logger if no controller is present
  def controller_logger(event); end

  def extract_path(path); end
end

RailsSemanticLogger::ActionController::LogSubscriber::INTERNAL_PARAMS = T.let(T.unsafe(nil), Array)
module RailsSemanticLogger::ActionView; end

# Output Semantic logs from Action View.
class RailsSemanticLogger::ActionView::LogSubscriber < ::ActiveSupport::LogSubscriber
  def initialize; end

  def render_collection(event); end
  def render_partial(event); end
  def render_template(event); end
  def start(name, id, payload); end

  private

  def from_rails_root(string); end
  def logger; end
  def rails_root; end
  def should_log?; end

  class << self
    # Returns the value of attribute logger.
    def logger; end

    # Returns the value of attribute rendered_log_level.
    def rendered_log_level; end

    # Sets the attribute rendered_log_level
    def rendered_log_level=(_arg0); end
  end
end

RailsSemanticLogger::ActionView::LogSubscriber::EMPTY = T.let(T.unsafe(nil), String)
RailsSemanticLogger::ActionView::LogSubscriber::VIEWS_PATTERN = T.let(T.unsafe(nil), Regexp)
module RailsSemanticLogger::ActiveJob; end

class RailsSemanticLogger::ActiveJob::LogSubscriber < ::ActiveSupport::LogSubscriber
  def enqueue(event); end
  def enqueue_at(event); end
  def perform(event); end
  def perform_start(event); end

  private

  def log_with_formatter(level: T.unsafe(nil), **kw_args); end
  def logger; end
end

class RailsSemanticLogger::ActiveJob::LogSubscriber::EventFormatter
  def initialize(event:, log_duration: T.unsafe(nil)); end

  def job_info; end
  def payload; end
  def queue_name; end
  def scheduled_at; end

  private

  def adapter_name; end

  # Returns the value of attribute event.
  def event; end

  def format(arg); end
  def formatted_args; end
  def job; end
  def log_duration?; end
end

module RailsSemanticLogger::ActiveRecord; end

class RailsSemanticLogger::ActiveRecord::LogSubscriber < ::ActiveSupport::LogSubscriber
  def sql(event); end

  private

  # When multiple values are received for a single bound field, it is converted into an array
  def add_bind_value(binds, key, value); end

  # Rails 3,4,5 hell trying to get the bind values
  # 3.x
  def bind_values(payload); end

  # Rails 3,4,5 hell trying to get the bind values
  def bind_values_v3(payload); end

  def bind_values_v4(payload); end
  def bind_values_v5_0_0(payload); end
  def bind_values_v5_0_3(payload); end
  def bind_values_v5_1_5(payload); end
  def bind_values_v6_1(payload); end
  def logger; end
  def render_bind(attr, value); end
  def render_bind_v4_2(column, value); end
  def render_bind_v5_0_0(attribute); end
  def render_bind_v5_0_3(attr, value); end
  def render_bind_v6_1(attr, value); end
  def type_casted_binds(casted_binds); end
  def type_casted_binds_v5_0_3(binds, casted_binds); end
  def type_casted_binds_v5_1_5(casted_binds); end

  class << self
    # Returns the value of attribute logger.
    def logger; end

    def reset_runtime; end
    def runtime; end
    def runtime=(value); end
  end
end

RailsSemanticLogger::ActiveRecord::LogSubscriber::IGNORE_PAYLOAD_NAMES = T.let(T.unsafe(nil), Array)
module RailsSemanticLogger::DelayedJob; end
class RailsSemanticLogger::Engine < ::Rails::Engine; end

# Options for controlling Rails Semantic Logger behavior
#
# * Convert Action Controller and Active Record text messages to semantic data
#
# Rails -- Started -- { :ip => "127.0.0.1", :method => "GET", :path => "/dashboards/inquiry_recent_activity" }
# UserController -- Completed #index -- { :action => "index", :db_runtime => 54.64, :format => "HTML", :method => "GET", :mongo_runtime => 0.0, :path => "/users", :status => 200, :status_message => "OK", :view_runtime => 709.88 }
#
# config.rails_semantic_logger.semantic = true
#
# * Change Rack started message to debug so that it does not appear in production
#
# config.rails_semantic_logger.started = false
#
# * Change Processing message to debug so that it does not appear in production
#
# config.rails_semantic_logger.processing = false
#
# * Change Action View render log messages to debug so that they do not appear in production
#
# ActionView::Base --   Rendered data/search/_user.html.haml (46.7ms)
#
# config.rails_semantic_logger.rendered = false
#
# * Override the Awesome Print options for logging Hash data as text:
#
# Any valid AwesomePrint option for rendering data.
# The defaults can changed be creating a `~/.aprc` file.
# See: https://github.com/michaeldv/awesome_print
#
# Note: The option :multiline is set to false if not supplied.
# Note: Has no effect if Awesome Print is not installed.
#
# config.rails_semantic_logger.ap_options = {multiline: false}
#
# * Whether to automatically add an environment specific log file appender.
# For Example: 'log/development.log'
#
# Note:
# When Semantic Logger fails to log to an appender it logs the error to an
# internal logger, which by default writes to STDERR.
# Example, change the default internal logger to log to stdout:
# SemanticLogger::Processor.logger = SemanticLogger::Appender::IO.new($stdout, level: :warn)
#
# config.rails_semantic_logger.add_file_appender = true
#
# * Silence asset logging
#
# config.rails_semantic_logger.quiet_assets = false
#
# * Disable automatic logging to stderr when running a Rails console.
#
# config.rails_semantic_logger.console_logger = false
#
# * Override the output format for the primary Rails log file.
#
# Valid options:
# * :default
# Plain text output with no color.
# * :color
# Plain text output with color.
# * :json
# JSON output format.
# * class
#
# * Proc
# A block that will be called to format the output.
# It is supplied with the `log` entry and should return the formatted data.
#
# Note:
# * `:default` is automatically changed to `:color` if `config.colorize_logging` is `true`.
#
# JSON Example, in `application.rb`:
# config.rails_semantic_logger.format = :json
#
# Custom Example, create `app/lib/my_formatter.rb`:
#
# # My Custom colorized formatter
# class MyFormatter < SemanticLogger::Formatters::Color
# # Return the complete log level name in uppercase
# def level
# "#{color}log.level.upcase#{color_map.clear}"
# end
# end
#
# # In application.rb:
# config.rails_semantic_logger.format = MyFormatter.new
#
#
# config.rails_semantic_logger.format = :default
#
# * Add a filter to the file logger [Regexp|Proc]
# RegExp: Only include log messages where the class name matches the supplied
# regular expression. All other messages will be ignored.
# Proc: Only include log messages where the supplied Proc returns true.
# The Proc must return true or false.
#
# config.rails_semantic_logger.filter = nil
#
# * named_tags: *DEPRECATED*
# Instead, supply a Hash to config.log_tags
# config.rails_semantic_logger.named_tags = nil
class RailsSemanticLogger::Options
  # Setup default values
  def initialize; end

  # Returns the value of attribute add_file_appender.
  def add_file_appender; end

  # Sets the attribute add_file_appender
  def add_file_appender=(_arg0); end

  # Returns the value of attribute ap_options.
  def ap_options; end

  # Sets the attribute ap_options
  def ap_options=(_arg0); end

  # Returns the value of attribute console_logger.
  def console_logger; end

  # Sets the attribute console_logger
  def console_logger=(_arg0); end

  # Returns the value of attribute filter.
  def filter; end

  # Sets the attribute filter
  def filter=(_arg0); end

  # Returns the value of attribute format.
  def format; end

  # Sets the attribute format
  def format=(_arg0); end

  # Returns the value of attribute named_tags.
  def named_tags; end

  # Sets the attribute named_tags
  def named_tags=(_arg0); end

  # Returns the value of attribute processing.
  def processing; end

  # Sets the attribute processing
  def processing=(_arg0); end

  # Returns the value of attribute quiet_assets.
  def quiet_assets; end

  # Sets the attribute quiet_assets
  def quiet_assets=(_arg0); end

  # Returns the value of attribute rendered.
  def rendered; end

  # Sets the attribute rendered
  def rendered=(_arg0); end

  # Returns the value of attribute semantic.
  def semantic; end

  # Sets the attribute semantic
  def semantic=(_arg0); end

  # Returns the value of attribute started.
  def started; end

  # Sets the attribute started
  def started=(_arg0); end
end

module RailsSemanticLogger::Rack; end

class RailsSemanticLogger::Rack::Logger < ::ActiveSupport::LogSubscriber
  def initialize(app, taggers = T.unsafe(nil)); end

  def call(env); end

  private

  def call_app(request, env); end

  # Leave out any named tags with a nil value
  def compute_named_tags(request); end

  def compute_tags(request); end
  def finish(request); end
  def logger; end
  def started_request_message(request); end

  class << self
    # Returns the value of attribute logger.
    def logger; end

    # Returns the value of attribute started_request_log_level.
    def started_request_log_level; end

    # Sets the attribute started_request_log_level
    def started_request_log_level=(_arg0); end
  end
end

module RailsSemanticLogger::Rack::Server
  def daemonize_app; end
end
