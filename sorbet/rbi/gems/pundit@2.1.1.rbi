# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `pundit` gem.
# Please instead update this file by running `bin/tapioca gem pundit`.

module Pundit
  extend ::ActiveSupport::Concern

  protected

  # Retrieves the policy for the given record, initializing it with the record
  # and current user and finally throwing an error if the user is not
  # authorized to perform the given action.
  def authorize(record, query = T.unsafe(nil), policy_class: T.unsafe(nil)); end

  # Retrieves a set of permitted attributes from the policy by instantiating
  # the policy class for the given record and calling `permitted_attributes` on
  # it, or `permitted_attributes_for_{action}` if `action` is defined. It then infers
  # what key the record should have in the params hash and retrieves the
  # permitted attributes from the params hash under that key.
  def permitted_attributes(record, action = T.unsafe(nil)); end

  # Cache of policies. You should not rely on this method.
  #
  def policies; end

  # Retrieves the policy for the given record.
  def policy(record); end

  # Retrieves the policy scope for the given record.
  def policy_scope(scope, policy_scope_class: T.unsafe(nil)); end

  # Cache of policy scope. You should not rely on this method.
  #
  def policy_scopes; end

  # Retrieves the params for the given record.
  def pundit_params_for(record); end

  def pundit_policy_authorized?; end
  def pundit_policy_scoped?; end

  # Hook method which allows customizing which user is passed to policies and
  # scopes initialized by {#authorize}, {#policy} and {#policy_scope}.
  def pundit_user; end

  # Allow this action not to perform authorization.
  def skip_authorization; end

  # Allow this action not to perform policy scoping.
  def skip_policy_scope; end

  # Raises an error if authorization has not been performed, usually used as an
  # `after_action` filter to prevent programmer error in forgetting to call
  # {#authorize} or {#skip_authorization}.
  def verify_authorized; end

  # Raises an error if policy scoping has not been performed, usually used as an
  # `after_action` filter to prevent programmer error in forgetting to call
  # {#policy_scope} or {#skip_policy_scope} in index actions.
  def verify_policy_scoped; end

  private

  def pundit_policy_scope(scope); end

  class << self
    # Retrieves the policy for the given record, initializing it with the
    # record and user and finally throwing an error if the user is not
    # authorized to perform the given action.
    def authorize(user, record, query, policy_class: T.unsafe(nil)); end

    # Retrieves the policy for the given record.
    def policy(user, record); end

    # Retrieves the policy for the given record.
    def policy!(user, record); end

    # Retrieves the policy scope for the given record.
    def policy_scope(user, scope); end

    # Retrieves the policy scope for the given record.
    def policy_scope!(user, scope); end

    private

    def pundit_model(record); end
  end
end

# Error that will be raised if a controller action has not called the
# `authorize` or `skip_authorization` methods.
class Pundit::AuthorizationNotPerformedError < ::Pundit::Error; end

# To avoid name clashes with common Error naming when mixing in Pundit,
# keep it here with compact class style definition.
class Pundit::Error < ::StandardError; end

module Pundit::Generators; end

module Pundit::Helper
  def policy_scope(scope); end
end

# Error that will be raised if a policy or policy scope constructor is not called correctly.
class Pundit::InvalidConstructorError < ::Pundit::Error; end

# Error that will be raised when authorization has failed
class Pundit::NotAuthorizedError < ::Pundit::Error
  def initialize(options = T.unsafe(nil)); end

  def policy; end
  def query; end
  def record; end
end

# Error that will be raised if a policy or policy scope is not defined.
class Pundit::NotDefinedError < ::Pundit::Error; end

# Finds policy and scope classes for given object.
class Pundit::PolicyFinder
  def initialize(object); end

  def object; end
  def param_key; end
  def policy; end
  def policy!; end
  def scope; end
  def scope!; end

  private

  def find(subject); end
  def find_class_name(subject); end
end

# Error that will be raised if a controller action has not called the
# `policy_scope` or `skip_policy_scope` methods.
class Pundit::PolicyScopingNotPerformedError < ::Pundit::AuthorizationNotPerformedError; end

Pundit::SUFFIX = T.let(T.unsafe(nil), String)
Pundit::VERSION = T.let(T.unsafe(nil), String)
