# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `graphql` gem.
# Please instead update this file by running `bin/tapioca gem graphql`.

# backport from ruby v2.5 to v2.2 that has no `padding` things
module Base64Bp
  extend ::Base64

  private

  def urlsafe_decode64(str); end
  def urlsafe_encode64(bin, padding:); end

  class << self
    def urlsafe_decode64(str); end
    def urlsafe_encode64(bin, padding:); end
  end
end

module GraphQL
  class << self
    def const_missing(const_name); end
    def default_parser; end

    # Sets the attribute default_parser
    def default_parser=(_arg0); end

    # Turn a query string or schema definition into an AST
    sig { params(graphql_string: String, tracer: T.untyped).returns(GraphQL::Language::Nodes::Document) }
    def parse(graphql_string, tracer: T.unsafe(nil)); end

    # Read the contents of `filename` and parse them as GraphQL
    def parse_file(filename); end

    def parse_with_racc(string, filename: T.unsafe(nil), tracer: T.unsafe(nil)); end
    def scan(graphql_string); end
    def scan_with_ragel(graphql_string); end
  end
end

module GraphQL::Analysis
  private

  def analysis_errors(results); end
  def analyze_multiplex(multiplex, analyzers); end

  # Visit `query`'s internal representation, calling `analyzers` along the way.
  #
  # - First, query analyzers are filtered down by calling `.analyze?(query)`, if they respond to that method
  # - Then, query analyzers are initialized by calling `.initial_value(query)`, if they respond to that method.
  # - Then, they receive `.call(memo, visit_type, irep_node)`, where visit type is `:enter` or `:leave`.
  # - Last, they receive `.final_value(memo)`, if they respond to that method.
  #
  # It returns an array of final `memo` values in the order that `analyzers` were passed in.
  def analyze_query(query, analyzers, multiplex_states: T.unsafe(nil)); end

  # Enter the node, visit its children, then leave the node.
  def reduce_node(irep_node, reducer_states); end

  def use(schema_class); end
  def visit_analyzers(visit_type, irep_node, reducer_states); end

  class << self
    def analysis_errors(results); end
    def analyze_multiplex(multiplex, analyzers); end

    # Visit `query`'s internal representation, calling `analyzers` along the way.
    #
    # - First, query analyzers are filtered down by calling `.analyze?(query)`, if they respond to that method
    # - Then, query analyzers are initialized by calling `.initial_value(query)`, if they respond to that method.
    # - Then, they receive `.call(memo, visit_type, irep_node)`, where visit type is `:enter` or `:leave`.
    # - Last, they receive `.final_value(memo)`, if they respond to that method.
    #
    # It returns an array of final `memo` values in the order that `analyzers` were passed in.
    def analyze_query(query, analyzers, multiplex_states: T.unsafe(nil)); end

    # Enter the node, visit its children, then leave the node.
    def reduce_node(irep_node, reducer_states); end

    def use(schema_class); end
    def visit_analyzers(visit_type, irep_node, reducer_states); end
  end
end

# A query reducer for measuring the depth of a given query.
#
# See https://graphql-ruby.org/queries/ast_analysis.html for more examples.
module GraphQL::Analysis::AST
  private

  def analysis_errors(results); end

  # Analyze a multiplex, and all queries within.
  # Multiplex analyzers are ran for all queries, keeping state.
  # Query analyzers are ran per query, without carrying state between queries.
  def analyze_multiplex(multiplex, analyzers); end

  def analyze_query(query, analyzers, multiplex_analyzers: T.unsafe(nil)); end
  def use(schema_class); end

  class << self
    def analysis_errors(results); end

    # Analyze a multiplex, and all queries within.
    # Multiplex analyzers are ran for all queries, keeping state.
    # Query analyzers are ran per query, without carrying state between queries.
    def analyze_multiplex(multiplex, analyzers); end

    def analyze_query(query, analyzers, multiplex_analyzers: T.unsafe(nil)); end
    def use(schema_class); end
  end
end

# Query analyzer for query ASTs. Query analyzers respond to visitor style methods
# but are prefixed by `enter` and `leave`.
#
# When an analyzer is initialized with a Multiplex, you can always get the current query from
# `visitor.query` in the visit methods.
class GraphQL::Analysis::AST::Analyzer
  def initialize(subject); end

  # Analyzer hook to decide at analysis time whether a query should
  # be analyzed or not.
  def analyze?; end

  def on_enter_abstract_node(node, parent, visitor); end
  def on_enter_argument(node, parent, visitor); end
  def on_enter_directive(node, parent, visitor); end
  def on_enter_document(node, parent, visitor); end
  def on_enter_enum(node, parent, visitor); end
  def on_enter_field(node, parent, visitor); end
  def on_enter_fragment_spread(node, parent, visitor); end
  def on_enter_inline_fragment(node, parent, visitor); end
  def on_enter_input_object(node, parent, visitor); end
  def on_enter_list_type(node, parent, visitor); end
  def on_enter_non_null_type(node, parent, visitor); end
  def on_enter_null_value(node, parent, visitor); end
  def on_enter_operation_definition(node, parent, visitor); end
  def on_enter_type_name(node, parent, visitor); end
  def on_enter_variable_definition(node, parent, visitor); end
  def on_enter_variable_identifier(node, parent, visitor); end
  def on_leave_abstract_node(node, parent, visitor); end
  def on_leave_argument(node, parent, visitor); end
  def on_leave_directive(node, parent, visitor); end
  def on_leave_document(node, parent, visitor); end
  def on_leave_enum(node, parent, visitor); end
  def on_leave_field(node, parent, visitor); end
  def on_leave_fragment_spread(node, parent, visitor); end
  def on_leave_inline_fragment(node, parent, visitor); end
  def on_leave_input_object(node, parent, visitor); end
  def on_leave_list_type(node, parent, visitor); end
  def on_leave_non_null_type(node, parent, visitor); end
  def on_leave_null_value(node, parent, visitor); end
  def on_leave_operation_definition(node, parent, visitor); end
  def on_leave_type_name(node, parent, visitor); end
  def on_leave_variable_definition(node, parent, visitor); end
  def on_leave_variable_identifier(node, parent, visitor); end

  # The result for this analyzer. Returning {GraphQL::AnalysisError} results
  # in a query error.
  def result; end

  protected

  def multiplex; end
  def query; end
  def subject; end

  class << self
    private

    def build_visitor_hooks(member_name); end
  end
end

class GraphQL::Analysis::AST::FieldUsage < ::GraphQL::Analysis::AST::Analyzer
  def initialize(query); end

  def on_leave_field(node, parent, visitor); end
  def result; end

  private

  def extract_deprecated_arguments(argument_values); end
end

# Used under the hood to implement complexity validation,
# see {Schema#max_complexity} and {Query#max_complexity}
class GraphQL::Analysis::AST::MaxQueryComplexity < ::GraphQL::Analysis::AST::QueryComplexity
  def result; end
end

class GraphQL::Analysis::AST::MaxQueryDepth < ::GraphQL::Analysis::AST::QueryDepth
  def result; end
end

class GraphQL::Analysis::AST::QueryComplexity < ::GraphQL::Analysis::AST::Analyzer
  # State for the query complexity calculation:
  # - `complexities_on_type` holds complexity scores for each type in an IRep node
  def initialize(query); end

  def on_enter_field(node, parent, visitor); end
  def on_leave_field(node, parent, visitor); end

  # Overide this method to use the complexity result
  def result; end

  private

  def applies_to?(query, left_scope, right_scope); end

  # A hook which is called whenever a field's max complexity is calculated.
  # Override this method to capture individual field complexity details.
  def field_complexity(scoped_type_complexity, max_complexity:, child_complexity: T.unsafe(nil)); end

  def max_possible_complexity; end

  # (`{field_key => complexity}`)
  def merged_max_complexity(query, children_for_scope); end

  def merged_max_complexity_for_scopes(query, scoped_children_hashes); end
end

class GraphQL::Analysis::AST::QueryComplexity::ScopedTypeComplexity
  def initialize(parent_type, field_definition, query, response_path); end

  # Returns the value of attribute field_definition.
  def field_definition; end

  def nodes; end
  def own_complexity(child_complexity); end

  # Returns the value of attribute query.
  def query; end

  # Returns the value of attribute response_path.
  def response_path; end

  # This value is only calculated when asked for to avoid needless hash allocations.
  # Also, if it's never asked for, we determine that this scope complexity
  # is a scalar field ({#terminal?}).
  def scoped_children; end

  # Returns true if this field has no selections, ie, it's a scalar.
  # We need a quick way to check whether we should continue traversing.
  def terminal?; end
end

# A single proc for {#scoped_children} hashes. Use this to avoid repeated allocations,
# since the lexical binding isn't important.
GraphQL::Analysis::AST::QueryComplexity::ScopedTypeComplexity::HASH_CHILDREN = T.let(T.unsafe(nil), Proc)

class GraphQL::Analysis::AST::QueryDepth < ::GraphQL::Analysis::AST::Analyzer
  def initialize(query); end

  def on_enter_field(node, parent, visitor); end
  def on_leave_field(node, parent, visitor); end
  def result; end
end

# Depth first traversal through a query AST, calling AST analyzers
# along the way.
#
# The visitor is a special case of GraphQL::Language::Visitor, visiting
# only the selected operation, providing helpers for common use cases such
# as skipped fields and visiting fragment spreads.
class GraphQL::Analysis::AST::Visitor < ::GraphQL::Language::Visitor
  def initialize(query:, analyzers:); end

  def argument_definition; end
  def arguments_for(ast_node, field_definition); end
  def directive_definition; end
  def field_definition; end
  def object_types; end
  def on_abstract_node(node, parent); end
  def on_argument(node, parent); end
  def on_directive(node, parent); end
  def on_field(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end

  # Visitor Hooks
  def on_operation_definition(node, parent); end

  def parent_type_definition; end
  def previous_argument_definition; end
  def previous_field_definition; end
  def query; end
  def rescued_errors; end
  def response_path; end
  def skipping?; end
  def type_definition; end
  def visit; end
  def visiting_fragment_definition?; end

  private

  def call_analyzers(method, node, parent); end

  # Visit a fragment spread inline instead of visiting the definition
  # by itself.
  def enter_fragment_spread_inline(fragment_spread); end

  # Visit a fragment spread inline instead of visiting the definition
  # by itself.
  def leave_fragment_spread_inline(_fragment_spread); end

  def on_fragment_with_type(node); end
  def skip?(ast_node); end
end

# A query reducer for tracking both field usage and deprecated field usage.
class GraphQL::Analysis::FieldUsage
  def initialize(&block); end

  def call(memo, visit_type, irep_node); end
  def final_value(memo); end
  def initial_value(query); end
end

# Used under the hood to implement complexity validation,
# see {Schema#max_complexity} and {Query#max_complexity}
class GraphQL::Analysis::MaxQueryComplexity < ::GraphQL::Analysis::QueryComplexity
  def initialize(max_complexity); end
end

# Used under the hood to implement depth validation,
# see {Schema#max_depth} and {Query#max_depth}
class GraphQL::Analysis::MaxQueryDepth < ::GraphQL::Analysis::QueryDepth
  def initialize(max_depth); end
end

# Calculate the complexity of a query, using {Field#complexity} values.
class GraphQL::Analysis::QueryComplexity
  def initialize(&block); end

  # Implement the query analyzer API
  def call(memo, visit_type, irep_node); end

  # Send the query and complexity to the block
  def final_value(reduced_value); end

  # State for the query complexity calcuation:
  # - `target` is passed to handler
  # - `complexities_on_type` holds complexity scores for each type in an IRep node
  def initial_value(target); end

  private

  # Get a complexity value for a field,
  # by getting the number or calling its proc
  def get_complexity(irep_node, child_complexity); end
end

# Selections on an object may apply differently depending on what is _actually_ returned by the resolve function.
# Find the maximum possible complexity among those combinations.
class GraphQL::Analysis::QueryComplexity::TypeComplexity
  def initialize; end

  # Return the max possible complexity for types in this selection
  def max_possible_complexity; end

  # Store the complexity for the branch on `type_defn`.
  # Later we will see if this is the max complexity among branches.
  def merge(type_defn, complexity); end
end

# A query reducer for measuring the depth of a given query.
class GraphQL::Analysis::QueryDepth
  def initialize(&block); end

  def call(memo, visit_type, irep_node); end
  def final_value(memo); end
  def initial_value(query); end
end

class GraphQL::Analysis::ReducerState
  def initialize(reducer, query); end

  def call(visit_type, irep_node); end

  # Returns the value of attribute errors.
  def errors; end

  # Sets the attribute errors
  def errors=(_arg0); end

  # Respond with any errors, if found. Otherwise, if the reducer accepts
  # `final_value`, send it the last memo value.
  # Otherwise, use the last value from the traversal.
  def finalize_reducer; end

  # Returns the value of attribute memo.
  def memo; end

  # Sets the attribute memo
  def memo=(_arg0); end

  # Returns the value of attribute reducer.
  def reducer; end

  private

  # If the reducer has an `initial_value` method, call it and store
  # the result as `memo`. Otherwise, use `nil` as memo.
  def initialize_reducer(reducer, query); end
end

class GraphQL::AnalysisError < ::GraphQL::ExecutionError; end

class GraphQL::Argument
  include ::GraphQL::Define::InstanceDefinable
  extend ::GraphQL::Define::InstanceDefinable::ClassMethods

  def initialize; end

  def as; end
  def as=(_arg0); end
  def ast_node; end
  def ast_node=(_arg0); end
  def default_value; end
  def default_value=(new_default_value); end
  def default_value?; end
  def deprecation_reason; end
  def deprecation_reason=(_arg0); end
  def description; end
  def description=(_arg0); end
  def expose_as; end
  def graphql_name; end

  # Backport this to support legacy-style directives
  def keyword; end

  def method_access; end
  def method_access=(_arg0); end
  def method_access?; end
  def name; end
  def name=(_arg0); end
  def prepare(value, ctx); end

  # Assign a `prepare` function to prepare this argument's value before `resolve` functions are called.
  def prepare=(prepare_proc); end

  def type; end
  def type=(new_input_type); end
  def type_class; end

  private

  def initialize_copy(other); end

  class << self
    def deep_stringify(val); end
    def from_dsl(name, type_or_argument = T.unsafe(nil), description = T.unsafe(nil), default_value: T.unsafe(nil), as: T.unsafe(nil), prepare: T.unsafe(nil), **kwargs, &block); end
  end
end

module GraphQL::Argument::DefaultPrepare
  class << self
    def call(value, ctx); end
  end
end

GraphQL::Argument::NO_DEFAULT_VALUE = T.let(T.unsafe(nil), Object)
module GraphQL::Authorization; end

module GraphQL::Authorization::Analyzer
  private

  def call(memo, visit_type, irep_node); end
  def final_value(memo); end
  def initial_value(query); end

  class << self
    def call(memo, visit_type, irep_node); end
    def final_value(memo); end
    def initial_value(query); end
  end
end

class GraphQL::Authorization::InaccessibleFieldsError < ::GraphQL::AnalysisError
  def initialize(fields:, irep_nodes:, context:); end

  def context; end
  def fields; end
  def irep_nodes; end
end

GraphQL::BOOLEAN_TYPE = T.let(T.unsafe(nil), GraphQL::ScalarType)

# Wrap unhandled errors with {TracedError}.
#
# {TracedError} provides a GraphQL backtrace with arguments and return values.
# The underlying error is available as {TracedError#cause}.
class GraphQL::Backtrace
  include ::Enumerable
  extend ::Forwardable

  def initialize(context, value: T.unsafe(nil)); end

  def [](*args, &block); end
  def each(*args, &block); end
  def inspect; end
  def to_a; end
  def to_s; end

  class << self
    def use(schema_defn, legacy: T.unsafe(nil)); end
  end
end

# Used for internal bookkeeping
class GraphQL::Backtrace::Frame
  def initialize(path:, query:, ast_node:, object:, field:, arguments:, parent_frame:); end

  def arguments; end
  def ast_node; end
  def field; end
  def object; end
  def parent_frame; end
  def path; end
  def query; end
end

module GraphQL::Backtrace::InspectResult
  private

  def inspect_result(obj); end
  def inspect_truncated(obj); end

  class << self
    def inspect_result(obj); end
    def inspect_truncated(obj); end
  end
end

module GraphQL::Backtrace::LegacyTracer
  private

  # Implement the {GraphQL::Tracing} API.
  def trace(key, metadata); end

  class << self
    # Implement the {GraphQL::Tracing} API.
    def trace(key, metadata); end
  end
end

# A class for turning a context into a human-readable table or array
class GraphQL::Backtrace::Table
  def initialize(context, value:); end

  def to_backtrace; end
  def to_table; end

  private

  def build_rows(context_entry, rows:, top: T.unsafe(nil)); end
  def render_table(rows); end
  def rows; end
  def value_at(runtime, path); end
end

GraphQL::Backtrace::Table::HEADERS = T.let(T.unsafe(nil), Array)
GraphQL::Backtrace::Table::MAX_COL_WIDTH = T.let(T.unsafe(nil), Integer)
GraphQL::Backtrace::Table::MIN_COL_WIDTH = T.let(T.unsafe(nil), Integer)

# When {Backtrace} is enabled, raised errors are wrapped with {TracedError}.
class GraphQL::Backtrace::TracedError < ::GraphQL::Error
  def initialize(err, current_ctx); end

  def context; end
  def graphql_backtrace; end
end

# This many lines of the original Ruby backtrace
# are included in the message
GraphQL::Backtrace::TracedError::CAUSE_BACKTRACE_PREVIEW_LENGTH = T.let(T.unsafe(nil), Integer)

GraphQL::Backtrace::TracedError::MESSAGE_TEMPLATE = T.let(T.unsafe(nil), String)

# TODO this is not fiber-friendly
module GraphQL::Backtrace::Tracer
  private

  # Implement the {GraphQL::Tracing} API.
  def trace(key, metadata); end

  class << self
    # Implement the {GraphQL::Tracing} API.
    def trace(key, metadata); end
  end
end

# Helpers for migrating in a backwards-compatible way
# Remove this in GraphQL-Ruby 2.0, when all users of it will be gone.
module GraphQL::BackwardsCompatibility
  private

  def get_arity(callable); end

  # Given a callable whose API used to take `from` arguments,
  # check its arity, and if needed, apply a wrapper so that
  # it can be called with `to` arguments.
  # If a wrapper is applied, warn the application with `name`.
  #
  # If `last`, then use the last arguments to call the function.
  def wrap_arity(callable, from:, to:, name:, last: T.unsafe(nil)); end

  class << self
    def get_arity(callable); end

    # Given a callable whose API used to take `from` arguments,
    # check its arity, and if needed, apply a wrapper so that
    # it can be called with `to` arguments.
    # If a wrapper is applied, warn the application with `name`.
    #
    # If `last`, then use the last arguments to call the function.
    def wrap_arity(callable, from:, to:, name:, last: T.unsafe(nil)); end
  end
end

class GraphQL::BackwardsCompatibility::FirstArgumentsWrapper
  def initialize(callable, old_arity); end

  def call(*args); end
end

class GraphQL::BackwardsCompatibility::LastArgumentsWrapper < ::GraphQL::BackwardsCompatibility::FirstArgumentsWrapper
  def call(*args); end
end

# The parent for all type classes.
class GraphQL::BaseType
  include ::GraphQL::Define::NonNullWithBang
  include ::GraphQL::Define::InstanceDefinable
  include ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Define::InstanceDefinable::ClassMethods

  def initialize; end

  def ==(other); end

  # Returns the value of attribute ast_node.
  def ast_node; end

  # Sets the attribute ast_node
  def ast_node=(_arg0); end

  def coerce_input(value, ctx = T.unsafe(nil)); end
  def coerce_isolated_input(value); end
  def coerce_isolated_result(value); end
  def coerce_result(value, ctx); end
  def default_relay=(_arg0); end
  def default_relay?; end
  def default_scalar=(_arg0); end
  def default_scalar?; end
  def description; end
  def description=(_arg0); end

  # Types with fields may override this
  def get_field(name); end

  # Future-compatible alias
  def graphql_definition(silence_deprecation_warning: T.unsafe(nil)); end

  # Future-compatible alias
  def graphql_name; end

  # Print the human-readable name of this type using the query-string naming pattern
  def inspect; end

  def introspection=(_arg0); end
  def introspection?; end

  # Returns true if this is a list type. A non-nullable list is considered a list.
  def list?; end

  def name; end
  def name=(name); end

  # Returns true if this is a non-nullable type. A nullable list of non-nullables is considered nullable.
  def non_null?; end

  # Find out which possible type to use for `value`.
  # Returns self if there are no possible types (ie, not Union or Interface)
  def resolve_type(value, ctx); end

  # Return a GraphQL string for the type definition
  def to_definition(schema, printer: T.unsafe(nil), **args); end

  def to_list_type; end
  def to_non_null_type; end

  # Print the human-readable name of this type using the query-string naming pattern
  def to_s; end

  # Print the human-readable name of this type using the query-string naming pattern
  def to_type_signature; end

  def type_class; end

  # If this type is modifying an underlying type,
  # return the underlying type. (Otherwise, return `self`.)
  def unwrap; end

  def valid_input?(value, ctx = T.unsafe(nil)); end
  def valid_isolated_input?(value); end
  def validate_input(value, ctx = T.unsafe(nil)); end
  def validate_isolated_input(value); end

  private

  def initialize_copy(other); end
  def warn_deprecated_coerce(alt_method_name); end

  class << self
    # During schema definition, types can be defined inside procs or as strings.
    # This function converts it to a type instance
    def resolve_related_type(type_arg); end
  end
end

module GraphQL::BaseType::ModifiesAnotherType
  def ==(other); end
  def unwrap; end
end

class GraphQL::CoercionError < ::GraphQL::Error
  def initialize(message, extensions: T.unsafe(nil)); end

  # under the `extensions` key.
  def extensions; end

  # under the `extensions` key.
  def extensions=(_arg0); end
end

module GraphQL::Compatibility; end

# Test an execution strategy. This spec is not meant as a development aid.
# Rather, when the strategy _works_, run it here to see if it has any differences
# from the built-in strategy.
#
# - Custom scalar input / output
# - Null propagation
# - Query-level masking
# - Directive support
# - Typecasting
# - Error handling (raise / return GraphQL::ExecutionError)
# - Provides Irep & AST node to resolve fn
# - Skipping fields
#
# Some things are explicitly _not_ tested here, because they're handled
# by other parts of the system:
#
# - Schema definition (including types and fields)
# - Parsing & parse errors
# - AST -> IRep transformation (eg, fragment merging)
# - Query validation and analysis
# - Relay features
module GraphQL::Compatibility::ExecutionSpecification
  class << self
    # Make a minitest suite for this execution strategy, making sure it
    # fulfills all the requirements of this library.
    def build_suite(execution_strategy); end
  end
end

module GraphQL::Compatibility::ExecutionSpecification::CounterSchema
  class << self
    def build(execution_strategy); end
  end
end

module GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema
  class << self
    def build(execution_strategy); end
  end
end

GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema::BOGUS_NODE = T.let(T.unsafe(nil), OpenStruct)

# A list object must implement #each
class GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema::CustomCollection
  def initialize(storage); end

  def each(&block); end
end

GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema::DATA = T.let(T.unsafe(nil), Hash)

module GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema::TestMiddleware
  class << self
    def call(parent_type, parent_object, field_definition, field_args, query_context, &next_middleware); end
  end
end

module GraphQL::Compatibility::LazyExecutionSpecification
  class << self
    def build_suite(execution_strategy); end
  end
end

module GraphQL::Compatibility::LazyExecutionSpecification::LazySchema
  class << self
    def build(execution_strategy); end
  end
end

module GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyInstrumentation
  class << self
    def instrument(type, field); end
  end
end

class GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyPush
  def initialize(ctx, value); end

  def push; end

  # Returns the value of attribute value.
  def value; end
end

class GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyPushCollection
  def initialize(ctx, values); end

  def push; end
  def value; end
end

# This asserts that a given parse function turns a string into
# the proper tree of {{GraphQL::Language::Nodes}}.
module GraphQL::Compatibility::QueryParserSpecification
  class << self
    def build_suite(&block); end
  end
end

module GraphQL::Compatibility::QueryParserSpecification::ParseErrorSpecification
  def assert_raises_parse_error(query_string); end
  def assert_rejects_character(char); end
  def test_it_includes_line_and_column; end
  def test_it_rejects_bad_unicode; end
  def test_it_rejects_blank_queries; end
  def test_it_rejects_empty_inline_fragments; end
  def test_it_rejects_invalid_characters; end
  def test_it_rejects_unexpected_ends; end
  def test_it_rejects_unterminated_strings; end
  def test_it_restricts_on; end
end

GraphQL::Compatibility::QueryParserSpecification::QUERY_STRING = T.let(T.unsafe(nil), String)

module GraphQL::Compatibility::QueryParserSpecification::QueryAssertions
  def assert_valid_directive(directive); end
  def assert_valid_field(field); end
  def assert_valid_fragment(fragment_def); end
  def assert_valid_fragment_spread(fragment_spread); end
  def assert_valid_literal_argument(argument); end
  def assert_valid_query(query); end
  def assert_valid_typed_inline_fragment(inline_fragment); end
  def assert_valid_typeless_inline_fragment(inline_fragment); end
  def assert_valid_variable(variable); end
  def assert_valid_variable_argument(argument); end
end

# This asserts that a given parse function turns a string into
# the proper tree of {{GraphQL::Language::Nodes}}.
module GraphQL::Compatibility::SchemaParserSpecification
  class << self
    def build_suite(&block); end
  end
end

GraphQL::Compatibility::SchemaParserSpecification::SCHEMA_DEFINITION_STRING = T.let(T.unsafe(nil), String)
GraphQL::DEPRECATED_BOOLEAN_TYPE = T.let(T.unsafe(nil), GraphQL::ScalarType)
GraphQL::DEPRECATED_FLOAT_TYPE = T.let(T.unsafe(nil), GraphQL::ScalarType)
GraphQL::DEPRECATED_ID_TYPE = T.let(T.unsafe(nil), GraphQL::ScalarType)

# Ruby has `deprecate_constant`,
# but I don't see a way to give a nice error message in that case,
# so I'm doing this instead.
GraphQL::DEPRECATED_INT_TYPE = T.let(T.unsafe(nil), GraphQL::ScalarType)

GraphQL::DEPRECATED_STRING_TYPE = T.let(T.unsafe(nil), GraphQL::ScalarType)

# This plugin supports Fiber-based concurrency, along with {GraphQL::Dataloader::Source}.
class GraphQL::Dataloader
  def initialize(nonblocking: T.unsafe(nil)); end

  def append_job(&job); end
  def join_queues(previous_queue, next_queue); end
  def nonblocking?; end
  def run; end

  # Use a self-contained queue for the work in the block.
  def run_isolated; end

  # truffle-ruby wasn't doing well with the implementation below
  def with(source_class, *batch_args, **batch_kwargs); end

  # Tell the dataloader that this fiber is waiting for data.
  #
  # Dataloader will resume the fiber after the requested data has been loaded (by another Fiber).
  def yield; end

  private

  # If there are pending sources, return a fiber for running them.
  # Otherwise, return `nil`.
  def create_source_fiber; end

  def resume(fiber); end

  # Copies the thread local vars into the fiber thread local vars. Many
  # gems (such as RequestStore, MiniRacer, etc.) rely on thread local vars
  # to keep track of execution context, and without this they do not
  # behave as expected.
  def spawn_fiber; end

  class << self
    # Returns the value of attribute default_nonblocking.
    def default_nonblocking; end

    # Sets the attribute default_nonblocking
    def default_nonblocking=(_arg0); end

    def use(schema, nonblocking: T.unsafe(nil)); end

    # Call the block with a Dataloader instance,
    # then run all enqueued jobs and return the result of the block.
    def with_dataloading(&block); end
  end
end

class GraphQL::Dataloader::AsyncDataloader < ::GraphQL::Dataloader; end

# The default implementation of dataloading -- all no-ops.
#
# The Dataloader interface isn't public, but it enables
# simple internal code while adding the option to add Dataloader.
class GraphQL::Dataloader::NullDataloader < ::GraphQL::Dataloader
  def append_job; end

  # These are all no-ops because code was
  # executed sychronously.
  def run; end

  def run_isolated; end
  def yield; end
end

class GraphQL::Dataloader::Request
  def initialize(source, key); end

  # Call this method to cause the current Fiber to wait for the results of this request.
  def load; end
end

class GraphQL::Dataloader::RequestAll < ::GraphQL::Dataloader::Request
  def initialize(source, keys); end

  # Call this method to cause the current Fiber to wait for the results of this request.
  def load; end
end

class GraphQL::Dataloader::Source
  # Returns the value of attribute dataloader.
  def dataloader; end

  # Subclasses must implement this method to return a value for each of `keys`
  def fetch(keys); end

  def load(key); end
  def load_all(keys); end
  def pending?; end

  # Returns the value of attribute pending_keys.
  def pending_keys; end

  def request(key); end
  def request_all(keys); end

  # Called by {GraphQL::Dataloader} to resolve and pending requests to this source.
  def run_pending_keys; end

  # Called by {Dataloader} to prepare the {Source}'s internal state
  def setup(dataloader); end

  # Wait for a batch, if there's anything to batch.
  # Then run the batch and update the cache.
  def sync; end

  private

  # Reads and returns the result for the key from the internal cache, or raises an error if the result was an error
  def result_for(key); end

  class << self
    # These arguments are given to `dataloader.with(source_class, ...)`. The object
    # returned from this method is used to de-duplicate batch loads under the hood
    # by using it as a Hash key.
    #
    # By default, the arguments are all put in an Array. To customize how this source's
    # batches are merged, override this method to return something else.
    #
    # For example, if you pass `ActiveRecord::Relation`s to `.with(...)`, you could override
    # this method to call `.to_sql` on them, thus merging `.load(...)` calls when they apply
    # to equivalent relations.
    def batch_key_for(*batch_args, **batch_kwargs); end
  end
end

# This error is raised when `Types::ISO8601Date` is asked to return a value
# that cannot be parsed to a Ruby Date.
class GraphQL::DateEncodingError < ::GraphQL::RuntimeTypeError
  def initialize(value); end

  # The value which couldn't be encoded
  def date_value; end
end

module GraphQL::Define
  class << self
    # A helper for definitions that store their value in `#metadata`.
    def assign_metadata_key(key); end
  end
end

# Turn argument configs into a {GraphQL::Argument}.
module GraphQL::Define::AssignArgument
  class << self
    def call(target, *args, **kwargs, &block); end
  end
end

module GraphQL::Define::AssignConnection
  class << self
    def call(type_defn, *field_args, max_page_size: T.unsafe(nil), **field_kwargs, &field_block); end
  end
end

module GraphQL::Define::AssignEnumValue
  class << self
    def call(enum_type, name, desc = T.unsafe(nil), deprecation_reason: T.unsafe(nil), value: T.unsafe(nil), &block); end
  end
end

module GraphQL::Define::AssignGlobalIdField
  class << self
    def call(type_defn, field_name, **field_kwargs); end
  end
end

module GraphQL::Define::AssignMutationFunction
  class << self
    def call(target, function); end
  end
end

class GraphQL::Define::AssignMutationFunction::ResultProxy < ::SimpleDelegator
  def initialize(target, client_mutation_id); end

  # Returns the value of attribute client_mutation_id.
  def client_mutation_id; end
end

module GraphQL::Define::AssignObjectField
  class << self
    def call(owner_type, name, type_or_field = T.unsafe(nil), desc = T.unsafe(nil), function: T.unsafe(nil), field: T.unsafe(nil), relay_mutation_function: T.unsafe(nil), **kwargs, &block); end
  end
end

# This object delegates most methods to a dictionary of functions, {@dictionary}.
# {@target} is passed to the specified function, along with any arguments and block.
# This allows a method-based DSL without adding methods to the defined class.
class GraphQL::Define::DefinedObjectProxy
  extend ::GraphQL::Ruby2Keywords

  def initialize(target); end

  # Lookup a function from the dictionary and call it if it's found.
  def method_missing(name, *args, &block); end

  # The object which will be defined by definition functions
  def target; end

  # Provides shorthand access to GraphQL's built-in types
  def types; end

  # Allow `plugin` to perform complex initialization on the definition.
  # Calls `plugin.use(defn, **kwargs)`.
  def use(plugin, **kwargs); end

  private

  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

module GraphQL::Define::InstanceDefinable
  mixes_in_class_methods ::GraphQL::Define::InstanceDefinable::ClassMethods

  def define(**kwargs, &block); end
  def deprecated_define(**kwargs, &block); end
  def metadata; end
  def redefine(**kwargs, &block); end

  private

  # Run the definition block if it hasn't been run yet.
  # This can only be run once: the block is deleted after it's used.
  # You have to call this before using any value which could
  # come from the definition block.
  def ensure_defined; end

  def initialize_copy(other); end

  # Take the pending methods and put them back on this object's singleton class.
  # This reverts the process done by {#stash_dependent_methods}
  def revive_dependent_methods; end

  # Find the method names which were declared as definition-dependent,
  # then grab the method definitions off of this object's class
  # and store them for later.
  #
  # Then make a dummy method for each of those method names which:
  #
  # - Triggers the pending definition, if there is one
  # - Calls the same method again.
  #
  # It's assumed that {#ensure_defined} will put the original method definitions
  # back in place with {#revive_dependent_methods}.
  def stash_dependent_methods; end

  class << self
    def included(base); end
  end
end

class GraphQL::Define::InstanceDefinable::AssignAttribute
  extend ::GraphQL::Ruby2Keywords

  def initialize(attr_name); end

  # Even though we're just using the first value here,
  # We have to add a splat here to use `ruby2_keywords`,
  # so that it will accept a `[{}]` input from the caller.
  def call(defn, *value); end
end

class GraphQL::Define::InstanceDefinable::AssignMetadataKey
  def initialize(key); end

  def call(defn, value = T.unsafe(nil)); end
end

module GraphQL::Define::InstanceDefinable::ClassMethods
  # Attach definitions to this class.
  # Each symbol in `accepts` will be assigned with `{key}=`.
  # The last entry in accepts may be a hash of name-proc pairs for custom definitions.
  def accepts_definitions(*accepts); end

  def define(**kwargs, &block); end

  # Create a new instance
  # and prepare a definition using its {.definitions}.
  def deprecated_define(**kwargs, &block); end

  def dictionary; end
  def ensure_defined(*method_names); end
  def ensure_defined_method_names; end
  def own_dictionary; end
end

class GraphQL::Define::InstanceDefinable::Definition
  def initialize(define_keywords, define_proc); end

  def define_keywords; end
  def define_proc; end
end

module GraphQL::Define::InstanceDefinable::DeprecatedDefine
  def define(**kwargs, &block); end
end

class GraphQL::Define::NoDefinitionError < ::GraphQL::Error; end

# Wrap the object in NonNullType in response to `!`
module GraphQL::Define::NonNullWithBang
  # Make the type non-null
  def !; end
end

# Some conveniences for definining return & argument types.
#
# Passed into initialization blocks, eg {ObjectType#initialize}, {Field#initialize}
class GraphQL::Define::TypeDefiner
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  def Boolean; end
  def Float; end
  def ID; end
  def Int; end
  def String; end

  # Make a {ListType} which wraps the input type
  def [](type); end
end

# There are two ways to apply the deprecated `!` DSL to class-style schema definitions:
#
# 1. Scoped by file (CRuby only), add to the top of the file:
#
# using GraphQL::DeprecationDSL
#
# (This is a "refinement", there are also other ways to scope it.)
#
# 2. Global application, add before schema definition:
#
# GraphQL::DeprecationDSL.activate
module GraphQL::DeprecatedDSL
  class << self
    def activate; end
  end
end

module GraphQL::DeprecatedDSL::Methods
  def !; end
end

GraphQL::DeprecatedDSL::TYPE_CLASSES = T.let(T.unsafe(nil), Array)

module GraphQL::Deprecation
  class << self
    def warn(message); end
  end
end

module GraphQL::Dig
  # implemented using the old activesupport #dig instead of the ruby built-in
  # so we can use some of the magic in Schema::InputObject and Query::Arguments
  # to handle stringified/symbolized keys.
  def dig(own_key, *rest_keys); end
end

# Directives are server-defined hooks for modifying execution.
#
# Two directives are included out-of-the-box:
# - `@skip(if: ...)` Skips the tagged field if the value of `if` is true
# - `@include(if: ...)` Includes the tagged field _only_ if `if` is true
class GraphQL::Directive
  include ::GraphQL::Define::InstanceDefinable
  extend ::GraphQL::Define::InstanceDefinable::ClassMethods

  def initialize; end

  # Returns the value of attribute arguments.
  def arguments; end

  # Sets the attribute arguments
  def arguments=(_arg0); end

  # Returns the value of attribute arguments_class.
  def arguments_class; end

  # Sets the attribute arguments_class
  def arguments_class=(_arg0); end

  # Returns the value of attribute ast_node.
  def ast_node; end

  # Sets the attribute ast_node
  def ast_node=(_arg0); end

  def default_directive=(_arg0); end
  def default_directive?; end

  # Returns the value of attribute description.
  def description; end

  # Sets the attribute description
  def description=(_arg0); end

  def get_argument(argument_name); end

  # Future-compatible alias
  def graphql_definition; end

  # Returns the value of attribute name.
  # Future-compatible alias
  def graphql_name; end

  def inspect; end

  # Returns the value of attribute locations.
  def locations; end

  # Sets the attribute locations
  def locations=(_arg0); end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  def name=(_arg0); end

  def on_field?; end
  def on_fragment?; end
  def on_operation?; end
  def to_s; end
  def type_class; end
end

GraphQL::Directive::ARGUMENT_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::DeprecatedDirective = T.let(T.unsafe(nil), GraphQL::Directive)
GraphQL::Directive::ENUM = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::ENUM_VALUE = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::FIELD = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::FIELD_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::FRAGMENT_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::FRAGMENT_SPREAD = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::INLINE_FRAGMENT = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::INPUT_FIELD_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::INPUT_OBJECT = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::INTERFACE = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::IncludeDirective = T.let(T.unsafe(nil), GraphQL::Directive)
GraphQL::Directive::LOCATIONS = T.let(T.unsafe(nil), Array)
GraphQL::Directive::LOCATION_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)
GraphQL::Directive::MUTATION = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::OBJECT = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::QUERY = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::SCALAR = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::SCHEMA = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::SUBSCRIPTION = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::SkipDirective = T.let(T.unsafe(nil), GraphQL::Directive)
GraphQL::Directive::UNION = T.let(T.unsafe(nil), Symbol)

class GraphQL::EnumType < ::GraphQL::BaseType
  extend ::GraphQL::Define::InstanceDefinable::DeprecatedDefine

  def initialize; end

  def add_value(enum_value); end
  def ast_node; end
  def ast_node=(_arg0); end
  def coerce_result(value, ctx = T.unsafe(nil)); end
  def enum_values(_context = T.unsafe(nil)); end
  def kind; end
  def to_s; end
  def values(_context = T.unsafe(nil)); end
  def values=(new_values); end

  private

  # Get the underlying value for this enum value
  def coerce_non_null_input(value_name, ctx); end

  def initialize_copy(other); end
  def validate_non_null_input(value_name, ctx); end
end

# A value within an {EnumType}
#
# Created with the `value` helper
class GraphQL::EnumType::EnumValue
  include ::GraphQL::Define::InstanceDefinable
  extend ::GraphQL::Define::InstanceDefinable::ClassMethods

  def ast_node; end
  def ast_node=(_arg0); end
  def deprecation_reason; end
  def deprecation_reason=(_arg0); end
  def description; end
  def description=(_arg0); end
  def graphql_name; end
  def name; end
  def name=(new_name); end
  def type_class; end
  def value; end
  def value=(_arg0); end
end

GraphQL::EnumType::EnumValue::ATTRIBUTES = T.let(T.unsafe(nil), Array)
class GraphQL::EnumType::UnresolvedValueError < ::GraphQL::Error; end
class GraphQL::Error < ::StandardError; end
module GraphQL::Execution; end

# Boolean checks for how an AST node's directives should
# influence its execution
module GraphQL::Execution::DirectiveChecks
  private

  def include?(directive_ast_nodes, query); end

  class << self
    def include?(directive_ast_nodes, query); end
  end
end

GraphQL::Execution::DirectiveChecks::INCLUDE = T.let(T.unsafe(nil), String)
GraphQL::Execution::DirectiveChecks::SKIP = T.let(T.unsafe(nil), String)

# A plugin that wraps query execution with error handling.
# Supports class-based schemas and the new {Interpreter} runtime only.
class GraphQL::Execution::Errors
  def initialize(schema); end

  def each_rescue; end
  def find_handler_for(error_class); end

  # Register this handler, updating the
  # internal handler index to maintain least-to-most specific.
  def rescue_from(error_class, error_handler); end

  # Call the given block with the schema's configured error handlers.
  #
  # If the block returns a lazy value, it's not wrapped with error handling. That area will have to be wrapped itself.
  def with_error_handling(ctx); end

  class << self
    def use(schema); end
  end
end

GraphQL::Execution::Errors::NEW_HANDLER_HASH = T.let(T.unsafe(nil), Proc)

# A valid execution strategy
class GraphQL::Execution::Execute
  include ::GraphQL::Execution::Execute::ExecutionFunctions

  def execute(ast_operation, root_type, query); end

  class << self
    def begin_multiplex(_multiplex); end
    def begin_query(query, _multiplex); end
    def finish_multiplex(results, multiplex); end
    def finish_query(query, _multiplex); end
    def use(schema_class); end
  end
end

module GraphQL::Execution::Execute::ExecutionFunctions
  private

  # If the returned object is lazy (unfinished),
  # assign the lazy object to `.value=` so we can resolve it later.
  # When we resolve it later, reassign it to `.value=` so that
  # the finished value replaces the unfinished one.
  #
  # If the returned object is finished, continue to coerce
  # and resolve child fields
  def continue_or_wait(raw_value, field_type, field_ctx); end

  def continue_resolve_field(raw_value, field_type, field_ctx); end
  def lazy_resolve_root_selection(result, query: T.unsafe(nil), multiplex: T.unsafe(nil)); end
  def resolve_field(object, field_ctx); end
  def resolve_root_selection(query); end
  def resolve_selection(object, current_type, current_ctx, mutation: T.unsafe(nil)); end
  def resolve_value(value, field_type, field_ctx); end

  class << self
    # If the returned object is lazy (unfinished),
    # assign the lazy object to `.value=` so we can resolve it later.
    # When we resolve it later, reassign it to `.value=` so that
    # the finished value replaces the unfinished one.
    #
    # If the returned object is finished, continue to coerce
    # and resolve child fields
    def continue_or_wait(raw_value, field_type, field_ctx); end

    def continue_resolve_field(raw_value, field_type, field_ctx); end
    def lazy_resolve_root_selection(result, query: T.unsafe(nil), multiplex: T.unsafe(nil)); end
    def resolve_field(object, field_ctx); end
    def resolve_root_selection(query); end
    def resolve_selection(object, current_type, current_ctx, mutation: T.unsafe(nil)); end
    def resolve_value(value, field_type, field_ctx); end
  end
end

# A `.call`-able suitable to be the last step in a middleware chain
module GraphQL::Execution::Execute::FieldResolveStep
  class << self
    # Execute the field's resolve method
    def call(_parent_type, parent_object, field_definition, field_args, context, _next = T.unsafe(nil)); end
  end
end

GraphQL::Execution::Execute::PROPAGATE_NULL = T.let(T.unsafe(nil), GraphQL::Execution::Execute::PropagateNull)
class GraphQL::Execution::Execute::PropagateNull; end

# Just a singleton for implementing {Query::Context#skip}
GraphQL::Execution::Execute::SKIP = T.let(T.unsafe(nil), GraphQL::Execution::Execute::Skip)

class GraphQL::Execution::Execute::Skip < ::GraphQL::Error; end

# Starting from a root context,
# create a hash out of the context tree.
module GraphQL::Execution::Flatten
  class << self
    def call(ctx); end

    private

    def flatten(obj); end
  end
end

module GraphQL::Execution::Instrumentation
  class << self
    # This function implements the instrumentation policy:
    #
    # - Instrumenters are a stack; the first `before_query` will have the last `after_query`
    # - If a `before_` hook returned without an error, its corresponding `after_` hook will run.
    # - If the `before_` hook did _not_ run, the `after_` hook will not be called.
    #
    # When errors are raised from `after_` hooks:
    # - Subsequent `after_` hooks _are_ called
    # - The first raised error is captured; later errors are ignored
    # - If an error was capture, it's re-raised after all hooks are finished
    #
    # Partial runs of instrumentation are possible:
    # - If a `before_multiplex` hook raises an error, no `before_query` hooks will run
    # - If a `before_query` hook raises an error, subsequent `before_query` hooks will not run (on any query)
    def apply_instrumenters(multiplex); end

    private

    def call_after_hooks(instrumenters, object, after_hook_name, ex); end

    # Call each before hook, and if they all succeed, yield.
    # If they don't all succeed, call after_ for each one that succeeded.
    def call_hooks(instrumenters, object, before_hook_name, after_hook_name); end

    # Call the before_ hooks of each query,
    # Then yield if no errors.
    # `call_hooks` takes care of appropriate cleanup.
    def each_query_call_hooks(instrumenters, queries, i = T.unsafe(nil)); end
  end
end

class GraphQL::Execution::Interpreter
  def initialize; end

  # Run the eager part of `query`
  def evaluate(query); end

  # Support `Executor` :S
  def execute(_operation, _root_type, query); end

  # Run the lazy part of `query` or `multiplex`.
  def sync_lazies(query: T.unsafe(nil), multiplex: T.unsafe(nil)); end

  class << self
    def begin_multiplex(multiplex); end
    def begin_query(query, multiplex); end
    def finish_multiplex(_results, multiplex); end
    def finish_query(query, _multiplex); end
    def use(schema_class); end
  end
end

# A container for metadata regarding arguments present in a GraphQL query.
class GraphQL::Execution::Interpreter::ArgumentValue
  def initialize(definition:, value:, default_used:); end

  def default_used?; end
  def definition; end
  def value; end
end

# A wrapper for argument hashes in GraphQL queries.
#
# This object is immutable so that the runtime code can be sure that
# modifications don't leak from one use to another
class GraphQL::Execution::Interpreter::Arguments
  include ::GraphQL::Dig
  extend ::Forwardable

  def initialize(argument_values:, keyword_arguments: T.unsafe(nil)); end

  def [](*args, &block); end
  def argument_values; end
  def each(*args, &block); end
  def each_value(*args, &block); end
  def empty?; end
  def fetch(*args, &block); end
  def inspect; end
  def key?(*args, &block); end
  def keys(*args, &block); end

  # The Ruby-style arguments hash, ready for a resolver.
  # This hash is the one used at runtime.
  def keyword_arguments; end

  # Create a new arguments instance which includes these extras.
  #
  # This is called by the runtime to implement field `extras: [...]`
  def merge_extras(extra_args); end

  def size(*args, &block); end
  def to_h(*args, &block); end
  def values(*args, &block); end
end

GraphQL::Execution::Interpreter::Arguments::EMPTY = T.let(T.unsafe(nil), GraphQL::Execution::Interpreter::Arguments)
GraphQL::Execution::Interpreter::Arguments::NO_ARGS = T.let(T.unsafe(nil), Hash)

class GraphQL::Execution::Interpreter::ArgumentsCache
  def initialize(query); end

  def dataload_for(ast_node, argument_owner, parent_object, &block); end
  def fetch(ast_node, argument_owner, parent_object); end

  class << self
    def prepare_args_hash(query, ast_arg_or_hash_or_value); end
  end
end

GraphQL::Execution::Interpreter::ArgumentsCache::NO_ARGUMENTS = T.let(T.unsafe(nil), Hash)
GraphQL::Execution::Interpreter::ArgumentsCache::NO_VALUE_GIVEN = T.let(T.unsafe(nil), Object)

class GraphQL::Execution::Interpreter::ExecutionErrors
  def initialize(ctx, ast_node, path); end

  def add(err_or_msg); end
end

class GraphQL::Execution::Interpreter::ListResultFailedError < ::GraphQL::Error
  def initialize(value:, path:, field:); end
end

# Wrapper for raw values
class GraphQL::Execution::Interpreter::RawValue
  def initialize(obj = T.unsafe(nil)); end

  def resolve; end
end

module GraphQL::Execution::Interpreter::Resolve
  class << self
    # After getting `results` back from an interpreter evaluation,
    # continue it until you get a response-ready Ruby value.
    #
    # `results` is one level of _depth_ of a query or multiplex.
    #
    # Resolve all lazy values in that depth before moving on
    # to the next level.
    #
    # It's assumed that the lazies will
    # return {Lazy} instances if there's more work to be done,
    # or return {Hash}/{Array} if the query should be continued.
    def resolve(results, dataloader); end

    # Continue field results in `results` until there's nothing else to continue.
    def resolve_all(results, dataloader); end
  end
end

# I think it would be even better if we could somehow make
# `continue_field` not recursive. "Trampolining" it somehow.
class GraphQL::Execution::Interpreter::Runtime
  def initialize(query:); end

  def after_lazy(lazy_obj, owner:, field:, path:, scoped_context:, owner_object:, arguments:, ast_node:, result:, result_name:, eager: T.unsafe(nil), trace: T.unsafe(nil), &block); end
  def arguments(graphql_object, arg_owner, ast_node); end
  def authorized_new(type, value, context); end
  def call_method_on_directives(method_name, object, directives, &block); end
  def context; end

  # The resolver for `field` returned `value`. Continue to execute the query,
  # treating `value` as `type` (probably the return type of the field).
  #
  # Use `next_selections` to resolve object fields, if there are any.
  #
  # Location information from `path` and `ast_node`.
  def continue_field(path, value, owner_type, field, current_type, ast_node, next_selections, is_non_null, owner_object, arguments, result_name, selection_result); end

  def continue_value(path, value, parent_type, field, is_non_null, ast_node, result_name, selection_result); end
  def dead_result?(selection_result); end
  def deep_merge_selection_result(from_result, into_result); end
  def delete_interpreter_context(key); end

  # Check {Schema::Directive.include?} for each directive that's present
  def directives_include?(node, graphql_object, parent_type); end

  def evaluate_selection(path, result_name, field_ast_nodes_or_ast_node, scoped_context, owner_object, owner_type, is_eager_field, selections_result, parent_object); end
  def evaluate_selection_with_args(arguments, field_defn, next_path, ast_node, field_ast_nodes, scoped_context, owner_type, object, is_eager_field, result_name, selection_result, parent_object); end
  def evaluate_selections(path, scoped_context, owner_object, owner_type, is_eager_selection, gathered_selections, selections_result, target_result, parent_object); end
  def final_result; end
  def gather_selections(owner_object, owner_type, selections, selections_to_run = T.unsafe(nil), selections_by_name = T.unsafe(nil)); end
  def inspect; end
  def lazy?(object); end
  def progress_path; end
  def query; end
  def resolve_list_item(inner_value, inner_type, next_path, ast_node, scoped_context, field, owner_object, arguments, this_idx, response_list, next_selections, owner_type); end
  def resolve_type(type, value, path); end
  def run_directive(method_name, object, directives, idx, &block); end

  # This _begins_ the execution. Some deferred work
  # might be stored up in lazies.
  def run_eager; end

  def schema; end
  def set_all_interpreter_context(object, field, arguments, path); end

  # Mark this node and any already-registered children as dead,
  # so that it accepts no more writes.
  def set_graphql_dead(selection_result); end

  # Set this pair in the Query context, but also in the interpeter namespace,
  # for compatibility.
  def set_interpreter_context(key, value); end

  def set_result(selection_result, result_name, value); end
  def tap_or_each(obj_or_array); end
end

module GraphQL::Execution::Interpreter::Runtime::GraphQLResult
  def initialize(result_name, parent_result); end

  def graphql_dead; end
  def graphql_dead=(_arg0); end

  # Although these are used by only one of the Result classes,
  # it's handy to have the methods implemented on both (even though they just return `nil`)
  # because it makes it easy to check if anything is assigned.
  def graphql_non_null_field_names; end

  # Although these are used by only one of the Result classes,
  # it's handy to have the methods implemented on both (even though they just return `nil`)
  # because it makes it easy to check if anything is assigned.
  def graphql_non_null_field_names=(_arg0); end

  def graphql_non_null_list_items; end
  def graphql_non_null_list_items=(_arg0); end
  def graphql_parent; end
  def graphql_result_data; end
  def graphql_result_data=(_arg0); end
  def graphql_result_name; end
end

class GraphQL::Execution::Interpreter::Runtime::GraphQLResultArray
  include ::GraphQL::Execution::Interpreter::Runtime::GraphQLResult

  def initialize(_result_name, _parent_result); end

  def []=(idx, value); end
  def graphql_skip_at(index); end
  def values; end
end

class GraphQL::Execution::Interpreter::Runtime::GraphQLResultHash
  include ::GraphQL::Execution::Interpreter::Runtime::GraphQLResult

  def initialize(_result_name, _parent_result); end

  def [](k); end
  def []=(key, value); end
  def delete(key); end
  def each; end
  def graphql_merged_into; end
  def graphql_merged_into=(_arg0); end
  def key?(k); end
  def values; end
end

class GraphQL::Execution::Interpreter::Runtime::GraphQLSelectionSet < ::Hash
  def graphql_directives; end
  def graphql_directives=(_arg0); end
end

GraphQL::Execution::Interpreter::Runtime::HALT = T.let(T.unsafe(nil), Object)
GraphQL::Execution::Interpreter::Runtime::NO_ARGS = T.let(T.unsafe(nil), Hash)

# This wraps a value which is available, but not yet calculated, like a promise or future.
#
# Calling `#value` will trigger calculation & return the "lazy" value.
#
# This is an itty-bitty promise-like object, with key differences:
# - It has only two states, not-resolved and resolved
# - It has no error-catching functionality
class GraphQL::Execution::Lazy
  # Create a {Lazy} which will get its inner value by calling the block
  def initialize(path: T.unsafe(nil), field: T.unsafe(nil), &get_value_func); end

  def field; end
  def path; end
  def then; end
  def value; end

  class << self
    def all(lazies); end

    # Traverse `val`, lazily resolving any values along the way
    def resolve(val); end
  end
end

# {GraphQL::Schema} uses this to match returned values to lazy resolution methods.
# Methods may be registered for classes, they apply to its subclasses also.
# The result of this lookup is cached for future resolutions.
# Instances of this class are thread-safe.
class GraphQL::Execution::Lazy::LazyMethodMap
  def initialize(use_concurrent: T.unsafe(nil)); end

  def each; end
  def get(value); end
  def set(lazy_class, lazy_value_method); end

  protected

  def storage; end

  private

  def find_superclass_method(value_class); end
  def initialize_copy(other); end
end

# Mock the Concurrent::Map API
class GraphQL::Execution::Lazy::LazyMethodMap::ConcurrentishMap
  extend ::Forwardable

  def initialize; end

  def []=(key, value); end
  def compute_if_absent(key); end
  def each_pair(*args, &block); end
  def size(*args, &block); end

  protected

  def copy_storage; end

  private

  def initialize_copy(other); end
end

# This can be used for fields which _had no_ lazy results
GraphQL::Execution::Lazy::NullResult = T.let(T.unsafe(nil), GraphQL::Execution::Lazy)

# Helpers for dealing with data structures containing {Lazy} instances
module GraphQL::Execution::Lazy::Resolve
  class << self
    # Traverse `val`, triggering resolution for each {Lazy}.
    # These {Lazy}s are expected to mutate their owner data structures
    # during resolution! (They're created with the `.then` calls in `resolve_in_place`).
    def deep_sync(val); end

    # If `value` is a collection,
    # add any {Lazy} instances in the collection
    # to `acc`
    def each_lazy(acc, value); end

    def resolve(value); end
    def resolve_in_place(value); end
  end
end

# This object can be passed like an array, but it doesn't allocate an
# array until it's used.
#
# There's one crucial difference: you have to _capture_ the result
# of `#<<`. (This _works_ with arrays but isn't required, since it has a side-effect.)
module GraphQL::Execution::Lazy::Resolve::NullAccumulator
  class << self
    def <<(item); end
    def empty?; end
  end
end

# Lookahead creates a uniform interface to inspect the forthcoming selections.
#
# It assumes that the AST it's working with is valid. (So, it's safe to use
# during execution, but if you're using it directly, be sure to validate first.)
#
# A field may get access to its lookahead by adding `extras: [:lookahead]`
# to its configuration.
class GraphQL::Execution::Lookahead
  def initialize(query:, ast_nodes:, field: T.unsafe(nil), root_type: T.unsafe(nil), owner_type: T.unsafe(nil)); end

  def arguments; end
  def ast_nodes; end
  def field; end
  def inspect; end

  # The method name of the field.
  # It returns the method_sym of the Lookahead's field.
  def name; end

  def owner_type; end
  def selected?; end

  # Like {#selects?}, but can be used for chaining.
  # It returns a null object (check with {#selected?})
  def selection(field_name, selected_type: T.unsafe(nil), arguments: T.unsafe(nil)); end

  # Like {#selection}, but for all nodes.
  # It returns a list of Lookaheads for all Selections
  #
  # If `arguments:` is provided, each provided key/value will be matched
  # against the arguments in each selection. This method will filter the selections
  # if any of the given `arguments:` do not match the given selection.
  def selections(arguments: T.unsafe(nil)); end

  # True if this node has a selection on `field_name`.
  # If `field_name` is a String, it is treated as a GraphQL-style (camelized)
  # field name and used verbatim. If `field_name` is a Symbol, it is
  # treated as a Ruby-style (underscored) name and camelized before comparing.
  #
  # If `arguments:` is provided, each provided key/value will be matched
  # against the arguments in the next selection. This method will return false
  # if any of the given `arguments:` are not present and matching in the next selection.
  # (But, the next selection may contain _more_ than the given arguments.)
  def selects?(field_name, arguments: T.unsafe(nil)); end

  private

  def arguments_match?(arguments, field_defn, field_node); end

  # If a selection on `node` matches `field_name` (which is backed by `field_defn`)
  # and matches the `arguments:` constraints, then add that node to `matches`
  def find_selected_nodes(node, field_name, field_defn, arguments:, matches:); end

  def find_selections(subselections_by_type, selections_on_type, selected_type, ast_selections, arguments); end

  # Wrap get_field and ensure that it returns a GraphQL::Schema::Field.
  # Remove this when legacy execution is removed.
  def get_class_based_field(type, name); end

  def normalize_keyword(keyword); end

  # If it's a symbol, stringify and camelize it
  def normalize_name(name); end

  def skipped_by_directive?(ast_selection); end
end

# A singleton, so that misses don't come with overhead.
GraphQL::Execution::Lookahead::NULL_LOOKAHEAD = T.let(T.unsafe(nil), GraphQL::Execution::Lookahead::NullLookahead)

# This is returned for {Lookahead#selection} when a non-existent field is passed
class GraphQL::Execution::Lookahead::NullLookahead < ::GraphQL::Execution::Lookahead
  # No inputs required here.
  def initialize; end

  def inspect; end
  def selected?; end
  def selection(*_arg0); end
  def selections(*_arg0); end
  def selects?(*_arg0); end
end

# Execute multiple queries under the same multiplex "umbrella".
# They can share a batching context and reduce redundant database hits.
#
# The flow is:
#
# - Multiplex instrumentation setup
# - Query instrumentation setup
# - Analyze the multiplex + each query
# - Begin each query
# - Resolve lazy values, breadth-first across all queries
# - Finish each query (eg, get errors)
# - Query instrumentation teardown
# - Multiplex instrumentation teardown
#
# If one query raises an application error, all queries will be in undefined states.
#
# Validation errors and {GraphQL::ExecutionError}s are handled in isolation:
# one of these errors in one query will not affect the other queries.
class GraphQL::Execution::Multiplex
  include ::GraphQL::Tracing::Traceable
  extend ::GraphQL::PersistedQueries::CompiledQueries::MultiplexPatch

  def initialize(schema:, queries:, context:, max_complexity:); end

  def context; end
  def dataloader; end
  def max_complexity; end
  def queries; end
  def schema; end

  class << self
    def run_all(schema, query_options, **kwargs); end
    def run_queries(schema, queries, context: T.unsafe(nil), max_complexity: T.unsafe(nil)); end

    private

    def finish_query(data_result, query, multiplex); end

    # Apply multiplex & query instrumentation to `queries`.
    #
    # It yields when the queries should be executed, then runs teardown.
    def instrument_and_analyze(multiplex); end

    def run_as_multiplex(multiplex); end

    # use the old `query_execution_strategy` etc to run this query
    def run_one_legacy(schema, query); end

    def supports_multiplexing?(schema); end
  end
end

# Used internally to signal that the query shouldn't be executed
GraphQL::Execution::Multiplex::NO_OPERATION = T.let(T.unsafe(nil), Hash)

module GraphQL::Execution::Typecast
  class << self
    def subtype?(parent_type, child_type); end
  end
end

# If a field's resolve function returns a {ExecutionError},
# the error will be inserted into the response's `"errors"` key
# and the field will resolve to `nil`.
class GraphQL::ExecutionError < ::GraphQL::Error
  def initialize(message, ast_node: T.unsafe(nil), options: T.unsafe(nil), extensions: T.unsafe(nil)); end

  def ast_node; end
  def ast_node=(_arg0); end

  # under the `extensions` key.
  def extensions; end

  # under the `extensions` key.
  def extensions=(_arg0); end

  # recommends that any custom entries in an error be under the
  # `extensions` key.
  def options; end

  # recommends that any custom entries in an error be under the
  # `extensions` key.
  def options=(_arg0); end

  # response which corresponds to this error.
  def path; end

  # response which corresponds to this error.
  def path=(_arg0); end

  def to_h; end
end

GraphQL::FLOAT_TYPE = T.let(T.unsafe(nil), GraphQL::ScalarType)

class GraphQL::Field
  include ::GraphQL::Define::InstanceDefinable
  extend ::GraphQL::Define::InstanceDefinable::ClassMethods

  def initialize; end

  def arguments; end
  def arguments=(_arg0); end
  def arguments_class; end
  def arguments_class=(_arg0); end
  def ast_node; end
  def ast_node=(_arg0); end
  def complexity; end
  def complexity=(_arg0); end
  def connection=(_arg0); end
  def connection?; end
  def connection_max_page_size; end
  def connection_max_page_size=(_arg0); end
  def deprecation_reason; end
  def deprecation_reason=(_arg0); end
  def description; end
  def description=(_arg0); end
  def edge_class; end
  def edge_class=(_arg0); end
  def edges?; end
  def function; end
  def function=(_arg0); end
  def get_argument(argument_name); end

  # Future-compatible alias
  def graphql_definition; end

  def graphql_name; end
  def hash_key; end
  def hash_key=(new_hash_key); end
  def introspection=(_arg0); end
  def introspection?; end

  # If {#resolve} returned an object which should be handled lazily,
  # this method will be called later to force the object to return its value.
  def lazy_resolve(obj, args, ctx); end

  # Assign a new resolve proc to this field. Used for {#lazy_resolve}
  def lazy_resolve=(new_lazy_resolve_proc); end

  def lazy_resolve_proc; end
  def mutation; end
  def mutation=(_arg0); end
  def name; end
  def name=(new_name); end

  # Prepare a lazy value for this field. It may be `then`-ed and resolved later.
  def prepare_lazy(obj, args, ctx); end

  def property; end
  def property=(new_property); end
  def relay_node_field; end
  def relay_node_field=(_arg0); end
  def relay_nodes_field; end
  def relay_nodes_field=(_arg0); end

  # Get a value for this field
  def resolve(object, arguments, context); end

  # Provide a new callable for this field's resolve function. If `nil`,
  # a new resolve proc will be build based on its {#name}, {#property} or {#hash_key}.
  def resolve=(new_resolve_proc); end

  def resolve_proc; end
  def subscription_scope; end
  def subscription_scope=(_arg0); end
  def to_s; end
  def trace; end
  def trace=(_arg0); end

  # Get the return type for this field.
  def type; end

  def type=(new_return_type); end
  def type_class; end

  private

  def build_default_resolver; end
  def initialize_copy(other); end
end

module GraphQL::Field::DefaultLazyResolve
  class << self
    def call(obj, args, ctx); end
  end
end

# Create resolve procs ahead of time based on a {GraphQL::Field}'s `name`, `property`, and `hash_key` configuration.
module GraphQL::Field::Resolve
  private

  def create_proc(field); end

  class << self
    def create_proc(field); end
  end
end

# These only require `obj` as input
class GraphQL::Field::Resolve::BuiltInResolve; end

# Resolve the field by looking up `@hash_key` with `#[]`
class GraphQL::Field::Resolve::HashKeyResolve < ::GraphQL::Field::Resolve::BuiltInResolve
  def initialize(hash_key); end

  def call(obj, args, ctx); end
end

# Resolve the field by `public_send`ing `@method_name`
class GraphQL::Field::Resolve::MethodResolve < ::GraphQL::Field::Resolve::BuiltInResolve
  def initialize(field); end

  def call(obj, args, ctx); end
end

# Call the field's name at query-time since
# it might have changed
class GraphQL::Field::Resolve::NameResolve < ::GraphQL::Field::Resolve::BuiltInResolve
  def initialize(field); end

  def call(obj, args, ctx); end
end

class GraphQL::Filter
  def initialize(only: T.unsafe(nil), except: T.unsafe(nil)); end

  # Returns true if `member, ctx` passes this filter
  def call(member, ctx); end

  def merge(only: T.unsafe(nil), except: T.unsafe(nil)); end
end

class GraphQL::Filter::MergedExcept < ::GraphQL::Filter::MergedOnly
  def call(member, ctx); end
end

class GraphQL::Filter::MergedOnly
  def initialize(first, second); end

  def call(member, ctx); end

  class << self
    def build(onlies); end
  end
end

class GraphQL::Function
  def arguments; end
  def call(obj, args, ctx); end
  def complexity; end
  def deprecation_reason; end
  def description; end
  def type; end

  class << self
    # Define an argument for this function & its subclasses
    def argument(*args, **kwargs, &block); end

    def arguments; end
    def build_field(function); end

    # Get or set this class's complexity
    def complexity(new_value = T.unsafe(nil)); end

    # Get or set this class's deprecation_reason
    def deprecation_reason(new_value = T.unsafe(nil)); end

    # Get or set this class's description
    def description(new_value = T.unsafe(nil)); end

    def inherited(subclass); end

    # Get or set the return type for this function class & descendants
    def type(premade_type = T.unsafe(nil), &block); end

    # Provides shorthand access to GraphQL's built-in types
    def types; end

    private

    # Arguments defined on this class (not superclasses)
    def own_arguments; end

    # Does this function inherit from another function?
    def parent_function?; end
  end
end

GraphQL::ID_TYPE = T.let(T.unsafe(nil), GraphQL::ScalarType)
GraphQL::INT_TYPE = T.let(T.unsafe(nil), GraphQL::ScalarType)

class GraphQL::InputObjectType < ::GraphQL::BaseType
  extend ::GraphQL::Define::InstanceDefinable::DeprecatedDefine

  def initialize; end

  def arguments; end
  def arguments=(_arg0); end
  def arguments_class; end
  def arguments_class=(_arg0); end
  def coerce_result(value, ctx = T.unsafe(nil)); end
  def get_argument(argument_name); end
  def input_fields; end
  def kind; end
  def mutation; end
  def mutation=(_arg0); end

  private

  def coerce_non_null_input(value, ctx); end
  def initialize_copy(other); end
  def validate_non_null_input(input, ctx); end
end

GraphQL::InputObjectType::INVALID_OBJECT_MESSAGE = T.let(T.unsafe(nil), String)

# This error is raised when `Types::Int` is given an input value outside of 32-bit integer range.
#
# For really big integer values, consider `GraphQL::Types::BigInt`
class GraphQL::IntegerDecodingError < ::GraphQL::RuntimeTypeError
  def initialize(value); end

  # The value which couldn't be decoded
  def integer_value; end
end

# This error is raised when `Types::Int` is asked to return a value outside of 32-bit integer range.
#
# For values outside that range, consider:
#
# - `ID` for database primary keys or other identifiers
# - `GraphQL::Types::BigInt` for really big integer values
class GraphQL::IntegerEncodingError < ::GraphQL::RuntimeTypeError
  def initialize(value, context:); end

  def field; end

  # The value which couldn't be encoded
  def integer_value; end

  def path; end
end

class GraphQL::InterfaceType < ::GraphQL::BaseType
  extend ::GraphQL::Define::InstanceDefinable::DeprecatedDefine

  def initialize; end

  # These fields don't have instrumenation applied
  def all_fields; end

  def fields; end
  def fields=(_arg0); end
  def get_field(field_name); end

  # Get a possible type of this {InterfaceType} by type name
  def get_possible_type(type_name, ctx); end

  def kind; end
  def orphan_types; end
  def orphan_types=(_arg0); end

  # Check if a type is a possible type of this {InterfaceType}
  def possible_type?(type, ctx); end

  def resolve_type(value, ctx); end
  def resolve_type=(resolve_type_callable); end
  def resolve_type_proc; end
  def resolve_type_proc=(_arg0); end
  def type_membership_class; end
  def type_membership_class=(_arg0); end

  private

  def initialize_copy(other); end
end

module GraphQL::InternalRepresentation; end

class GraphQL::InternalRepresentation::Document
  def initialize; end

  def [](key); end
  def each(&block); end
  def fragment_definitions; end
  def operation_definitions; end
end

class GraphQL::InternalRepresentation::Node
  def initialize(name:, owner_type:, query:, return_type:, parent:, ast_nodes: T.unsafe(nil), definitions: T.unsafe(nil)); end

  def ==(other); end
  def arguments; end
  def ast_node; end
  def ast_nodes; end

  # Merge selections from `new_parent` into `self`.
  # Selections are merged in place, not copied.
  def deep_merge_node(new_parent, scope: T.unsafe(nil), merge_self: T.unsafe(nil)); end

  def definition; end
  def definition_name; end
  def definitions; end
  def inspect; end
  def name; end
  def owner_type; end
  def parent; end
  def query; end
  def return_type; end

  # These children correspond closely to scopes in the AST.
  # Keys _may_ be abstract types. They're assumed to be read-only after rewrite is finished
  # because {#typed_children} is derived from them.
  #
  # Using {#scoped_children} during the rewrite step reduces the overhead of reifying
  # abstract types because they're only reified _after_ the rewrite.
  def scoped_children; end

  def subscription_topic; end

  # Each key is a {GraphQL::ObjectType} which this selection _may_ be made on.
  # The values for that key are selections which apply to that type.
  #
  # This value is derived from {#scoped_children} after the rewrite is finished.
  def typed_children; end

  protected

  # Sets the attribute owner_type
  def owner_type=(_arg0); end

  # Sets the attribute parent
  def parent=(_arg0); end

  private

  # Get applicable children from {#scoped_children}
  def get_typed_children(obj_type); end

  def initialize_copy(other_node); end
end

GraphQL::InternalRepresentation::Node::DEFAULT_TYPED_CHILDREN = T.let(T.unsafe(nil), Proc)

# A specialized, reusable object for leaf nodes.
GraphQL::InternalRepresentation::Node::NO_TYPED_CHILDREN = T.let(T.unsafe(nil), Hash)

module GraphQL::InternalRepresentation::Print
  private

  def print(schema, query_string); end
  def print_node(node, indent: T.unsafe(nil)); end

  class << self
    def print(schema, query_string); end
    def print_node(node, indent: T.unsafe(nil)); end
  end
end

# While visiting an AST, build a normalized, flattened tree of {InternalRepresentation::Node}s.
#
# No unions or interfaces are present in this tree, only object types.
#
# Selections from the AST are attached to the object types they apply to.
#
# Inline fragments and fragment spreads are preserved in {InternalRepresentation::Node#ast_spreads},
# where they can be used to check for the presence of directives. This might not be sufficient
# for future directives, since the selections' grouping is lost.
#
# The rewritten query tree serves as the basis for the `FieldsWillMerge` validation.
module GraphQL::InternalRepresentation::Rewrite
  include ::GraphQL::Language

  def initialize(*_arg0); end

  def on_field(ast_node, ast_parent); end
  def on_fragment_definition(ast_node, parent); end
  def on_fragment_spread(ast_node, ast_parent); end
  def on_inline_fragment(node, parent); end
  def on_operation_definition(ast_node, parent); end
  def operations; end
  def push_root_node(ast_node, definitions); end
  def rewrite_document; end
  def skip?(ast_node); end
end

GraphQL::InternalRepresentation::Rewrite::NO_DIRECTIVES = T.let(T.unsafe(nil), Array)

# At a point in the AST, selections may apply to one or more types.
# {Scope} represents those types which selections may apply to.
#
# Scopes can be defined by:
#
# - A single concrete or abstract type
# - An array of types
# - `nil`
#
# The AST may be scoped to an array of types when two abstractly-typed
# fragments occur in inside one another.
class GraphQL::InternalRepresentation::Scope
  def initialize(query, type_defn); end

  # Call the block for each type in `self`.
  # This uses the simplest possible expression of `self`,
  # so if this scope is defined by an abstract type, it gets yielded.
  def each(&block); end

  # From a starting point of `self`, create a new scope by condition `other_type_defn`.
  def enter(other_type_defn); end

  private

  def concrete_types; end
end

GraphQL::InternalRepresentation::Scope::NO_TYPES = T.let(T.unsafe(nil), Array)

# Traverse a re-written query tree, calling handlers for each node
module GraphQL::InternalRepresentation::Visit
  private

  # Traverse a node in a rewritten query tree,
  # visiting the node itself and each of its typed children.
  def each_node(node, &block); end

  def visit_each_node(operations, handlers); end

  class << self
    # Traverse a node in a rewritten query tree,
    # visiting the node itself and each of its typed children.
    def each_node(node, &block); end

    def visit_each_node(operations, handlers); end
  end
end

module GraphQL::Introspection
  class << self
    def query(include_deprecated_args: T.unsafe(nil)); end
  end
end

class GraphQL::Introspection::BaseObject < ::GraphQL::Schema::Object
  class << self
    def field(*args, **kwargs, &block); end
  end
end

class GraphQL::Introspection::BaseObject::InvalidNullError < ::GraphQL::InvalidNullError; end
class GraphQL::Introspection::DirectiveLocationEnum < ::GraphQL::Schema::Enum; end
class GraphQL::Introspection::DirectiveLocationEnum::UnresolvedValueError < ::GraphQL::Schema::Enum::UnresolvedValueError; end

class GraphQL::Introspection::DirectiveType < ::GraphQL::Introspection::BaseObject
  def args(include_deprecated:); end
end

class GraphQL::Introspection::DirectiveType::InvalidNullError < ::GraphQL::InvalidNullError; end

class GraphQL::Introspection::DynamicFields < ::GraphQL::Introspection::BaseObject
  # `irep_node:` will be nil for the interpreter, since there is no such thing
  def __typename(irep_node: T.unsafe(nil)); end
end

class GraphQL::Introspection::DynamicFields::InvalidNullError < ::GraphQL::InvalidNullError; end

class GraphQL::Introspection::EntryPoints < ::GraphQL::Introspection::BaseObject
  def __schema; end
  def __type(name:); end
end

class GraphQL::Introspection::EntryPoints::InvalidNullError < ::GraphQL::InvalidNullError; end

class GraphQL::Introspection::EnumValueType < ::GraphQL::Introspection::BaseObject
  def is_deprecated; end
  def name; end
end

class GraphQL::Introspection::EnumValueType::InvalidNullError < ::GraphQL::InvalidNullError; end

class GraphQL::Introspection::FieldType < ::GraphQL::Introspection::BaseObject
  def args(include_deprecated:); end
  def is_deprecated; end
end

class GraphQL::Introspection::FieldType::InvalidNullError < ::GraphQL::InvalidNullError; end

# This query is used by graphql-client so don't add the includeDeprecated
# argument for inputFields since the server may not support it. Two stage
# introspection queries will be required to handle this in clients.
GraphQL::Introspection::INTROSPECTION_QUERY = T.let(T.unsafe(nil), String)

class GraphQL::Introspection::InputValueType < ::GraphQL::Introspection::BaseObject
  def default_value; end
  def is_deprecated; end

  private

  # Recursively serialize, taking care not to add quotes to enum values
  def serialize_default_value(value, type); end
end

class GraphQL::Introspection::InputValueType::InvalidNullError < ::GraphQL::InvalidNullError; end

class GraphQL::Introspection::SchemaType < ::GraphQL::Introspection::BaseObject
  def directives; end
  def mutation_type; end
  def query_type; end
  def schema_description; end
  def subscription_type; end
  def types; end

  private

  def permitted_root_type(op_type); end
end

class GraphQL::Introspection::SchemaType::InvalidNullError < ::GraphQL::InvalidNullError; end
class GraphQL::Introspection::TypeKindEnum < ::GraphQL::Schema::Enum; end
class GraphQL::Introspection::TypeKindEnum::UnresolvedValueError < ::GraphQL::Schema::Enum::UnresolvedValueError; end

class GraphQL::Introspection::TypeType < ::GraphQL::Introspection::BaseObject
  def enum_values(include_deprecated:); end
  def fields(include_deprecated:); end
  def input_fields(include_deprecated:); end
  def interfaces; end
  def kind; end
  def of_type; end
  def possible_types; end
  def specified_by_url; end
end

class GraphQL::Introspection::TypeType::InvalidNullError < ::GraphQL::InvalidNullError; end

class GraphQL::InvalidNameError < ::GraphQL::ExecutionError
  def initialize(name, valid_regex); end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute valid_regex.
  def valid_regex; end
end

# Raised automatically when a field's resolve function returns `nil`
# for a non-null field.
class GraphQL::InvalidNullError < ::GraphQL::RuntimeTypeError
  def initialize(parent_type, field, value); end

  def field; end
  def parent_error?; end
  def parent_type; end
  def to_h; end
  def value; end

  class << self
    def inspect; end

    # Returns the value of attribute parent_class.
    def parent_class; end

    # Sets the attribute parent_class
    def parent_class=(_arg0); end

    def subclass_for(parent_class); end
  end
end

module GraphQL::Language
  class << self
    def serialize(value); end
  end
end

module GraphQL::Language::BlockString
  class << self
    def break_line(line, length); end
    def print(str, indent: T.unsafe(nil)); end

    # Remove leading and trailing whitespace from a block string.
    # See "Block Strings" in https://github.com/facebook/graphql/blob/master/spec/Section%202%20--%20Language.md
    def trim_whitespace(str); end
  end
end

class GraphQL::Language::Cache
  def initialize(path); end

  def fetch(filename); end
end

GraphQL::Language::Cache::DIGEST = T.let(T.unsafe(nil), Digest::SHA256)

module GraphQL::Language::DefinitionSlice
  extend ::GraphQL::Language::DefinitionSlice

  def slice(document, name); end
end

class GraphQL::Language::DefinitionSlice::DependencyVisitor < ::GraphQL::Language::Visitor
  def initialize(doc, definitions, names); end

  def on_fragment_spread(node, parent); end

  class << self
    def find_definition_dependencies(definitions, name, names); end
  end
end

# {GraphQL::Language::DocumentFromSchemaDefinition} is used to convert a {GraphQL::Schema} object
# To a {GraphQL::Language::Document} AST node.
class GraphQL::Language::DocumentFromSchemaDefinition
  def initialize(schema, context: T.unsafe(nil), only: T.unsafe(nil), except: T.unsafe(nil), include_introspection_types: T.unsafe(nil), include_built_in_directives: T.unsafe(nil), include_built_in_scalars: T.unsafe(nil), always_include_schema: T.unsafe(nil)); end

  def build_argument_node(argument); end
  def build_argument_nodes(arguments); end
  def build_default_value(default_value, type); end
  def build_definition_nodes; end
  def build_directive_location_node(location); end
  def build_directive_location_nodes(locations); end
  def build_directive_node(directive); end
  def build_directive_nodes(directives); end
  def build_enum_type_node(enum_type); end
  def build_enum_value_node(enum_value); end
  def build_field_node(field); end
  def build_field_nodes(fields); end
  def build_input_object_node(input_object); end
  def build_interface_type_node(interface_type); end
  def build_object_type_node(object_type); end
  def build_scalar_type_node(scalar_type); end
  def build_schema_node; end
  def build_type_definition_node(type); end
  def build_type_definition_nodes(types); end
  def build_type_name_node(type); end
  def build_union_type_node(union_type); end
  def document; end

  private

  def always_include_schema; end
  def ast_directives(member); end
  def definition_directives(member); end
  def directives(member); end
  def include_built_in_directives; end
  def include_built_in_scalars; end
  def include_introspection_types; end
  def include_schema_node?; end
  def schema; end
  def schema_respects_root_name_conventions?(schema); end
  def warden; end
end

# Exposes {.generate}, which turns AST nodes back into query strings.
module GraphQL::Language::Generation
  extend ::GraphQL::Language::Generation

  # Turn an AST node back into a string.
  def generate(node, indent: T.unsafe(nil), printer: T.unsafe(nil)); end
end

module GraphQL::Language::Lexer
  class << self
    def emit(token_name, ts, te, meta, token_value = T.unsafe(nil)); end
    def emit_string(ts, te, meta, block:); end

    # Returns the value of attribute graphql_lexer_en_main.
    def graphql_lexer_en_main; end

    # Sets the attribute graphql_lexer_en_main
    def graphql_lexer_en_main=(_arg0); end

    # Returns the value of attribute graphql_lexer_en_str.
    def graphql_lexer_en_str; end

    # Sets the attribute graphql_lexer_en_str
    def graphql_lexer_en_str=(_arg0); end

    # Returns the value of attribute graphql_lexer_error.
    def graphql_lexer_error; end

    # Sets the attribute graphql_lexer_error
    def graphql_lexer_error=(_arg0); end

    # Returns the value of attribute graphql_lexer_first_final.
    def graphql_lexer_first_final; end

    # Sets the attribute graphql_lexer_first_final
    def graphql_lexer_first_final=(_arg0); end

    # Returns the value of attribute graphql_lexer_start.
    def graphql_lexer_start; end

    # Sets the attribute graphql_lexer_start
    def graphql_lexer_start=(_arg0); end

    def record_comment(ts, te, meta); end

    # Replace any escaped unicode or whitespace with the _actual_ characters
    # To avoid allocating more strings, this modifies the string passed into it
    def replace_escaped_characters_in_place(raw_string); end

    def run_lexer(query_string); end
    def tokenize(query_string); end

    private

    # Returns the value of attribute _graphql_lexer_char_class.
    def _graphql_lexer_char_class; end

    # Sets the attribute _graphql_lexer_char_class
    def _graphql_lexer_char_class=(_arg0); end

    # Returns the value of attribute _graphql_lexer_cond_actions.
    def _graphql_lexer_cond_actions; end

    # Sets the attribute _graphql_lexer_cond_actions
    def _graphql_lexer_cond_actions=(_arg0); end

    # Returns the value of attribute _graphql_lexer_cond_targs.
    def _graphql_lexer_cond_targs; end

    # Sets the attribute _graphql_lexer_cond_targs
    def _graphql_lexer_cond_targs=(_arg0); end

    # Returns the value of attribute _graphql_lexer_eof_trans.
    def _graphql_lexer_eof_trans; end

    # Sets the attribute _graphql_lexer_eof_trans
    def _graphql_lexer_eof_trans=(_arg0); end

    # Returns the value of attribute _graphql_lexer_from_state_actions.
    def _graphql_lexer_from_state_actions; end

    # Sets the attribute _graphql_lexer_from_state_actions
    def _graphql_lexer_from_state_actions=(_arg0); end

    # Returns the value of attribute _graphql_lexer_index_defaults.
    def _graphql_lexer_index_defaults; end

    # Sets the attribute _graphql_lexer_index_defaults
    def _graphql_lexer_index_defaults=(_arg0); end

    # Returns the value of attribute _graphql_lexer_index_offsets.
    def _graphql_lexer_index_offsets; end

    # Sets the attribute _graphql_lexer_index_offsets
    def _graphql_lexer_index_offsets=(_arg0); end

    # Returns the value of attribute _graphql_lexer_indicies.
    def _graphql_lexer_indicies; end

    # Sets the attribute _graphql_lexer_indicies
    def _graphql_lexer_indicies=(_arg0); end

    # Returns the value of attribute _graphql_lexer_nfa_offsets.
    def _graphql_lexer_nfa_offsets; end

    # Sets the attribute _graphql_lexer_nfa_offsets
    def _graphql_lexer_nfa_offsets=(_arg0); end

    # Returns the value of attribute _graphql_lexer_nfa_pop_trans.
    def _graphql_lexer_nfa_pop_trans; end

    # Sets the attribute _graphql_lexer_nfa_pop_trans
    def _graphql_lexer_nfa_pop_trans=(_arg0); end

    # Returns the value of attribute _graphql_lexer_nfa_push_actions.
    def _graphql_lexer_nfa_push_actions; end

    # Sets the attribute _graphql_lexer_nfa_push_actions
    def _graphql_lexer_nfa_push_actions=(_arg0); end

    # Returns the value of attribute _graphql_lexer_nfa_targs.
    def _graphql_lexer_nfa_targs; end

    # Sets the attribute _graphql_lexer_nfa_targs
    def _graphql_lexer_nfa_targs=(_arg0); end

    # Returns the value of attribute _graphql_lexer_to_state_actions.
    def _graphql_lexer_to_state_actions; end

    # Sets the attribute _graphql_lexer_to_state_actions
    def _graphql_lexer_to_state_actions=(_arg0); end

    # Returns the value of attribute _graphql_lexer_trans_cond_spaces.
    def _graphql_lexer_trans_cond_spaces; end

    # Sets the attribute _graphql_lexer_trans_cond_spaces
    def _graphql_lexer_trans_cond_spaces=(_arg0); end

    # Returns the value of attribute _graphql_lexer_trans_keys.
    def _graphql_lexer_trans_keys; end

    # Sets the attribute _graphql_lexer_trans_keys
    def _graphql_lexer_trans_keys=(_arg0); end
  end
end

GraphQL::Language::Lexer::ESCAPES = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::ESCAPES_REPLACE = T.let(T.unsafe(nil), Hash)
GraphQL::Language::Lexer::PACK_DIRECTIVE = T.let(T.unsafe(nil), String)
GraphQL::Language::Lexer::UTF_8 = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::UTF_8_ENCODING = T.let(T.unsafe(nil), String)
GraphQL::Language::Lexer::UTF_8_REPLACE = T.let(T.unsafe(nil), Proc)
GraphQL::Language::Lexer::VALID_STRING = T.let(T.unsafe(nil), Regexp)
module GraphQL::Language::Nodes; end

# {AbstractNode} is the base class for all nodes in a GraphQL AST.
#
# It provides some APIs for working with ASTs:
# - `children` returns all AST nodes attached to this one. Used for tree traversal.
# - `scalars` returns all scalar (Ruby) values attached to this one. Used for comparing nodes.
# - `to_query_string` turns an AST node into a GraphQL string
class GraphQL::Language::Nodes::AbstractNode
  # Initialize a node by extracting its position,
  # then calling the class's `initialize_node` method.
  def initialize(options = T.unsafe(nil)); end

  # Value equality
  def ==(other); end

  def children; end
  def children_method_name; end

  # Returns the value of attribute col.
  def col; end

  # TODO DRY with `replace_child`
  def delete_child(previous_child); end

  # Returns the value of attribute filename.
  def filename; end

  # Returns the value of attribute line.
  def line; end

  # This creates a copy of `self`, with `new_options` applied.
  def merge(new_options); end

  def position; end

  # Copy `self`, but modify the copy so that `previous_child` is replaced by `new_child`
  def replace_child(previous_child, new_child); end

  def scalars; end
  def to_query_string(printer: T.unsafe(nil)); end

  protected

  def merge!(new_options); end

  private

  # This might be unnecessary, but its easiest to add it here.
  def initialize_copy(other); end

  class << self
    # Add a default `#visit_method` and `#children_method_name` using the class name
    def inherited(child_class); end

    private

    # Name accessors which return lists of nodes,
    # along with the kind of node they return, if possible.
    # - Add a reader for these children
    # - Add a persistent update method to add a child
    # - Generate a `#children` method
    def children_methods(children_of_type); end

    def generate_initialize_node; end

    # These methods return a plain Ruby value, not another node
    # - Add reader methods
    # - Add a `#scalars` method
    def scalar_methods(*method_names); end
  end
end

module GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def initialize(options = T.unsafe(nil)); end

  # This AST node's {#line} returns the first line, which may be the description.
  def definition_line; end
end

GraphQL::Language::Nodes::AbstractNode::NO_CHILDREN = T.let(T.unsafe(nil), Array)

# A key-value pair for a field's inputs
class GraphQL::Language::Nodes::Argument < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def initialize_node(name: T.unsafe(nil), value: T.unsafe(nil)); end
  def name; end
  def scalars; end
  def value; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::Directive < ::GraphQL::Language::Nodes::AbstractNode
  def arguments; end
  def children; end
  def initialize_node(name: T.unsafe(nil), arguments: T.unsafe(nil)); end
  def merge_argument(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::DirectiveDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def arguments; end
  def children; end

  # Returns the value of attribute description.
  def description; end

  def initialize_node(name: T.unsafe(nil), repeatable: T.unsafe(nil), description: T.unsafe(nil), locations: T.unsafe(nil), arguments: T.unsafe(nil)); end
  def locations; end
  def merge_argument(node_opts); end
  def merge_location(node_opts); end
  def name; end
  def repeatable; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::DirectiveLocation < ::GraphQL::Language::Nodes::NameOnlyNode
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# This is the AST root for normal queries
class GraphQL::Language::Nodes::Document < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def definitions; end
  def initialize_node(definitions: T.unsafe(nil)); end
  def slice_definition(name); end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# An enum value. The string is available as {#name}.
class GraphQL::Language::Nodes::Enum < ::GraphQL::Language::Nodes::NameOnlyNode
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::EnumTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), values: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def merge_value(node_opts); end
  def name; end
  def scalars; end
  def values; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::EnumTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil), values: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def merge_value(node_opts); end
  def name; end
  def scalars; end
  def values; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::EnumValueDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A single selection in a GraphQL query.
class GraphQL::Language::Nodes::Field < ::GraphQL::Language::Nodes::AbstractNode
  def alias; end
  def arguments; end
  def children; end
  def directives; end
  def initialize_node(attributes); end
  def merge_argument(node_opts); end
  def merge_directive(node_opts); end
  def merge_selection(node_opts); end
  def name; end
  def scalars; end
  def selections; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

GraphQL::Language::Nodes::Field::NONE = T.let(T.unsafe(nil), Array)

class GraphQL::Language::Nodes::FieldDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def arguments; end
  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end

  # this is so that `children_method_name` of `InputValueDefinition` works properly
  # with `#replace_child`
  def fields; end

  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), arguments: T.unsafe(nil)); end
  def merge(new_options); end
  def merge_argument(node_opts); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def type; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A reusable fragment, defined at document-level.
class GraphQL::Language::Nodes::FragmentDefinition < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), directives: T.unsafe(nil), selections: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def merge_selection(node_opts); end
  def name; end
  def scalars; end
  def selections; end
  def type; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# Application of a named fragment in a selection
class GraphQL::Language::Nodes::FragmentSpread < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# An unnamed fragment, defined directly in the query with `... {  }`
class GraphQL::Language::Nodes::InlineFragment < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(type: T.unsafe(nil), selections: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def merge_selection(node_opts); end
  def scalars; end
  def selections; end
  def type; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A collection of key-value inputs which may be a field argument
class GraphQL::Language::Nodes::InputObject < ::GraphQL::Language::Nodes::AbstractNode
  def arguments; end
  def children; end
  def initialize_node(arguments: T.unsafe(nil)); end
  def merge_argument(node_opts); end
  def to_h(options = T.unsafe(nil)); end
  def visit_method; end

  private

  def serialize_value_for_hash(value); end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::InputObjectTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def fields; end
  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::InputObjectTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def fields; end
  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::InputValueDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end
  def default_value; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), default_value: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def type; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::InterfaceTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def fields; end
  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), interfaces: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end
  def interfaces; end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def merge_interface(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::InterfaceTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def fields; end
  def initialize_node(name: T.unsafe(nil), interfaces: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end
  def interfaces; end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def merge_interface(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A list type definition, denoted with `[...]` (used for variable type definitions)
class GraphQL::Language::Nodes::ListType < ::GraphQL::Language::Nodes::WrapperType
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# Base class for nodes whose only value is a name (no child nodes or other scalars)
class GraphQL::Language::Nodes::NameOnlyNode < ::GraphQL::Language::Nodes::AbstractNode
  def initialize_node(name: T.unsafe(nil)); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A non-null type definition, denoted with `...!` (used for variable type definitions)
class GraphQL::Language::Nodes::NonNullType < ::GraphQL::Language::Nodes::WrapperType
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A null value literal.
class GraphQL::Language::Nodes::NullValue < ::GraphQL::Language::Nodes::NameOnlyNode
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::ObjectTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def fields; end
  def initialize_node(name: T.unsafe(nil), interfaces: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end
  def interfaces; end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::ObjectTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def fields; end
  def initialize_node(name: T.unsafe(nil), interfaces: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end
  def interfaces; end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A query, mutation or subscription.
# May be anonymous or named.
# May be explicitly typed (eg `mutation { ... }`) or implicitly a query (eg `{ ... }`).
class GraphQL::Language::Nodes::OperationDefinition < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(operation_type: T.unsafe(nil), name: T.unsafe(nil), variables: T.unsafe(nil), selections: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def merge_selection(node_opts); end
  def merge_variable(node_opts); end
  def name; end
  def operation_type; end
  def scalars; end
  def selections; end
  def variables; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::ScalarTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::ScalarTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::SchemaDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end
  def directives; end
  def initialize_node(query: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def mutation; end
  def query; end
  def scalars; end
  def subscription; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::SchemaExtension < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(query: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def mutation; end
  def query; end
  def scalars; end
  def subscription; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A type name, used for variable definitions
class GraphQL::Language::Nodes::TypeName < ::GraphQL::Language::Nodes::NameOnlyNode
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::UnionTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def initialize_node(name: T.unsafe(nil), types: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end

  # Returns the value of attribute types.
  def types; end

  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::UnionTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(name: T.unsafe(nil), types: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end

  # Returns the value of attribute types.
  def types; end

  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# An operation-level query variable
class GraphQL::Language::Nodes::VariableDefinition < ::GraphQL::Language::Nodes::AbstractNode
  def default_value; end
  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), default_value: T.unsafe(nil)); end
  def name; end
  def scalars; end
  def type; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# Usage of a variable in a query. Name does _not_ include `$`.
class GraphQL::Language::Nodes::VariableIdentifier < ::GraphQL::Language::Nodes::NameOnlyNode
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# Base class for non-null type names and list type names
class GraphQL::Language::Nodes::WrapperType < ::GraphQL::Language::Nodes::AbstractNode
  def initialize_node(of_type: T.unsafe(nil)); end
  def of_type; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Parser < ::Racc::Parser
  def initialize(query_string, filename:, tracer: T.unsafe(nil)); end

  def _reduce_10(val, _values, result); end
  def _reduce_100(val, _values, result); end
  def _reduce_102(val, _values, result); end
  def _reduce_103(val, _values, result); end
  def _reduce_104(val, _values, result); end
  def _reduce_105(val, _values, result); end
  def _reduce_106(val, _values, result); end
  def _reduce_107(val, _values, result); end
  def _reduce_108(val, _values, result); end
  def _reduce_109(val, _values, result); end
  def _reduce_11(val, _values, result); end
  def _reduce_114(val, _values, result); end
  def _reduce_116(val, _values, result); end
  def _reduce_117(val, _values, result); end
  def _reduce_12(val, _values, result); end
  def _reduce_126(val, _values, result); end
  def _reduce_127(val, _values, result); end
  def _reduce_134(val, _values, result); end
  def _reduce_135(val, _values, result); end
  def _reduce_136(val, _values, result); end
  def _reduce_137(val, _values, result); end
  def _reduce_138(val, _values, result); end
  def _reduce_139(val, _values, result); end
  def _reduce_140(val, _values, result); end
  def _reduce_141(val, _values, result); end
  def _reduce_142(val, _values, result); end
  def _reduce_143(val, _values, result); end
  def _reduce_144(val, _values, result); end
  def _reduce_145(val, _values, result); end
  def _reduce_146(val, _values, result); end
  def _reduce_147(val, _values, result); end
  def _reduce_151(val, _values, result); end
  def _reduce_152(val, _values, result); end
  def _reduce_153(val, _values, result); end
  def _reduce_155(val, _values, result); end
  def _reduce_156(val, _values, result); end
  def _reduce_157(val, _values, result); end
  def _reduce_158(val, _values, result); end
  def _reduce_159(val, _values, result); end
  def _reduce_16(val, _values, result); end
  def _reduce_160(val, _values, result); end
  def _reduce_161(val, _values, result); end
  def _reduce_162(val, _values, result); end
  def _reduce_163(val, _values, result); end
  def _reduce_164(val, _values, result); end
  def _reduce_165(val, _values, result); end
  def _reduce_166(val, _values, result); end
  def _reduce_167(val, _values, result); end
  def _reduce_168(val, _values, result); end
  def _reduce_169(val, _values, result); end
  def _reduce_170(val, _values, result); end
  def _reduce_171(val, _values, result); end
  def _reduce_172(val, _values, result); end
  def _reduce_173(val, _values, result); end
  def _reduce_174(val, _values, result); end
  def _reduce_175(val, _values, result); end
  def _reduce_176(val, _values, result); end
  def _reduce_177(val, _values, result); end
  def _reduce_18(val, _values, result); end
  def _reduce_180(val, _values, result); end
  def _reduce_181(val, _values, result); end
  def _reduce_19(val, _values, result); end
  def _reduce_2(val, _values, result); end
  def _reduce_20(val, _values, result); end
  def _reduce_21(val, _values, result); end
  def _reduce_22(val, _values, result); end
  def _reduce_23(val, _values, result); end
  def _reduce_24(val, _values, result); end
  def _reduce_25(val, _values, result); end
  def _reduce_26(val, _values, result); end
  def _reduce_27(val, _values, result); end
  def _reduce_28(val, _values, result); end
  def _reduce_29(val, _values, result); end
  def _reduce_3(val, _values, result); end
  def _reduce_30(val, _values, result); end
  def _reduce_31(val, _values, result); end
  def _reduce_32(val, _values, result); end
  def _reduce_33(val, _values, result); end
  def _reduce_37(val, _values, result); end
  def _reduce_38(val, _values, result); end
  def _reduce_4(val, _values, result); end
  def _reduce_63(val, _values, result); end
  def _reduce_64(val, _values, result); end
  def _reduce_65(val, _values, result); end
  def _reduce_66(val, _values, result); end
  def _reduce_67(val, _values, result); end
  def _reduce_68(val, _values, result); end
  def _reduce_69(val, _values, result); end
  def _reduce_70(val, _values, result); end
  def _reduce_71(val, _values, result); end
  def _reduce_72(val, _values, result); end
  def _reduce_73(val, _values, result); end
  def _reduce_74(val, _values, result); end
  def _reduce_75(val, _values, result); end
  def _reduce_83(val, _values, result); end
  def _reduce_84(val, _values, result); end
  def _reduce_85(val, _values, result); end
  def _reduce_86(val, _values, result); end
  def _reduce_87(val, _values, result); end
  def _reduce_88(val, _values, result); end
  def _reduce_89(val, _values, result); end
  def _reduce_90(val, _values, result); end
  def _reduce_91(val, _values, result); end
  def _reduce_92(val, _values, result); end
  def _reduce_93(val, _values, result); end
  def _reduce_94(val, _values, result); end
  def _reduce_95(val, _values, result); end
  def _reduce_96(val, _values, result); end
  def _reduce_97(val, _values, result); end
  def _reduce_98(val, _values, result); end
  def _reduce_99(val, _values, result); end
  def _reduce_none(val, _values, result); end
  def parse_document; end

  private

  def get_description(token); end
  def make_node(node_name, assigns); end
  def next_token; end
  def on_error(parser_token_id, lexer_token, vstack); end

  class << self
    def cache; end
    def cache=(_arg0); end
    def parse(query_string, filename: T.unsafe(nil), tracer: T.unsafe(nil)); end
    def parse_file(filename, tracer: T.unsafe(nil)); end
  end
end

GraphQL::Language::Parser::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
GraphQL::Language::Parser::Racc_arg = T.let(T.unsafe(nil), Array)
GraphQL::Language::Parser::Racc_token_to_s_table = T.let(T.unsafe(nil), Array)

class GraphQL::Language::Printer
  # Turn an arbitrary AST node back into a string.
  def print(node, indent: T.unsafe(nil)); end

  protected

  def print_argument(argument); end
  def print_arguments(arguments, indent: T.unsafe(nil)); end
  def print_description(node, indent: T.unsafe(nil), first_in_block: T.unsafe(nil)); end
  def print_directive(directive); end
  def print_directive_definition(directive); end
  def print_directives(directives); end
  def print_document(document); end
  def print_enum(enum); end
  def print_enum_type_definition(enum_type); end
  def print_enum_value_definition(enum_value); end
  def print_field(field, indent: T.unsafe(nil)); end
  def print_field_definition(field); end
  def print_field_definitions(fields); end
  def print_fragment_definition(fragment_def, indent: T.unsafe(nil)); end
  def print_fragment_spread(fragment_spread, indent: T.unsafe(nil)); end
  def print_implements(type); end
  def print_inline_fragment(inline_fragment, indent: T.unsafe(nil)); end
  def print_input_object(input_object); end
  def print_input_object_type_definition(input_object_type); end
  def print_input_value_definition(input_value); end
  def print_interface_type_definition(interface_type); end
  def print_list_type(list_type); end
  def print_node(node, indent: T.unsafe(nil)); end
  def print_non_null_type(non_null_type); end
  def print_null_value; end
  def print_object_type_definition(object_type); end
  def print_operation_definition(operation_definition, indent: T.unsafe(nil)); end
  def print_scalar_type_definition(scalar_type); end
  def print_schema_definition(schema); end
  def print_selections(selections, indent: T.unsafe(nil)); end
  def print_type_name(type_name); end
  def print_union_type_definition(union_type); end
  def print_variable_definition(variable_definition); end
  def print_variable_identifier(variable_identifier); end

  private

  # Returns the value of attribute node.
  def node; end
end

# A custom printer used to print sanitized queries. It inlines provided variables
# within the query for facilitate logging and analysis of queries.
#
# The printer returns `nil` if the query is invalid.
#
# Since the GraphQL Ruby AST for a GraphQL query doesnt contain any reference
# on the type of fields or arguments, we have to track the current object, field
# and input type while printing the query.
class GraphQL::Language::SanitizedPrinter < ::GraphQL::Language::Printer
  def initialize(query, inline_variables: T.unsafe(nil)); end

  def coerce_argument_value_to_list?(type, value); end
  def print_argument(argument); end
  def print_directive(directive); end
  def print_field(field, indent: T.unsafe(nil)); end
  def print_fragment_definition(fragment_def, indent: T.unsafe(nil)); end
  def print_inline_fragment(inline_fragment, indent: T.unsafe(nil)); end
  def print_node(node, indent: T.unsafe(nil)); end

  # Print the operation definition but do not include the variable
  # definitions since we will inline them within the query
  def print_operation_definition(operation_definition, indent: T.unsafe(nil)); end

  def print_variable_identifier(variable_id); end

  # Indicates whether or not to redact non-null values for the given argument. Defaults to redacting all strings
  # arguments but this can be customized by subclasses.
  def redact_argument_value?(argument, value); end

  # Returns the value to use for redacted versions of the given argument. Defaults to the
  # string "<REDACTED>".
  def redacted_argument_value(argument); end

  def sanitized_query_string; end

  private

  # Returns the value of attribute query.
  def query; end

  def value_to_ast(value, type); end
end

GraphQL::Language::SanitizedPrinter::REDACTED = T.let(T.unsafe(nil), String)

# Emitted by the lexer and passed to the parser.
# Contains type, value and position data.
class GraphQL::Language::Token
  def initialize(name, value, line, col, prev_token); end

  # Returns the value of attribute col.
  def col; end

  def inspect; end

  # Returns the value of attribute line.
  def line; end

  def line_and_column; end
  def name; end

  # Returns the value of attribute prev_token.
  def prev_token; end

  def to_f; end
  def to_i; end
  def to_s; end
  def value; end
end

# Depth-first traversal through the tree, calling hooks at each stop.
class GraphQL::Language::Visitor
  def initialize(document); end

  # Get a {NodeVisitor} for `node_class`
  def [](node_class); end

  # The default implementation for visiting an AST node.
  # It doesn't _do_ anything, but it continues to visiting the node's children.
  # To customize this hook, override one of its make_visit_methodes (or the base method?)
  # in your subclasses.
  #
  # For compatibility, it calls hook procs, too.
  def on_abstract_node(node, parent); end

  def on_argument(node, parent); end
  def on_directive(node, parent); end
  def on_directive_definition(node, parent); end
  def on_directive_location(node, parent); end
  def on_document(node, parent); end
  def on_enum(node, parent); end
  def on_enum_type_definition(node, parent); end
  def on_enum_type_extension(node, parent); end
  def on_enum_value_definition(node, parent); end
  def on_field(node, parent); end
  def on_field_definition(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end
  def on_input_object(node, parent); end
  def on_input_object_type_definition(node, parent); end
  def on_input_object_type_extension(node, parent); end
  def on_input_value_definition(node, parent); end
  def on_interface_type_definition(node, parent); end
  def on_interface_type_extension(node, parent); end
  def on_list_type(node, parent); end
  def on_non_null_type(node, parent); end
  def on_null_value(node, parent); end
  def on_object_type_definition(node, parent); end
  def on_object_type_extension(node, parent); end
  def on_operation_definition(node, parent); end
  def on_scalar_type_definition(node, parent); end
  def on_scalar_type_extension(node, parent); end
  def on_schema_definition(node, parent); end
  def on_schema_extension(node, parent); end
  def on_type_name(node, parent); end
  def on_union_type_definition(node, parent); end
  def on_union_type_extension(node, parent); end
  def on_variable_definition(node, parent); end
  def on_variable_identifier(node, parent); end
  def result; end

  # Visit `document` and all children, applying hooks as you go
  def visit; end

  # Call the user-defined handler for `node`.
  def visit_node(node, parent); end

  private

  def begin_visit(node, parent); end

  # Should global `leave` visitors come first or last?
  def end_visit(node, parent); end

  # Run the hooks for `node`, and if the hooks return a copy of `node`,
  # copy `parent` so that it contains the copy of that node as a child,
  # then return the copies
  # If a non-array value is returned, consuming functions should ignore
  # said value
  def on_node_with_modifications(node, parent); end

  class << self
    # If one of the visitors returns SKIP, stop visiting this node
    def apply_hooks(hooks, node, parent); end

    # We don't use `alias` here because it breaks `super`
    def make_visit_method(node_method); end
  end
end

# When this is returned from a visitor method,
# Then the `node` passed into the method is removed from `parent`'s children.
GraphQL::Language::Visitor::DELETE_NODE = T.let(T.unsafe(nil), GraphQL::Language::Visitor::DeleteNode)

class GraphQL::Language::Visitor::DeleteNode; end

# Collect `enter` and `leave` hooks for classes in {GraphQL::Language::Nodes}
#
# Access {NodeVisitor}s via {GraphQL::Language::Visitor#[]}
class GraphQL::Language::Visitor::NodeVisitor
  def initialize; end

  # Shorthand to add a hook to the {#enter} array
  def <<(hook); end

  def enter; end
  def leave; end
end

# If any hook returns this value, the {Visitor} stops visiting this
# node right away
GraphQL::Language::Visitor::SKIP = T.let(T.unsafe(nil), Symbol)

# A list type modifies another type.
#
# List types can be created with the type helper (`types[InnerType]`)
# or {BaseType#to_list_type} (`InnerType.to_list_type`)
#
# For return types, it says that the returned value will be a list of the modified.
#
# For input types, it says that the incoming value will be a list of the modified type.
#
# Given a list type, you can always get the underlying type with {#unwrap}.
class GraphQL::ListType < ::GraphQL::BaseType
  include ::GraphQL::BaseType::ModifiesAnotherType

  def initialize(of_type:); end

  def coerce_result(value, ctx = T.unsafe(nil)); end
  def inspect; end
  def kind; end
  def list?; end

  # Returns the value of attribute of_type.
  def of_type; end

  def to_s; end
  def to_type_signature; end

  private

  def coerce_non_null_input(value, ctx); end
  def ensure_array(value); end
  def validate_non_null_input(value, ctx); end
end

# Raised when a argument is configured with `loads:` and the client provides an `ID`,
# but no object is loaded for that ID.
class GraphQL::LoadApplicationObjectFailedError < ::GraphQL::ExecutionError
  def initialize(argument:, id:, object:); end

  def argument; end
  def id; end
  def object; end
end

class GraphQL::NameValidator
  class << self
    def validate!(name); end
  end
end

GraphQL::NameValidator::VALID_NAME_REGEX = T.let(T.unsafe(nil), Regexp)

# A non-null type modifies another type.
#
# Non-null types can be created with `!` (`InnerType!`)
# or {BaseType#to_non_null_type} (`InnerType.to_non_null_type`)
#
# For return types, it says that the returned value will _always_ be present.
#
# (If the application fails to return a value, {InvalidNullError} will be passed to {Schema#type_error}.)
#
# For input types, it says that the incoming value _must_ be provided by the query.
#
# (If a value isn't provided, {Query::VariableValidationError} will be raised).
#
# Given a non-null type, you can always get the underlying type with {#unwrap}.
class GraphQL::NonNullType < ::GraphQL::BaseType
  include ::GraphQL::BaseType::ModifiesAnotherType
  extend ::Forwardable

  def initialize(of_type:); end

  def coerce_input(*args, &block); end
  def coerce_result(*args, &block); end
  def inspect; end
  def kind; end
  def list?(*args, &block); end
  def non_null?; end

  # Returns the value of attribute of_type.
  def of_type; end

  def to_s; end
  def to_type_signature; end
  def valid_input?(value, ctx); end
  def validate_input(value, ctx); end
end

class GraphQL::ObjectType < ::GraphQL::BaseType
  extend ::GraphQL::Define::InstanceDefinable::DeprecatedDefine

  def initialize; end

  # These fields don't have instrumenation applied
  def all_fields; end

  def fields; end
  def fields=(_arg0); end

  # This fields doesnt have instrumenation applied
  def get_field(field_name); end

  # Declare that this object implements this interface.
  # This declaration will be validated when the schema is defined.
  def implements(interfaces, inherit: T.unsafe(nil), **options); end

  def interfaces(ctx = T.unsafe(nil)); end

  # This method declares interfaces for this type AND inherits any field definitions
  def interfaces=(new_interfaces); end

  def kind; end
  def mutation; end
  def mutation=(_arg0); end
  def relay_node_type; end
  def relay_node_type=(_arg0); end
  def resolve_type_proc; end
  def structural_interface_type_memberships=(_arg0); end

  protected

  def inherited_interface_type_memberships; end
  def structural_interface_type_memberships; end

  private

  def initialize_copy(other); end
  def interface_fields; end
  def normalize_interfaces(ifaces); end
end

module GraphQL::Pagination; end

# Customizes `RelationConnection` to work with `ActiveRecord::Relation`s.
class GraphQL::Pagination::ActiveRecordRelationConnection < ::GraphQL::Pagination::RelationConnection
  private

  def already_loaded?(relation); end
  def null_relation(relation); end
  def relation_count(relation); end
  def relation_larger_than(relation, initial_offset, size); end
  def relation_limit(relation); end
  def relation_offset(relation); end
  def set_limit(nodes, limit); end
  def set_offset(nodes, offset); end
end

class GraphQL::Pagination::ArrayConnection < ::GraphQL::Pagination::Connection
  def cursor_for(item); end
  def has_next_page; end
  def has_previous_page; end
  def nodes; end

  private

  def index_from_cursor(cursor); end

  # Populate all the pagination info _once_,
  # It doesn't do anything on subsequent calls.
  def load_nodes; end
end

# A Connection wraps a list of items and provides cursor-based pagination over it.
#
# Connections were introduced by Facebook's `Relay` front-end framework, but
# proved to be generally useful for GraphQL APIs. When in doubt, use connections
# to serve lists (like Arrays, ActiveRecord::Relations) via GraphQL.
#
# Unlike the previous connection implementation, these default to bidirectional pagination.
#
# Pagination arguments and context may be provided at initialization or assigned later (see {Schema::Field::ConnectionExtension}).
class GraphQL::Pagination::Connection
  def initialize(items, parent: T.unsafe(nil), field: T.unsafe(nil), context: T.unsafe(nil), first: T.unsafe(nil), after: T.unsafe(nil), max_page_size: T.unsafe(nil), last: T.unsafe(nil), before: T.unsafe(nil), edge_class: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def after; end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def after_value; end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def after_value=(_arg0); end

  def arguments; end
  def arguments=(_arg0); end
  def before; end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def before_value; end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def before_value=(_arg0); end

  def context; end
  def context=(_arg0); end

  # Return a cursor for this item.
  def cursor_for(item); end

  def edge_class; end
  def edge_class=(_arg0); end

  # A dynamic alias for compatibility with {Relay::BaseConnection}.
  def edge_nodes; end

  def edges; end
  def end_cursor; end
  def field; end
  def field=(_arg0); end
  def first; end

  # Sets the attribute first
  def first=(_arg0); end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def first_value; end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def first_value=(_arg0); end

  def has_max_page_size_override?; end
  def has_next_page; end
  def has_previous_page; end
  def items; end
  def last; end

  # Sets the attribute last
  def last=(_arg0); end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def last_value; end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def last_value=(_arg0); end

  def max_page_size; end
  def max_page_size=(new_value); end
  def nodes; end

  # The connection object itself implements `PageInfo` fields
  def page_info; end

  def parent; end
  def parent=(_arg0); end

  # This is called by `Relay::RangeAdd` -- it can be overridden
  # when `item` needs some modifications based on this connection's state.
  def range_add_edge(item); end

  def start_cursor; end

  private

  def decode(cursor); end
  def encode(cursor); end
  def limit_pagination_argument(argument, max_page_size); end
end

# A wrapper around paginated items. It includes a {cursor} for pagination
# and could be extended with custom relationship-level data.
class GraphQL::Pagination::Connection::Edge
  def initialize(node, connection); end

  def cursor; end

  # Returns the value of attribute node.
  def node; end

  def parent; end
end

class GraphQL::Pagination::Connection::PaginationImplementationMissingError < ::GraphQL::Error; end

# A schema-level connection wrapper manager.
#
# Attach as a plugin.
class GraphQL::Pagination::Connections
  def initialize(schema:); end

  def add(nodes_class, implementation); end
  def all_wrappers; end
  def delete(nodes_class); end

  # use an override if there is one
  def edge_class_for_field(field); end

  # Used by the runtime to wrap values in connection wrappers.
  def wrap(field, parent, items, arguments, context); end

  def wrapper_for(items, wrappers: T.unsafe(nil)); end

  protected

  # Returns the value of attribute wrappers.
  def wrappers; end

  private

  def add_default; end

  class << self
    def use(schema_defn); end
  end
end

class GraphQL::Pagination::Connections::ImplementationMissingError < ::GraphQL::Error; end

class GraphQL::Pagination::MongoidRelationConnection < ::GraphQL::Pagination::RelationConnection
  def null_relation(relation); end
  def relation_count(relation); end
  def relation_limit(relation); end
  def relation_offset(relation); end
end

# A generic class for working with database query objects.
class GraphQL::Pagination::RelationConnection < ::GraphQL::Pagination::Connection
  def cursor_for(item); end
  def has_next_page; end
  def has_previous_page; end
  def nodes; end

  private

  def after_offset; end
  def before_offset; end
  def calculate_sliced_nodes_parameters; end

  # Apply `first` and `last` to `sliced_nodes`,
  # returning a new relation
  def limited_nodes; end

  # Load nodes after applying first/last/before/after,
  # returns an array of nodes
  def load_nodes; end

  def null_relation(relation); end
  def offset_from_cursor(cursor); end
  def relation_count(relation); end
  def relation_larger_than(relation, _initial_offset, size); end
  def relation_limit(relation); end
  def relation_offset(relation); end

  # Abstract this operation so we can always ignore inputs less than zero.
  # (Sequel doesn't like it, understandably.)
  def set_limit(relation, limit_value); end

  # Abstract this operation so we can always ignore inputs less than zero.
  # (Sequel doesn't like it, understandably.)
  def set_offset(relation, offset_value); end

  # Apply `before` and `after` to the underlying `items`,
  # returning a new relation.
  def sliced_nodes; end
end

# Customizes `RelationConnection` to work with `Sequel::Dataset`s.
class GraphQL::Pagination::SequelDatasetConnection < ::GraphQL::Pagination::RelationConnection
  private

  def null_relation(relation); end
  def relation_count(relation); end
  def relation_limit(relation); end
  def relation_offset(relation); end
end

class GraphQL::ParseError < ::GraphQL::Error
  def initialize(message, line, col, query, filename: T.unsafe(nil)); end

  # Returns the value of attribute col.
  def col; end

  # Returns the value of attribute line.
  def line; end

  # Returns the value of attribute query.
  def query; end

  def to_h; end
end

# A combination of query string and {Schema} instance which can be reduced to a {#result}.
class GraphQL::Query
  include ::GraphQL::PersistedQueries::CompiledQueries::QueryPatch
  include ::GraphQL::Tracing::Traceable
  extend ::Forwardable

  # Prepare query `query_string` on `schema`
  def initialize(schema, query_string = T.unsafe(nil), query: T.unsafe(nil), document: T.unsafe(nil), context: T.unsafe(nil), variables: T.unsafe(nil), validate: T.unsafe(nil), subscription_topic: T.unsafe(nil), operation_name: T.unsafe(nil), root_value: T.unsafe(nil), max_depth: T.unsafe(nil), max_complexity: T.unsafe(nil), except: T.unsafe(nil), only: T.unsafe(nil), warden: T.unsafe(nil)); end

  # Returns the value of attribute analysis_errors.
  def analysis_errors; end

  # Sets the attribute analysis_errors
  def analysis_errors=(_arg0); end

  def analyzers(*args, &block); end
  def arguments_cache; end

  # Node-level cache for calculating arguments. Used during execution and query analysis.
  def arguments_for(ast_node, definition, parent_object: T.unsafe(nil)); end

  def ast_analyzers(*args, &block); end

  # Returns the value of attribute context.
  def context; end

  def document; end
  def executed?; end

  # This contains a few components:
  #
  # - The selected operation name (or `anonymous`)
  # - The fingerprint of the query string
  # - The number of given variables (for readability)
  # - The fingerprint of the given variables
  #
  # This fingerprint can be used to track runs of the same operation-variables combination over time.
  def fingerprint; end

  def fragments; end
  def get_field(*args, &block); end
  def get_type(*args, &block); end
  def inspect; end
  def internal_representation(*args, &block); end
  def interpreter?; end
  def irep_selection; end

  # A lookahead for the root selections of this query
  def lookahead; end

  def max_complexity(*args, &block); end
  def max_depth(*args, &block); end
  def merge_filters(only: T.unsafe(nil), except: T.unsafe(nil)); end

  # Returns the value of attribute multiplex.
  def multiplex; end

  # Sets the attribute multiplex
  def multiplex=(_arg0); end

  def mutation?; end
  def operation_fingerprint; end
  def operation_name; end
  def operation_name=(_arg0); end
  def operations; end
  def possible_types(*args, &block); end

  # Returns the value of attribute provided_variables.
  def provided_variables; end

  def query?; end

  # If a document was provided to `GraphQL::Schema#execute` instead of the raw query string, we will need to get it from the document
  def query_string; end

  # Sets the attribute query_string
  def query_string=(_arg0); end

  def resolve_type(abstract_type, value = T.unsafe(nil)); end

  # Get the result for this query, executing it once
  def result; end

  def result_values; end
  def result_values=(result_hash); end
  def root_type_for_operation(*args, &block); end

  # The value for root types
  def root_value; end

  # The value for root types
  def root_value=(_arg0); end

  # A version of the given query string, with:
  # - Variables inlined to the query
  # - Strings replaced with `<REDACTED>`
  def sanitized_query_string(inline_variables: T.unsafe(nil)); end

  # Returns the value of attribute schema.
  def schema; end

  # This is the operation to run for this query.
  # If more than one operation is present, it must be named at runtime.
  def selected_operation; end

  def selected_operation_name; end
  def static_errors; end
  def subscription?; end
  def subscription_topic; end
  def subscription_update?; end

  # Returns the value of attribute tracers.
  def tracers; end

  def valid?; end
  def validate; end
  def validate=(_arg0); end
  def validation_errors(*args, &block); end
  def validation_pipeline; end

  # Determine the values for variables of this query, using default values
  # if a value isn't provided at runtime.
  #
  # If some variable is invalid, errors are added to {#validation_errors}.
  def variables; end

  def variables_fingerprint; end
  def warden; end
  def with_error_handling; end

  private

  def find_operation(operations, operation_name); end

  # Since the query string is processed at the last possible moment,
  # any internal values which depend on it should be accessed within this wrapper.
  def with_prepared_ast; end
end

# Read-only access to values, normalizing all keys to strings
#
# {Arguments} recursively wraps the input in {Arguments} instances.
class GraphQL::Query::Arguments
  include ::GraphQL::Dig
  extend ::Forwardable

  def initialize(values, context:, defaults_used:); end

  def [](key); end
  def any?(*args, &block); end

  # Returns the value of attribute argument_values.
  def argument_values; end

  def default_used?(key); end
  def each(*args, &block); end

  # Access each key, value and type for the arguments in this set.
  def each_value; end

  def key?(key); end
  def keys(*args, &block); end
  def prepare; end

  # Get the hash of all values, with stringified keys
  def to_h; end

  # Convert this instance into valid Ruby keyword arguments
  def to_hash; end

  # Convert this instance into valid Ruby keyword arguments
  def to_kwargs; end

  def values(*args, &block); end

  private

  def unwrap_value(value); end
  def wrap_value(value, arg_defn_type, context); end

  class << self
    # Returns the value of attribute argument_definitions.
    def argument_definitions; end

    # Sets the attribute argument_definitions
    def argument_definitions=(_arg0); end

    # Returns the value of attribute argument_owner.
    def argument_owner; end

    # Sets the attribute argument_owner
    def argument_owner=(_arg0); end

    def construct_arguments_class(argument_owner); end
  end
end

class GraphQL::Query::Arguments::ArgumentValue
  def initialize(key, value, definition, default_used); end

  # Sets the attribute default_used
  def default_used=(_arg0); end

  def default_used?; end

  # Returns the value of attribute definition.
  def definition; end

  # Returns the value of attribute key.
  def key; end

  # Returns the value of attribute value.
  def value; end
end

GraphQL::Query::Arguments::NO_ARGS = T.let(T.unsafe(nil), GraphQL::Query::Arguments::NoArguments)
GraphQL::Query::Arguments::NULL_ARGUMENT_VALUE = T.let(T.unsafe(nil), GraphQL::Query::Arguments::ArgumentValue)
class GraphQL::Query::Arguments::NoArguments < ::GraphQL::Query::Arguments; end

module GraphQL::Query::ArgumentsCache
  class << self
    def build(query); end
  end
end

# Expose some query-specific info to field resolve functions.
# It delegates `[]` to the hash that's passed to `GraphQL::Query#initialize`.
class GraphQL::Query::Context
  include ::GraphQL::Query::Context::SharedMethods
  extend ::Forwardable

  # Make a new context which delegates key lookup to `values`
  def initialize(query:, values:, object:, schema: T.unsafe(nil)); end

  # Lookup `key` from the hash passed to {Schema#execute} as `context:`
  def [](key); end

  # Reassign `key` to the hash passed to {Schema#execute} as `context:`
  def []=(key, value); end

  def ast_node; end
  def dataloader; end
  def delete(key); end
  def dig(key, *other_keys); end
  def errors; end

  # Returns the value of attribute execution_strategy.
  def execution_strategy; end

  def execution_strategy=(new_strategy); end
  def fetch(key, default = T.unsafe(nil)); end
  def inspect; end
  def interpreter=(_arg0); end
  def interpreter?(*args, &block); end
  def irep_node; end
  def key?(key); end

  # Get an isolated hash for `ns`. Doesn't affect user-provided storage.
  def namespace(ns); end

  def namespace?(ns); end
  def path; end
  def query; end
  def received_null_child; end
  def response_extensions; end
  def schema; end
  def scoped_context; end
  def scoped_context=(_arg0); end
  def scoped_merge!(hash); end
  def scoped_set!(key, value); end

  # Returns the value of attribute execution_strategy.
  # `strategy` is required by GraphQL::Batch
  def strategy; end

  def to_h; end
  def to_hash; end
  def trace(*args, &block); end
  def value=(_arg0); end
  def warden; end
  def warden=(_arg0); end
end

class GraphQL::Query::Context::ExecutionErrors
  def initialize(ctx); end

  def >>(err_or_msg); end
  def add(err_or_msg); end
  def push(err_or_msg); end
end

class GraphQL::Query::Context::FieldResolutionContext
  include ::GraphQL::Query::Context::SharedMethods
  include ::GraphQL::Tracing::Traceable
  extend ::Forwardable

  def initialize(context, key, irep_node, parent, object); end

  def [](*args, &block); end
  def []=(*args, &block); end

  # Add error to current field resolution.
  def add_error(error); end

  def ast_node; end
  def dig(*args, &block); end
  def errors(*args, &block); end
  def execution_strategy(*args, &block); end
  def fetch(*args, &block); end

  # Returns the value of attribute field.
  def field; end

  def inspect; end
  def interpreter?(*args, &block); end

  # Returns the value of attribute irep_node.
  def irep_node; end

  # Returns the value of attribute key.
  def key; end

  def key?(*args, &block); end
  def namespace(*args, &block); end

  # Returns the value of attribute parent.
  def parent; end

  # Returns the value of attribute parent_type.
  def parent_type; end

  def path; end

  # Returns the value of attribute query.
  def query; end

  # Returns the value of attribute schema.
  def schema; end

  # Returns the value of attribute irep_node.
  def selection; end

  def spawn(*args, &block); end
  def strategy(*args, &block); end
  def to_h(*args, &block); end

  # Returns the value of attribute type.
  def type; end

  # Set a new value for this field in the response.
  # It may be updated after resolving a {Lazy}.
  # If it is {Execute::PROPAGATE_NULL}, tell the owner to propagate null.
  # If it's {Execute::Execution::SKIP}, remove this field result from its parent
  def value=(new_value); end

  def warden(*args, &block); end
  def wrapped_connection; end
  def wrapped_connection=(_arg0); end
  def wrapped_object; end
  def wrapped_object=(_arg0); end

  protected

  def received_null_child; end

  private

  def list_of_non_null_items?(type); end
end

module GraphQL::Query::Context::SharedMethods
  # Add error at query-level.
  def add_error(error); end

  def backtrace; end

  # Remove this child from the result value
  # (used for null propagation and skip)
  def delete_child(child_ctx); end

  def execution_errors; end
  def invalid_null?; end
  def lookahead; end
  def object; end
  def object=(_arg0); end

  # Return this value to tell the runtime
  # to exclude this field from the response altogether
  def skip; end

  def skipped; end
  def skipped=(_arg0); end
  def skipped?; end

  # Create a child context to use for `key`
  def spawn_child(key:, irep_node:, object:); end

  def value; end
end

GraphQL::Query::Context::UNSPECIFIED_FETCH_DEFAULT = T.let(T.unsafe(nil), Object)

class GraphQL::Query::Executor
  def initialize(query); end

  def query; end

  # Evaluate {operation_name} on {query}.
  # Handle {GraphQL::ExecutionError}s by putting them in the "errors" key.
  def result; end

  private

  def execute; end
end

class GraphQL::Query::Executor::PropagateNull < ::StandardError; end

module GraphQL::Query::Fingerprint
  class << self
    # Make an obfuscated hash of the given string (either a query string or variables JSON)
    def generate(input_str); end
  end
end

class GraphQL::Query::InputValidationResult
  def initialize(valid: T.unsafe(nil), problems: T.unsafe(nil)); end

  def add_problem(explanation, path = T.unsafe(nil), extensions: T.unsafe(nil), message: T.unsafe(nil)); end
  def merge_result!(path, inner_result); end

  # Returns the value of attribute problems.
  def problems; end

  # Sets the attribute problems
  def problems=(_arg0); end

  def valid?; end
end

# Turn query string values into something useful for query execution
class GraphQL::Query::LiteralInput
  class << self
    def coerce(type, ast_node, variables); end
    def from_arguments(ast_arguments, argument_owner, variables); end
  end
end

# This object can be `ctx` in places where there is no query
class GraphQL::Query::NullContext
  def initialize; end

  def [](key); end

  # Returns the value of attribute dataloader.
  def dataloader; end

  def interpreter?; end

  # Returns the value of attribute query.
  def query; end

  # Returns the value of attribute schema.
  def schema; end

  # Returns the value of attribute warden.
  def warden; end

  class << self
    def [](key); end
    def dataloader(*args, &block); end
    def instance; end
    def interpreter?(*args, &block); end
    def query(*args, &block); end
    def schema(*args, &block); end
    def warden(*args, &block); end
  end
end

class GraphQL::Query::NullContext::NullQuery
  def with_error_handling; end
end

class GraphQL::Query::NullContext::NullSchema < ::GraphQL::Schema; end

class GraphQL::Query::NullContext::NullWarden < ::GraphQL::Schema::Warden
  def visible_argument?(arg, ctx); end
  def visible_enum_value?(ev, ctx); end
  def visible_field?(field, ctx); end
  def visible_type?(type, ctx); end
  def visible_type_membership?(tm, ctx); end
end

class GraphQL::Query::OperationNameMissingError < ::GraphQL::ExecutionError
  def initialize(name); end
end

# A result from {Schema#execute}.
# It provides the requested data and
# access to the {Query} and {Query::Context}.
class GraphQL::Query::Result
  extend ::Forwardable

  def initialize(query:, values:); end

  # A result is equal to another object when:
  #
  # - The other object is a Hash whose value matches `result.to_h`
  # - The other object is a Result whose value matches `result.to_h`
  #
  # (The query is ignored for comparing result equality.)
  def ==(other); end

  def [](*args, &block); end
  def as_json(*args, &block); end
  def context(*args, &block); end
  def inspect; end
  def keys(*args, &block); end

  # Delegate any hash-like method to the underlying hash.
  def method_missing(method_name, *args, &block); end

  def mutation?(*args, &block); end
  def query; end
  def query?(*args, &block); end
  def subscription?(*args, &block); end
  def to_h; end
  def to_json(*args, &block); end
  def values(*args, &block); end

  private

  def respond_to_missing?(method_name, include_private = T.unsafe(nil)); end
end

class GraphQL::Query::SerialExecution
  # This is the only required method for an Execution strategy.
  # You could create a custom execution strategy and configure your schema to
  # use that custom strategy instead.
  def execute(ast_operation, root_type, query_object); end

  def field_resolution; end
  def operation_resolution; end
  def selection_resolution; end
end

class GraphQL::Query::SerialExecution::FieldResolution
  def initialize(selection, parent_type, target, query_ctx); end

  # Returns the value of attribute arguments.
  def arguments; end

  # GraphQL::Batch depends on this
  def execution_context; end

  # Returns the value of attribute field.
  def field; end

  # Returns the value of attribute irep_node.
  def irep_node; end

  # Returns the value of attribute parent_type.
  def parent_type; end

  # Returns the value of attribute query.
  def query; end

  def result; end

  # Returns the value of attribute target.
  def target; end

  private

  # After getting the value from the field's resolve method,
  # continue by "finishing" the value, eg. executing sub-fields or coercing values
  def get_finished_value(raw_value); end

  # Get the result of:
  # - Any middleware on this schema
  # - The field's resolve method
  # If the middleware chain returns a GraphQL::ExecutionError, its message
  # is added to the "errors" key.
  def get_raw_value; end
end

module GraphQL::Query::SerialExecution::OperationResolution
  class << self
    def resolve(selection, target, query); end
  end
end

module GraphQL::Query::SerialExecution::SelectionResolution
  class << self
    def resolve(target, current_type, selection, query_ctx); end
  end
end

module GraphQL::Query::SerialExecution::ValueResolution
  class << self
    def resolve(parent_type, field_defn, field_type, value, selection, query_ctx); end
  end
end

# Contain the validation pipeline and expose the results.
#
# 0. Checks in {Query#initialize}:
# - Rescue a ParseError, halt if there is one
# - Check for selected operation, halt if not found
# 1. Validate the AST, halt if errors
# 2. Validate the variables, halt if errors
# 3. Run query analyzers, halt if errors
#
# {#valid?} is false if any of the above checks halted the pipeline.
class GraphQL::Query::ValidationPipeline
  def initialize(query:, validate:, parse_error:, operation_name_error:, max_depth:, max_complexity:); end

  def analyzers; end
  def internal_representation; end
  def max_complexity; end
  def max_depth; end
  def valid?; end
  def validation_errors; end

  private

  # If there are max_* values, add them,
  # otherwise reuse the schema's list of analyzers.
  def build_analyzers(schema, max_depth, max_complexity); end

  # If the pipeline wasn't run yet, run it.
  # If it was already run, do nothing.
  def ensure_has_validated; end
end

class GraphQL::Query::VariableValidationError < ::GraphQL::ExecutionError
  def initialize(variable_ast, type, value, validation_result); end

  def to_h; end

  # Returns the value of attribute validation_result.
  def validation_result; end

  # Sets the attribute validation_result
  def validation_result=(_arg0); end

  # Returns the value of attribute value.
  def value; end

  # Sets the attribute value
  def value=(_arg0); end

  private

  def problem_fields; end
end

# Read-only access to query variables, applying default values if needed.
class GraphQL::Query::Variables
  extend ::Forwardable

  def initialize(ctx, ast_variables, provided_variables); end

  def [](*args, &block); end

  # Returns the value of attribute context.
  def context; end

  def errors; end
  def fetch(*args, &block); end
  def key?(*args, &block); end
  def length(*args, &block); end
  def to_h(*args, &block); end
end

class GraphQL::Railtie < ::Rails::Railtie; end
module GraphQL::Relay; end

class GraphQL::Relay::ArrayConnection < ::GraphQL::Relay::BaseConnection
  def cursor_from_node(item); end
  def first; end
  def has_next_page; end
  def has_previous_page; end
  def last; end

  private

  def index_from_cursor(cursor); end

  # apply first / last limit results
  def paged_nodes; end

  # Apply cursors to edges
  def sliced_nodes; end
end

# Subclasses must implement:
# - {#cursor_from_node}, which returns an opaque cursor for the given item
# - {#sliced_nodes}, which slices by `before` & `after`
# - {#paged_nodes}, which applies `first` & `last` limits
#
# In a subclass, you have access to
# - {#nodes}, the collection which the connection will wrap
# - {#first}, {#after}, {#last}, {#before} (arguments passed to the field)
# - {#max_page_size} (the specified maximum page size that can be returned from a connection)
class GraphQL::Relay::BaseConnection
  # Make a connection, wrapping `nodes`
  def initialize(nodes, arguments, field: T.unsafe(nil), max_page_size: T.unsafe(nil), parent: T.unsafe(nil), context: T.unsafe(nil)); end

  # The value passed as `after:`, if there was one
  def after; end

  # Returns the value of attribute arguments.
  def arguments; end

  # The value passed as `before:`, if there was one
  def before; end

  # Returns the value of attribute context.
  def context; end

  # An opaque operation which returns a connection-specific cursor.
  def cursor_from_node(object); end

  def decode(data); end

  # These are the nodes to render for this connection,
  # probably wrapped by {GraphQL::Relay::Edge}
  def edge_nodes; end

  def encode(data); end

  # Used by `pageInfo`
  def end_cursor; end

  # Returns the value of attribute field.
  def field; end

  # The value passed as `first:`, if there was one. Negative numbers become `0`.
  def first; end

  # Used by `pageInfo`
  def has_next_page; end

  # Used by `pageInfo`
  def has_previous_page; end

  def inspect; end

  # The value passed as `last:`, if there was one. Negative numbers become `0`.
  def last; end

  # Returns the value of attribute max_page_size.
  def max_page_size; end

  # Returns the value of attribute nodes.
  def nodes; end

  # Support the `pageInfo` field
  def page_info; end

  # Returns the value of attribute parent.
  def parent; end

  # Used by `pageInfo`
  def start_cursor; end

  private

  def limit_pagination_argument(argument, max_page_size); end
  def paged_nodes; end
  def sliced_nodes; end

  class << self
    # Find a connection implementation suitable for exposing `nodes`
    def connection_for_nodes(nodes); end

    # Add `connection_class` as the connection wrapper for `nodes_class`
    # eg, `RelationConnection` is the implementation for `AR::Relation`
    def register_connection_implementation(nodes_class, connection_class); end
  end
end

# Map of collection class names -> connection_classes
# eg `{"Array" => ArrayConnection}`
GraphQL::Relay::BaseConnection::CONNECTION_IMPLEMENTATIONS = T.let(T.unsafe(nil), Hash)

# Just to encode data in the cursor, use something that won't conflict
GraphQL::Relay::BaseConnection::CURSOR_SEPARATOR = T.let(T.unsafe(nil), String)

# Provided a GraphQL field which returns a collection of nodes,
# wrap that field to expose those nodes as a connection.
#
# The original resolve proc is used to fetch nodes,
# then a connection implementation is fetched with {BaseConnection.connection_for_nodes}.
module GraphQL::Relay::ConnectionInstrumentation
  class << self
    def default_arguments; end

    # Build a connection field from a {GraphQL::Field} by:
    # - Merging in the default arguments
    # - Transforming its resolve function to return a connection object
    def instrument(type, field); end
  end
end

class GraphQL::Relay::ConnectionResolve
  def initialize(field, underlying_resolve); end

  def call(obj, args, ctx); end

  private

  def build_connection(nodes, args, parent, ctx); end
end

module GraphQL::Relay::ConnectionType
  class << self
    def bidirectional_pagination; end
    def bidirectional_pagination=(_arg0); end
    def create_type(wrapped_type, edge_type: T.unsafe(nil), edge_class: T.unsafe(nil), nodes_field: T.unsafe(nil), &block); end
    def default_nodes_field; end
    def default_nodes_field=(_arg0); end
  end
end

# Mostly an internal concern.
#
# Wraps an object as a `node`, and exposes a connection-specific `cursor`.
class GraphQL::Relay::Edge
  def initialize(node, connection); end

  # Returns the value of attribute connection.
  def connection; end

  def cursor; end
  def inspect; end

  # Returns the value of attribute node.
  def node; end

  def parent; end
end

module GraphQL::Relay::EdgeType
  class << self
    def create_type(wrapped_type, name: T.unsafe(nil), &block); end
  end
end

module GraphQL::Relay::EdgesInstrumentation
  class << self
    def instrument(type, field); end
  end
end

class GraphQL::Relay::EdgesInstrumentation::EdgesResolve
  def initialize(edge_class:, resolve:); end

  # A user's custom Connection may return a lazy object,
  # if so, handle it later.
  def call(obj, args, ctx); end
end

class GraphQL::Relay::GlobalIdResolve
  def initialize(type:); end

  def call(obj, args, ctx); end
end

# A connection implementation to expose MongoDB collection objects.
# It works for:
# - `Mongoid::Criteria`
class GraphQL::Relay::MongoRelationConnection < ::GraphQL::Relay::RelationConnection
  private

  def limit_nodes(sliced_nodes, limit); end
  def relation_count(relation); end
  def relation_limit(relation); end
  def relation_offset(relation); end
end

class GraphQL::Relay::Mutation
  include ::GraphQL::Define::InstanceDefinable
  extend ::GraphQL::Define::InstanceDefinable::ClassMethods

  def initialize; end

  def arguments; end
  def arguments=(_arg0); end
  def description; end
  def description=(_arg0); end
  def field; end
  def fields; end
  def fields=(_arg0); end
  def has_generated_return_type?; end
  def input_fields; end
  def input_type; end
  def name; end
  def name=(_arg0); end
  def resolve=(new_resolve_proc); end
  def result_class; end

  # For backwards compat, but do we need this separate API?
  def return_fields; end

  def return_interfaces; end
  def return_interfaces=(_arg0); end
  def return_type; end
  def return_type=(_arg0); end
end

module GraphQL::Relay::Mutation::Instrumentation
  class << self
    # Modify mutation `return_field` resolves by wrapping the returned object
    # in a {Mutation::Result}.
    #
    # By using an instrumention, we can apply our wrapper _last_,
    # giving users access to the original resolve function in earlier instrumentation.
    def instrument(type, field); end
  end
end

# Wrap a user-provided resolve function,
# wrapping the returned value in a {Mutation::Result}.
# Also, pass the `clientMutationId` to that result object.
class GraphQL::Relay::Mutation::Resolve
  def initialize(mutation, resolve); end

  def call(obj, args, ctx); end

  private

  def build_result(mutation_result, args, ctx); end
end

# Use this when the mutation's return type was generated from `return_field`s.
# It delegates field lookups to the hash returned from `resolve`.
class GraphQL::Relay::Mutation::Result
  def initialize(client_mutation_id:, result:); end

  def client_mutation_id; end

  class << self
    # Build a subclass whose instances have a method
    # for each of `mutation_defn`'s `return_field`s
    def define_subclass(mutation_defn); end

    def mutation; end
    def mutation=(_arg0); end
  end
end

# Helpers for working with Relay-specific Node objects.
module GraphQL::Relay::Node
  class << self
    def field(**kwargs, &block); end
    def interface; end
    def plural_field(**kwargs, &block); end
  end
end

# Wrap a Connection and expose its page info
GraphQL::Relay::PageInfo = T.let(T.unsafe(nil), GraphQL::ObjectType)

# This provides some isolation from `GraphQL::Relay` internals.
#
# Given a list of items and a new item, it will provide a connection and an edge.
#
# The connection doesn't receive outside arguments, so the list of items
# should be ordered and paginated before providing it here.
class GraphQL::Relay::RangeAdd
  def initialize(collection:, item:, parent: T.unsafe(nil), context: T.unsafe(nil), edge_class: T.unsafe(nil)); end

  # Returns the value of attribute connection.
  def connection; end

  # Returns the value of attribute edge.
  def edge; end

  # Returns the value of attribute parent.
  def parent; end
end

# A connection implementation to expose SQL collection objects.
# It works for:
# - `ActiveRecord::Relation`
# - `Sequel::Dataset`
class GraphQL::Relay::RelationConnection < ::GraphQL::Relay::BaseConnection
  def cursor_from_node(item); end
  def first; end
  def has_next_page; end
  def has_previous_page; end
  def last; end

  private

  def limit_nodes(sliced_nodes, limit); end
  def offset_from_cursor(cursor); end

  # apply first / last limit results
  def paged_nodes; end

  def paged_nodes_offset; end

  # If a relation contains a `.group` clause, a `.count` will return a Hash.
  def relation_count(relation); end

  def relation_limit(relation); end
  def relation_offset(relation); end

  # Apply cursors to edges
  def sliced_nodes; end

  def sliced_nodes_count; end
end

# Mixin for Relay-related methods in type objects
# (used by BaseType and Schema::Member).
module GraphQL::Relay::TypeExtensions
  def connection_type; end

  # Define a custom connection type for this object type
  def define_connection(**kwargs, &block); end

  # Define a custom edge type for this object type
  def define_edge(**kwargs, &block); end

  def edge_type; end
end

class GraphQL::RequiredImplementationMissingError < ::GraphQL::Error; end

# forwards-compat for argument handling
module GraphQL::Ruby2Keywords; end

class GraphQL::RuntimeTypeError < ::GraphQL::Error; end
GraphQL::STRING_TYPE = T.let(T.unsafe(nil), GraphQL::ScalarType)

class GraphQL::ScalarType < ::GraphQL::BaseType
  extend ::GraphQL::Define::InstanceDefinable::DeprecatedDefine

  def initialize; end

  def coerce=(proc); end
  def coerce_input=(coerce_input_fn); end
  def coerce_result(value, ctx = T.unsafe(nil)); end
  def coerce_result=(coerce_result_fn); end
  def kind; end

  private

  def coerce_non_null_input(value, ctx); end
  def ensure_two_arg(callable, method_name); end
  def raw_coercion_input(value); end
  def validate_non_null_input(value, ctx); end
end

module GraphQL::ScalarType::NoOpCoerce
  class << self
    def call(val, ctx); end
  end
end

# A GraphQL schema which may be queried with {GraphQL::Query}.
#
# The {Schema} contains:
#
# - types for exposing your application
# - query analyzers for assessing incoming queries (including max depth & max complexity restrictions)
# - execution strategies for running incoming queries
#
# Schemas start with root types, {Schema#query}, {Schema#mutation} and {Schema#subscription}.
# The schema will traverse the tree of fields & types, using those as starting points.
# Any undiscoverable types may be provided with the `types` configuration.
#
# Schemas can restrict large incoming queries with `max_depth` and `max_complexity` configurations.
# (These configurations can be overridden by specific calls to {Schema#execute})
#
# Schemas can specify how queries should be executed against them.
# `query_execution_strategy`, `mutation_execution_strategy` and `subscription_execution_strategy`
# each apply to corresponding root types.
# #
class GraphQL::Schema
  include ::GraphQL::Define::InstanceDefinable
  include ::GraphQL::Schema::LazyHandlingMethods
  extend ::Forwardable
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Define::InstanceDefinable::ClassMethods
  extend ::GraphQL::Define::InstanceDefinable::DeprecatedDefine
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::LazyHandlingMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL

  def initialize; end

  # Can't delegate to `class`
  def _schema_class; end

  def accessible?(member, context); end

  # Returns the value of attribute analysis_engine.
  def analysis_engine; end

  # Sets the attribute analysis_engine
  def analysis_engine=(_arg0); end

  # Return the Hash response of {Introspection::INTROSPECTION_QUERY}.
  def as_json(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

  # Returns the value of attribute ast_node.
  def ast_node; end

  # Sets the attribute ast_node
  def ast_node=(_arg0); end

  # Given this schema member, find the class-based definition object
  # whose `method_name` should be treated as an application hook
  def call_on_type_class(member, method_name, context, default:); end

  # This is a compatibility hack so that instance-level and class-level
  # methods can get correctness checks without calling one another
  def check_resolved_type(type, object, ctx = T.unsafe(nil)); end

  # Returns the value of attribute connections.
  def connections; end

  # Sets the attribute connections
  def connections=(_arg0); end

  def context_class; end
  def context_class=(_arg0); end

  # Returns the value of attribute cursor_encoder.
  def cursor_encoder; end

  # Sets the attribute cursor_encoder
  def cursor_encoder=(_arg0); end

  def dataloader_class; end
  def default_filter; end
  def default_mask; end
  def default_mask=(_arg0); end

  # Returns the value of attribute default_max_page_size.
  def default_max_page_size; end

  # Sets the attribute default_max_page_size
  def default_max_page_size=(_arg0); end

  def deprecated_define(**kwargs, &block); end
  def directive(*args, &block); end

  # Returns the value of attribute directives.
  def directives; end

  # Sets the attribute directives
  def directives=(_arg0); end

  # [Boolean] True if this object disables the introspection entry point fields
  def disable_introspection_entry_points; end

  # [Boolean] True if this object disables the introspection entry point fields
  def disable_introspection_entry_points=(_arg0); end

  def disable_introspection_entry_points?; end

  # [Boolean] True if this object disables the __schema introspection entry point field
  def disable_schema_introspection_entry_point; end

  # [Boolean] True if this object disables the __schema introspection entry point field
  def disable_schema_introspection_entry_point=(_arg0); end

  def disable_schema_introspection_entry_point?; end

  # [Boolean] True if this object disables the __type introspection entry point field
  def disable_type_introspection_entry_point; end

  # [Boolean] True if this object disables the __type introspection entry point field
  def disable_type_introspection_entry_point=(_arg0); end

  def disable_type_introspection_entry_point?; end

  # [Boolean] True if this object bubbles validation errors up from a field into its parent InputObject, if there is one.
  def error_bubbling; end

  # [Boolean] True if this object bubbles validation errors up from a field into its parent InputObject, if there is one.
  def error_bubbling=(_arg0); end

  def error_handler(*args, &block); end

  # Execute a query on itself. Raises an error if the schema definition is invalid.
  def execute(query_str = T.unsafe(nil), **kwargs); end

  def execution_strategy_for_operation(operation); end

  # Search for a schema member using a string path
  # Schema.find("Ensemble.musicians")
  def find(path); end

  # Resolve field named `field_name` for type `parent_type`.
  # Handles dynamic fields `__typename`, `__type` and `__schema`, too
  def get_field(parent_type, field_name); end

  # Fields for this type, after instrumentation is applied
  def get_fields(type); end

  def get_type(type_name); end

  # For forwards-compatibility with Schema classes
  def graphql_definition; end

  # Get a unique identifier from this object
  def id_from_object(object, type, ctx); end

  def id_from_object=(new_proc); end

  # Returns the value of attribute id_from_object_proc.
  def id_from_object_proc; end

  def inaccessible_fields(*args, &block); end
  def inspect; end

  # Attach `instrumenter` to this schema for instrumenting events of `instrumentation_type`.
  def instrument(instrumentation_type, instrumenter); end

  # Returns the value of attribute instrumenters.
  def instrumenters; end

  # Sets the attribute instrumenters
  def instrumenters=(_arg0); end

  def interpreter?; end

  # Returns the value of attribute introspection_namespace.
  def introspection_namespace; end

  # Sets the attribute introspection_namespace
  def introspection_namespace=(_arg0); end

  def introspection_system; end

  # Returns the value of attribute lazy_methods.
  def lazy_methods; end

  # Sets the attribute lazy_methods
  def lazy_methods=(_arg0); end

  # Returns the value of attribute max_complexity.
  def max_complexity; end

  # Sets the attribute max_complexity
  def max_complexity=(_arg0); end

  # Returns the value of attribute max_depth.
  def max_depth; end

  # Sets the attribute max_depth
  def max_depth=(_arg0); end

  def middleware; end
  def middleware=(_arg0); end

  # Execute several queries on itself. Raises an error if the schema definition is invalid.
  def multiplex(queries, **kwargs); end

  # Returns the value of attribute multiplex_analyzers.
  def multiplex_analyzers; end

  # Sets the attribute multiplex_analyzers
  def multiplex_analyzers=(_arg0); end

  # Returns the value of attribute mutation.
  def mutation; end

  # Sets the attribute mutation
  def mutation=(_arg0); end

  # Returns the value of attribute mutation_execution_strategy.
  def mutation_execution_strategy; end

  # Sets the attribute mutation_execution_strategy
  def mutation_execution_strategy=(_arg0); end

  def new_connections?; end

  # Fetch an application object by its unique id
  def object_from_id(id, ctx); end

  def object_from_id=(new_proc); end

  # Returns the value of attribute object_from_id_proc.
  def object_from_id_proc; end

  # Returns the value of attribute orphan_types.
  def orphan_types; end

  # Sets the attribute orphan_types
  def orphan_types=(_arg0); end

  # A function to call when {#execute} receives an invalid query string
  def parse_error(err, ctx); end

  def parse_error=(new_proc); end
  def possible_types(type_defn, context = T.unsafe(nil)); end

  # Returns the value of attribute query.
  def query; end

  # Sets the attribute query
  def query=(_arg0); end

  # Returns the value of attribute query_analyzers.
  def query_analyzers; end

  # Sets the attribute query_analyzers
  def query_analyzers=(_arg0); end

  # Returns the value of attribute query_execution_strategy.
  def query_execution_strategy; end

  # Sets the attribute query_execution_strategy
  def query_execution_strategy=(_arg0); end

  # Returns the value of attribute raise_definition_error.
  def raise_definition_error; end

  # Sets the attribute raise_definition_error
  def raise_definition_error=(_arg0); end

  # Returns a list of Arguments and Fields referencing a certain type
  def references_to(type_name = T.unsafe(nil)); end

  def remove_handler(*args, &block); end
  def rescue_from(*args, &block); end

  # Determine the GraphQL type for a given object.
  # This is required for unions and interfaces (including Relay's `Node` interface)
  def resolve_type(type, object, ctx = T.unsafe(nil)); end

  def resolve_type=(new_resolve_type_proc); end

  # Returns the value of attribute resolve_type_proc.
  def resolve_type_proc; end

  def root_type_for_operation(operation); end
  def root_types; end

  # Returns the value of attribute static_validator.
  def static_validator; end

  # Returns the value of attribute subscription.
  def subscription; end

  # Sets the attribute subscription
  def subscription=(_arg0); end

  # Returns the value of attribute subscription_execution_strategy.
  def subscription_execution_strategy; end

  # Sets the attribute subscription_execution_strategy
  def subscription_execution_strategy=(_arg0); end

  # Single, long-lived instance of the provided subscriptions class, if there is one.
  def subscriptions; end

  # Single, long-lived instance of the provided subscriptions class, if there is one.
  def subscriptions=(_arg0); end

  # Return the GraphQL IDL for the schema
  def to_definition(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

  # Return the GraphQL::Language::Document IDL AST for the schema
  def to_document(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

  # Returns the JSON response of {Introspection::INTROSPECTION_QUERY}.
  def to_json(*args); end

  def tracers; end

  # When we encounter a type error during query execution, we call this hook.
  #
  # You can use this hook to write a log entry,
  # add a {GraphQL::ExecutionError} to the response (with `ctx.add_error`)
  # or raise an exception and halt query execution.
  def type_error(err, ctx); end

  def type_error=(new_proc); end
  def type_from_ast(ast_node, context:); end
  def types; end
  def unauthorized_field(*args, &block); end
  def unauthorized_object(*args, &block); end

  # Returns a list of Union types in which a type is a member
  def union_memberships(type); end

  def using_ast_analysis?; end
  def validate(*args, &block); end

  # Returns the value of attribute validate_max_errors.
  def validate_max_errors; end

  # Sets the attribute validate_max_errors
  def validate_max_errors=(_arg0); end

  # Returns the value of attribute validate_timeout.
  def validate_timeout; end

  # Sets the attribute validate_timeout
  def validate_timeout=(_arg0); end

  def visible?(member, context); end

  protected

  # Lazily create a middleware and add it to the schema
  # (Don't add it if it's not used)
  def rescue_middleware; end

  def rescues?; end

  private

  def initialize_copy(other); end
  def rebuild_artifacts; end
  def with_definition_error_check; end

  class << self
    def accessible?(member, ctx); end
    def add_subscription_extension_if_necessary; end
    def analysis_engine; end

    # Sets the attribute analysis_engine
    def analysis_engine=(_arg0); end

    # Return the Hash response of {Introspection::INTROSPECTION_QUERY}.
    def as_json(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

    def connections; end
    def connections=(_arg0); end
    def context_class(new_context_class = T.unsafe(nil)); end
    def cursor_encoder(new_encoder = T.unsafe(nil)); end
    def dataloader_class; end

    # Sets the attribute dataloader_class
    def dataloader_class=(_arg0); end

    def default_analysis_engine; end
    def default_directives; end
    def default_execution_strategy; end

    # Sets the attribute default_execution_strategy
    def default_execution_strategy=(_arg0); end

    def default_filter; end
    def default_mask(new_mask = T.unsafe(nil)); end
    def default_max_page_size(new_default_max_page_size = T.unsafe(nil)); end
    def deprecated_graphql_definition; end
    def description(new_description = T.unsafe(nil)); end

    # Attach a single directive to this schema
    def directive(new_directive); end

    # Add several directives at once
    def directives(*new_directives); end

    def disable_introspection_entry_points; end
    def disable_introspection_entry_points?; end
    def disable_schema_introspection_entry_point; end
    def disable_schema_introspection_entry_point?; end
    def disable_type_introspection_entry_point; end
    def disable_type_introspection_entry_point?; end
    def error_bubbling(new_error_bubbling = T.unsafe(nil)); end

    # Sets the attribute error_bubbling
    def error_bubbling=(_arg0); end

    def error_handler; end

    # Execute a query on itself.
    sig { params(query_string: T.nilable(String), query: T.nilable(String), document: T.untyped, context: T.nilable(T::Hash[T.untyped, T.untyped]), variables: T.nilable(T::Hash[String, T.untyped]), operation_name: T.nilable(String), root_value: Object, kwargs: T.untyped).returns(T::Hash[String, T.untyped]) }
    def execute(query_string = T.unsafe(nil), query: T.unsafe(nil), document: T.unsafe(nil), context: T.unsafe(nil), variables: T.unsafe(nil), operation_name: T.unsafe(nil), root_value: T.unsafe(nil), **kwargs); end

    def execution_strategy_for_operation(*args, &block); end
    def find(path); end

    # Create schema from an IDL schema or file containing an IDL definition.
    def from_definition(definition_or_path, default_resolve: T.unsafe(nil), parser: T.unsafe(nil), using: T.unsafe(nil)); end

    # Create schema with the result of an introspection query.
    def from_introspection(introspection_result); end

    def get_field(type_or_name, field_name, context = T.unsafe(nil)); end
    def get_fields(type, context = T.unsafe(nil)); end
    def get_type(type_name, context = T.unsafe(nil)); end
    def graphql_definition(silence_deprecation_warning: T.unsafe(nil)); end
    def id_from_object(object, type, ctx); end
    def id_from_object=(*args, &block); end
    def id_from_object_proc(*args, &block); end

    # This hook is called when a client tries to access one or more
    # fields that fail the `accessible?` check.
    #
    # By default, an error is added to the response. Override this hook to
    # track metrics or return a different error to the client.
    def inaccessible_fields(error); end

    def inherited(child_class); end
    def instrument(instrument_step, instrumenter, options = T.unsafe(nil)); end
    def instrumenters; end

    # Sets the attribute interpreter
    def interpreter=(_arg0); end

    def interpreter?; end
    def introspection(new_introspection_namespace = T.unsafe(nil)); end
    def introspection_system; end
    def lazy_resolve(lazy_class, value_method); end
    def max_complexity(max_complexity = T.unsafe(nil)); end

    # Sets the attribute max_complexity
    def max_complexity=(_arg0); end

    def max_depth(new_max_depth = T.unsafe(nil)); end

    # Sets the attribute max_depth
    def max_depth=(_arg0); end

    def metadata(*args, &block); end
    def middleware(new_middleware = T.unsafe(nil)); end

    # Execute several queries on itself, concurrently.
    def multiplex(queries, **kwargs); end

    def multiplex_analyzer(new_analyzer); end
    def multiplex_analyzers; end
    def mutation(new_mutation_object = T.unsafe(nil)); end
    def mutation_execution_strategy(new_mutation_execution_strategy = T.unsafe(nil)); end
    def new_connections?; end
    def object_from_id(node_id, ctx); end
    def object_from_id=(*args, &block); end
    def object_from_id_proc(*args, &block); end
    def orphan_types(*new_orphan_types); end

    # A function to call when {#execute} receives an invalid query string
    #
    # The default is to add the error to `context.errors`
    def parse_error(parse_err, ctx); end

    def plugins; end
    def possible_types(type = T.unsafe(nil), context = T.unsafe(nil)); end
    def query(new_query_object = T.unsafe(nil)); end
    def query_analyzer(new_analyzer); end
    def query_analyzers; end
    def query_execution_strategy(new_query_execution_strategy = T.unsafe(nil)); end
    def query_stack_error(query, err); end
    def redefine(*args, &block); end
    def references_to(to_type = T.unsafe(nil), from: T.unsafe(nil)); end
    def remove_handler(*args, &block); end
    def rescue_from(*err_classes, &handler_block); end
    def resolve_type(type, obj, ctx); end
    def root_type_for_operation(operation); end
    def root_types; end
    def sanitized_printer(new_sanitized_printer = T.unsafe(nil)); end
    def static_validator; end
    def subscription(new_subscription_object = T.unsafe(nil)); end
    def subscription_execution_strategy(new_subscription_execution_strategy = T.unsafe(nil)); end
    def subscriptions; end
    def subscriptions=(_arg0); end

    # Return the GraphQL IDL for the schema
    def to_definition(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

    # Return the GraphQL::Language::Document IDL AST for the schema
    def to_document; end

    # Returns the JSON response of {Introspection::INTROSPECTION_QUERY}.
    def to_json(**args); end

    def tracer(new_tracer); end
    def tracers; end
    def type_error(type_err, ctx); end
    def type_from_ast(ast_node, context: T.unsafe(nil)); end

    # Build a map of `{ name => type }` and return it
    def types(context = T.unsafe(nil)); end

    # This hook is called when a field fails an `authorized?` check.
    #
    # By default, this hook implements the same behavior as unauthorized_object.
    #
    # Whatever value is returned from this method will be used instead of the
    # unauthorized field . If an error is raised, then `nil` will be used.
    #
    # If you want to add an error to the `"errors"` key, raise a {GraphQL::ExecutionError}
    # in this hook.
    def unauthorized_field(unauthorized_error); end

    # This hook is called when an object fails an `authorized?` check.
    # You might report to your bug tracker here, so you can correct
    # the field resolvers not to return unauthorized objects.
    #
    # By default, this hook just replaces the unauthorized object with `nil`.
    #
    # Whatever value is returned from this method will be used instead of the
    # unauthorized object (accessible as `unauthorized_error.object`). If an
    # error is raised, then `nil` will be used.
    #
    # If you want to add an error to the `"errors"` key, raise a {GraphQL::ExecutionError}
    # in this hook.
    def unauthorized_object(unauthorized_error); end

    def union_memberships(type = T.unsafe(nil)); end
    def use(plugin, **kwargs); end
    def using_ast_analysis?; end

    # Validate a query string according to this schema.
    def validate(string_or_document, rules: T.unsafe(nil), context: T.unsafe(nil)); end

    def validate_max_errors(new_validate_max_errors = T.unsafe(nil)); end

    # Sets the attribute validate_max_errors
    def validate_max_errors=(_arg0); end

    def validate_timeout(new_validate_timeout = T.unsafe(nil)); end

    # Sets the attribute validate_timeout
    def validate_timeout=(_arg0); end

    def visible?(member, ctx); end

    private

    def add_type_and_traverse(t, root:); end
    def all_middleware; end
    def lazy_methods; end
    def non_introspection_types; end
    def own_directives; end
    def own_instrumenters; end
    def own_middleware; end
    def own_multiplex_analyzers; end
    def own_orphan_types; end
    def own_plugins; end
    def own_possible_types; end
    def own_query_analyzers; end
    def own_tracers; end
    def own_types; end
    def own_union_memberships; end
  end
end

class GraphQL::Schema::Addition
  def initialize(schema:, own_types:, new_types:); end

  # Returns the value of attribute arguments_with_default_values.
  def arguments_with_default_values; end

  # Returns the value of attribute directives.
  def directives; end

  # Returns the value of attribute possible_types.
  def possible_types; end

  # Returns the value of attribute references.
  def references; end

  # Returns the value of attribute types.
  def types; end

  # Returns the value of attribute union_memberships.
  def union_memberships; end

  private

  def add_directives_from(owner); end
  def add_type(type, owner:, late_types:, path:); end
  def add_type_and_traverse(new_types); end

  # Lookup using `own_types` here because it's ok to override
  # inherited types by name
  def get_local_type(name); end

  def get_type(name); end
  def references_to(thing, from:); end
  def update_type_owner(owner, type); end
end

class GraphQL::Schema::Argument
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  include ::GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition
  include ::GraphQL::Schema::Member::AcceptsDefinition
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::HasDirectives
  include ::GraphQL::Schema::Member::HasDeprecationReason
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  include ::GraphQL::Schema::Member::HasValidators
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods

  def accessible?(context); end
  def authorized?(obj, value, ctx); end
  def authorized_as_type?(obj, value, ctx, as_type:); end
  def coerce_into_values(parent_object, values, context, argument_values); end
  def default_value; end
  def default_value?; end
  def deprecation_reason(text = T.unsafe(nil)); end
  def deprecation_reason=(new_reason); end
  def description(text = T.unsafe(nil)); end

  # Sets the attribute description
  def description=(_arg0); end

  def from_resolver?; end
  def graphql_name; end
  def inspect; end
  def keyword; end
  def load_and_authorize_value(load_method_owner, coerced_value, context); end
  def loads; end
  def name; end
  def owner; end
  def prepare; end

  # Apply the {prepare} configuration to `value`, using methods from `obj`.
  # Used by the runtime.
  def prepare_value(obj, value, context: T.unsafe(nil)); end

  def statically_coercible?; end
  def type; end
  def type=(new_type); end
  def validate_default_value; end
  def visible?(context); end

  private

  def validate_deprecated_or_optional(null:, deprecation_reason:); end
  def validate_input_type(input_type); end
end

class GraphQL::Schema::Argument::InvalidDefaultValueError < ::GraphQL::Error
  def initialize(argument); end
end

GraphQL::Schema::Argument::NO_DEFAULT = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::BUILT_IN_TYPES = T.let(T.unsafe(nil), Hash)

module GraphQL::Schema::Base64Encoder
  class << self
    def decode(encoded_text, nonce: T.unsafe(nil)); end
    def encode(unencoded_text, nonce: T.unsafe(nil)); end
  end
end

module GraphQL::Schema::BuildFromDefinition
  class << self
    def from_definition(definition_string, parser: T.unsafe(nil), **kwargs); end
    def from_definition_path(definition_path, parser: T.unsafe(nil), **kwargs); end
    def from_document(document, default_resolve:, using: T.unsafe(nil), relay: T.unsafe(nil)); end
  end
end

module GraphQL::Schema::BuildFromDefinition::Builder
  extend ::GraphQL::Schema::BuildFromDefinition::Builder

  def args_to_kwargs(arg_owner, node); end
  def build(document, default_resolve:, relay:, using: T.unsafe(nil)); end
  def build_arguments(type_class, arguments, type_resolver); end
  def build_default_value(default_value); end
  def build_definition_from_node(definition, type_resolver, default_resolve); end
  def build_deprecation_reason(directives); end
  def build_directive(directive_definition, type_resolver); end
  def build_directives(definition, ast_node, type_resolver); end
  def build_enum_type(enum_type_definition, type_resolver); end
  def build_fields(owner, field_definitions, type_resolver, default_resolve:); end
  def build_input_object_type(input_object_type_definition, type_resolver); end
  def build_interface_type(interface_type_definition, type_resolver); end
  def build_object_type(object_type_definition, type_resolver); end
  def build_resolve_type(lookup_hash, directives, missing_type_handler); end
  def build_scalar_type(scalar_type_definition, type_resolver, default_resolve:); end
  def build_scalar_type_coerce_method(scalar_class, method_name, default_definition_resolve); end
  def build_union_type(union_type_definition, type_resolver); end
  def prepare_directives(ast_node, type_resolver); end

  # Modify `types`, replacing any late-bound references to built-in types
  # with their actual definitions.
  #
  # (Schema definitions are allowed to reference those built-ins without redefining them.)
  def replace_late_bound_types_with_built_in(types); end

  def resolve_type_name(type); end
end

GraphQL::Schema::BuildFromDefinition::Builder::NO_DEFAULT_VALUE = T.let(T.unsafe(nil), Hash)
GraphQL::Schema::BuildFromDefinition::Builder::NullResolveType = T.let(T.unsafe(nil), Proc)

# Wrap a user-provided hash of resolution behavior for easy access at runtime.
#
# Coerce scalar values by:
# - Checking for a function in the map like `{ Date: { coerce_input: ->(val, ctx) { ... }, coerce_result: ->(val, ctx) { ... } } }`
# - Falling back to a passthrough
#
# Interface/union resolution can be provided as a `resolve_type:` key.
class GraphQL::Schema::BuildFromDefinition::ResolveMap
  def initialize(user_resolve_hash); end

  def call(type, field, obj, args, ctx); end
  def coerce_input(type, value, ctx); end
  def coerce_result(type, value, ctx); end
end

class GraphQL::Schema::BuildFromDefinition::ResolveMap::DefaultResolve
  def initialize(field_map, field_name); end

  # Make some runtime checks about
  # how `obj` implements the `field_name`.
  #
  # Create a new resolve function according to that implementation, then:
  # - update `field_map` with this implementation
  # - call the implementation now (to satisfy this field execution)
  #
  # If `obj` doesn't implement `field_name`, raise an error.
  def call(obj, args, ctx); end
end

module GraphQL::Schema::BuildFromDefinition::ResolveMap::NullScalarCoerce
  class << self
    def call(val, _ctx); end
  end
end

# In early GraphQL versions, errors would be "automatically"
# rescued and replaced with `"Internal error"`. That behavior
# was undesirable but this middleware is offered for people who
# want to preserve it.
#
# It has a couple of differences from the previous behavior:
#
# - Other parts of the query _will_ be run (previously,
# execution would stop when the error was raised and the result
# would have no `"data"` key at all)
# - The entry in {Query::Context#errors} is a {GraphQL::ExecutionError}, _not_
# the originally-raised error.
# - The entry in the `"errors"` key includes the location of the field
# which raised the errors.
module GraphQL::Schema::CatchallMiddleware
  class << self
    # Rescue any error and replace it with a {GraphQL::ExecutionError}
    # whose message is {MESSAGE}
    def call(parent_type, parent_object, field_definition, field_args, query_context); end
  end
end

GraphQL::Schema::CatchallMiddleware::MESSAGE = T.let(T.unsafe(nil), String)
class GraphQL::Schema::CyclicalDefinitionError < ::GraphQL::Error; end
GraphQL::Schema::DYNAMIC_FIELDS = T.let(T.unsafe(nil), Array)

module GraphQL::Schema::DefaultParseError
  class << self
    def call(parse_error, ctx); end
  end
end

module GraphQL::Schema::DefaultTypeError
  class << self
    def call(type_error, ctx); end
  end
end

# Subclasses of this can influence how {GraphQL::Execution::Interpreter} runs queries.
#
# - {.include?}: if it returns `false`, the field or fragment will be skipped altogether, as if it were absent
# - {.resolve}: Wraps field resolution (so it should call `yield` to continue)
class GraphQL::Schema::Directive < ::GraphQL::Schema::Member
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  extend ::GraphQL::Schema::Member::HasArguments
  extend ::GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL

  def initialize(owner, **arguments); end

  def arguments; end
  def owner; end

  private

  def assert_has_location(location); end
  def assert_valid_owner; end

  class << self
    def default_directive(new_default_directive = T.unsafe(nil)); end
    def default_directive?; end

    # Return a name based on the class name,
    # but downcase the first letter.
    def default_graphql_name; end

    # If false, this part of the query won't be evaluated
    def include?(_object, arguments, context); end

    def locations(*new_locations); end
    def on_field?; end
    def on_fragment?; end
    def on_operation?; end
    def path; end
    def repeatable(new_value); end
    def repeatable?; end

    # Continuing is passed as a block; `yield` to continue
    def resolve(object, arguments, context); end

    # Continuing is passed as a block, yield to continue.
    def resolve_each(object, arguments, context); end

    # Determines whether {Execution::Lookahead} considers the field to be selected
    def static_include?(_arguments, _context); end
  end
end

GraphQL::Schema::Directive::ARGUMENT_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::DEFAULT_DEPRECATION_REASON = T.let(T.unsafe(nil), String)

class GraphQL::Schema::Directive::Deprecated < ::GraphQL::Schema::Directive
  class << self
    def load_reason(value, _context = T.unsafe(nil)); end
  end
end

GraphQL::Schema::Directive::ENUM = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::ENUM_VALUE = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::FIELD = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::FIELD_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::FRAGMENT_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::FRAGMENT_SPREAD = T.let(T.unsafe(nil), Symbol)

# An example directive to show how you might interact with the runtime.
#
# This directive might be used along with a server-side feature flag system like Flipper.
#
# With that system, you could use this directive to exclude parts of a query
# if the current viewer doesn't have certain flags enabled.
# (So, this flag would be for internal clients, like your iOS app, not third-party API clients.)
#
# To use it, you have to implement `.enabled?`, for example:
class GraphQL::Schema::Directive::Feature < ::GraphQL::Schema::Directive
  class << self
    # Override this method in your app's subclass of this directive.
    def enabled?(flag_name, object, context); end

    # Implement the Directive API
    def include?(object, arguments, context); end

    def load_flag(value, _context = T.unsafe(nil)); end
  end
end

# This is _similar_ to {Directive::Feature}, except it's prescribed by the server, not the client.
#
# In this case, the server hides types and fields _entirely_, unless the current context has certain `:flags` present.
class GraphQL::Schema::Directive::Flagged < ::GraphQL::Schema::Directive
  def initialize(target, **options); end

  class << self
    def load_by(value, _context = T.unsafe(nil)); end
  end
end

module GraphQL::Schema::Directive::Flagged::VisibleByFlag
  def visible?(context); end

  class << self
    def included(schema_class); end
  end
end

GraphQL::Schema::Directive::INLINE_FRAGMENT = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::INPUT_FIELD_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::INPUT_OBJECT = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::INTERFACE = T.let(T.unsafe(nil), Symbol)

class GraphQL::Schema::Directive::Include < ::GraphQL::Schema::Directive
  class << self
    def load_if(value, _context = T.unsafe(nil)); end
    def static_include?(args, ctx); end
  end
end

GraphQL::Schema::Directive::LOCATIONS = T.let(T.unsafe(nil), Array)
GraphQL::Schema::Directive::LOCATION_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)
GraphQL::Schema::Directive::MUTATION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::OBJECT = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::QUERY = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::SCALAR = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::SCHEMA = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::SUBSCRIPTION = T.let(T.unsafe(nil), Symbol)

class GraphQL::Schema::Directive::Skip < ::GraphQL::Schema::Directive
  class << self
    def load_if(value, _context = T.unsafe(nil)); end
    def static_include?(args, ctx); end
  end
end

# An example directive to show how you might interact with the runtime.
#
# This directive takes the return value of the tagged part of the query,
# and if the named transform is whitelisted and applies to the return value,
# it's applied by calling a method with that name.
class GraphQL::Schema::Directive::Transform < ::GraphQL::Schema::Directive
  class << self
    def load_by(value, _context = T.unsafe(nil)); end

    # Implement the Directive API
    def resolve(object, arguments, context); end
  end
end

GraphQL::Schema::Directive::Transform::TRANSFORMS = T.let(T.unsafe(nil), Array)
GraphQL::Schema::Directive::UNION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::VARIABLE_DEFINITION = T.let(T.unsafe(nil), Symbol)
class GraphQL::Schema::DuplicateNamesError < ::GraphQL::Error; end

class GraphQL::Schema::DuplicateTypeNamesError < ::GraphQL::Error
  def initialize(type_name:, first_definition:, second_definition:, path:); end
end

class GraphQL::Schema::Enum < ::GraphQL::Schema::Member
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::ValidatesInput
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL

  class << self
    def all_enum_value_definitions; end
    def coerce_input(value_name, ctx); end
    def coerce_result(value, ctx); end
    def enum_value_class(new_enum_value_class = T.unsafe(nil)); end
    def enum_values(context = T.unsafe(nil)); end
    def inherited(child_class); end
    def kind; end
    def validate_non_null_input(value_name, ctx); end

    # Define a value for this enum
    sig { params(graphql_name: T.any(String, Symbol), positional_description: String, value: Object, description: T.nilable(String), deprecation_reason: T.nilable(String), block: T.untyped).void }
    def value(graphql_name, positional_description = T.unsafe(nil), value: T.unsafe(nil), description: T.unsafe(nil), deprecation_reason: T.unsafe(nil), &block); end

    sig { params(context: T.untyped).returns(T::Hash[String, GraphQL::Schema::EnumValue]) }
    def values(context = T.unsafe(nil)); end

    private

    def own_values; end
  end
end

class GraphQL::Schema::Enum::UnresolvedValueError < ::GraphQL::EnumType::UnresolvedValueError
  def initialize(value:, enum:, context:); end
end

# A possible value for an {Enum}.
#
# You can extend this class to customize enum values in your schema.
class GraphQL::Schema::EnumValue < ::GraphQL::Schema::Member
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  include ::GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition
  include ::GraphQL::Schema::Member::AcceptsDefinition
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::HasDirectives
  include ::GraphQL::Schema::Member::HasDeprecationReason
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods

  def accessible?(_ctx); end
  def authorized?(_ctx); end
  def description(new_desc = T.unsafe(nil)); end

  # Returns the value of attribute graphql_name.
  def graphql_name; end

  def inspect; end
  def owner; end
  def value(new_val = T.unsafe(nil)); end
  def visible?(_ctx); end
end

class GraphQL::Schema::Field
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  include ::GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition
  include ::GraphQL::Schema::Member::AcceptsDefinition
  include ::GraphQL::Schema::Member::HasArguments
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  include ::GraphQL::Schema::Member::HasValidators
  include ::GraphQL::Schema::Member::HasDirectives
  include ::GraphQL::Schema::Member::HasDeprecationReason
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects

  def accessible?(context); end
  def authorized?(object, args, context); end

  # If true, subscription updates with this field can be shared between viewers
  def broadcastable?; end

  def calculate_complexity(query:, nodes:, child_complexity:); end
  def complexity(new_complexity = T.unsafe(nil)); end

  # Can be set with `connection: true|false` or inferred from a type name ending in `*Connection`
  def connection?; end

  def description(text = T.unsafe(nil)); end

  # Sets the attribute description
  def description=(_arg0); end

  # Add `extension` to this field, initialized with `options` if provided.
  def extension(extension_class, options = T.unsafe(nil)); end

  # Read extension instances from this field,
  # or add new classes/options to be initialized on this field.
  # Extensions are executed in the order they are added.
  def extensions(new_extensions = T.unsafe(nil)); end

  # Read extras (as symbols) from this field,
  # or add new extras to be opted into by this field's resolver.
  def extras(new_extras = T.unsafe(nil)); end

  def fetch_extra(extra_name, ctx); end
  def graphql_name; end
  def has_max_page_size?; end
  def inspect; end
  def introspection?; end
  def max_page_size; end
  def method_conflict_warning?; end
  def method_str; end
  def method_sym; end
  def mutation; end
  def name; end
  def original_name; end
  def owner; end
  def owner=(_arg0); end
  def owner_type; end
  def relay_node_field; end

  # This method is called by the interpreter for each field.
  # You can extend it in your base field classes.
  def resolve(object, args, ctx); end

  # Implement {GraphQL::Field}'s resolve API.
  #
  # Eventually, we might hook up field instances to execution in another way. TBD.
  def resolve_field(obj, args, ctx); end

  def resolver; end
  def resolver_method; end
  def scoped?; end
  def subscription_scope; end
  def subscription_scope=(_arg0); end
  def trace; end
  def type; end

  # Sets the attribute type
  def type=(_arg0); end

  def visible?(context); end

  private

  def assert_satisfactory_implementation(receiver, method_name, ruby_kwargs); end
  def public_send_field(unextended_obj, unextended_ruby_kwargs, query_ctx); end
  def run_extensions_before_resolve(obj, args, ctx, extended, idx: T.unsafe(nil)); end

  # Convert a GraphQL arguments instance into a Ruby-style hash.
  def to_ruby_args(obj, graphql_args, field_ctx); end

  # Wrap execution with hooks.
  # Written iteratively to avoid big stack traces.
  def with_extensions(obj, args, ctx); end

  class << self
    # This extension is applied to fields when {#connection?} is true.
    #
    # You can override it in your base field definition.
    def connection_extension(new_extension_class = T.unsafe(nil)); end

    # Create a field instance from a list of arguments, keyword arguments, and a block.
    #
    # This method implements prioritization between the `resolver` or `mutation` defaults
    # and the local overrides via other keywords.
    #
    # It also normalizes positional arguments into keywords for {Schema::Field#initialize}.
    def from_options(name = T.unsafe(nil), type = T.unsafe(nil), desc = T.unsafe(nil), resolver: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), **kwargs, &block); end
  end
end

class GraphQL::Schema::Field::ConnectionExtension < ::GraphQL::Schema::FieldExtension
  def after_resolve(value:, object:, arguments:, context:, memo:); end
  def apply; end

  # Remove pagination args before passing it to a user method
  def resolve(object:, arguments:, context:); end
end

class GraphQL::Schema::Field::FieldImplementationFailed < ::GraphQL::Error; end
class GraphQL::Schema::Field::MissingReturnTypeError < ::GraphQL::Error; end
GraphQL::Schema::Field::NO_ARGS = T.let(T.unsafe(nil), Hash)

class GraphQL::Schema::Field::ScopeExtension < ::GraphQL::Schema::FieldExtension
  def after_resolve(object:, arguments:, context:, value:, memo:); end
end

# Extend this class to make field-level customizations to resolve behavior.
#
# When a extension is added to a field with `extension(MyExtension)`, a `MyExtension` instance
# is created, and its hooks are applied whenever that field is called.
#
# The instance is frozen so that instance variables aren't modified during query execution,
# which could cause all kinds of issues due to race conditions.
class GraphQL::Schema::FieldExtension
  # Called when the extension is mounted with `extension(name, options)`.
  # The instance will be frozen to avoid improper use of state during execution.
  def initialize(field:, options:); end

  def added_default_arguments; end
  def added_extras; end

  # Called after the field's definition block has been executed.
  # (Any arguments from the block are present on `field`)
  def after_define; end

  def after_define_apply; end

  # Called after {#field} was resolved, and after any lazy values (like `Promise`s) were synced,
  # but before the value was added to the GraphQL response.
  #
  # Whatever this hook returns will be used as the return value.
  def after_resolve(object:, arguments:, context:, value:, memo:); end

  # Called when this extension is attached to a field.
  # The field definition may be extended during this method.
  def apply; end

  def field; end
  def options; end

  # Called before resolving {#field}. It should either:
  #
  # - `yield` values to continue execution; OR
  # - return something else to shortcut field execution.
  #
  # Whatever this method returns will be used for execution.
  def resolve(object:, arguments:, context:); end

  class << self
    def default_argument(*argument_args, **argument_kwargs); end
    def default_argument_configurations; end

    # If configured, these `extras` will be added to the field if they aren't already present,
    # but removed by from `arguments` before the field's `resolve` is called.
    # (The extras _will_ be present for other extensions, though.)
    def extras(new_extras = T.unsafe(nil)); end
  end
end

GraphQL::Schema::FieldExtension::NO_EXTRAS = T.let(T.unsafe(nil), Array)

module GraphQL::Schema::FindInheritedValue
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects

  private

  def find_inherited_value(method_name, default_value = T.unsafe(nil)); end

  class << self
    def extended(child_cls); end
    def included(child_cls); end
  end
end

module GraphQL::Schema::FindInheritedValue::EmptyObjects; end
GraphQL::Schema::FindInheritedValue::EmptyObjects::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
GraphQL::Schema::FindInheritedValue::EmptyObjects::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# Find schema members using string paths
class GraphQL::Schema::Finder
  def initialize(schema); end

  def find(path); end

  private

  def find_in_directive(directive, path:); end
  def find_in_enum_type(enum_type, path:); end
  def find_in_field(field, path:); end
  def find_in_fields_type(type, kind:, path:); end
  def find_in_input_object(input_object, path:); end
  def find_in_type(type, path:); end

  # Returns the value of attribute schema.
  def schema; end
end

class GraphQL::Schema::Finder::MemberNotFoundError < ::ArgumentError; end

class GraphQL::Schema::InputObject < ::GraphQL::Schema::Member
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  include ::GraphQL::Dig
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::Forwardable
  extend ::GraphQL::Schema::Member::HasArguments
  extend ::GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  extend ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  extend ::GraphQL::Schema::Member::ValidatesInput
  extend ::GraphQL::Schema::Member::HasValidators
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL

  def initialize(arguments = T.unsafe(nil), context:, defaults_used:, ruby_kwargs: T.unsafe(nil)); end

  # Lookup a key on this object, it accepts new-style underscored symbols
  # Or old-style camelized identifiers.
  def [](key); end

  def any?(*args, &block); end
  def arguments; end
  def context; end
  def each(*args, &block); end
  def empty?(*args, &block); end
  def key?(key); end
  def keys(*args, &block); end
  def map(*args, &block); end
  def prepare; end
  def to_h; end
  def to_hash; end

  # A copy of the Ruby-style hash
  def to_kwargs; end

  def unwrap_value(value); end
  def values(*args, &block); end

  private

  def overwrite_argument(key, value); end

  class << self
    def argument(*args, **kwargs, &block); end
    def arguments_class; end
    def arguments_class=(_arg0); end
    def authorized?(obj, value, ctx); end
    def coerce_input(value, ctx); end

    # It's funny to think of a _result_ of an input object.
    # This is used for rendering the default value in introspection responses.
    def coerce_result(value, ctx); end

    def kind; end
    def validate_non_null_input(input, ctx); end
  end
end

module GraphQL::Schema::Interface
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::Member::HasUnresolvedTypeError
  extend ::GraphQL::Schema::Member::HasDirectives
  extend ::GraphQL::Schema::Member::HasInterfaces
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Interface::DefinitionMethods
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension

  mixes_in_class_methods ::GraphQL::Schema::Member::RelayShortcuts

  def unwrap; end
end

module GraphQL::Schema::Interface::DefinitionMethods
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition
  include ::GraphQL::Relay::TypeExtensions
  include ::GraphQL::Schema::FindInheritedValue
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  include ::GraphQL::Schema::Member::BaseDSLMethods
  include ::GraphQL::Schema::Member::TypeSystemHelpers
  include ::GraphQL::Schema::Member::HasFields
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::Member::RelayShortcuts
  include ::GraphQL::Schema::Member::Scoped
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::HasUnresolvedTypeError
  include ::GraphQL::Schema::Member::HasDirectives
  include ::GraphQL::Schema::Member::HasInterfaces
  include ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods

  # The interface is accessible if any of its possible types are accessible
  def accessible?(context); end

  # Methods defined in this block will be:
  # - Added as class methods to this interface
  # - Added as class methods to all child interfaces
  def definition_methods(&block); end

  # Here's the tricky part. Make sure behavior keeps making its way down the inheritance chain.
  def included(child_class); end

  def kind; end
  def orphan_types(*types); end
  def type_membership_class(membership_class = T.unsafe(nil)); end
  def visible?(context); end
end

class GraphQL::Schema::IntrospectionSystem
  def initialize(schema); end

  def dynamic_field(name:); end
  def dynamic_fields; end
  def entry_point(name:); end
  def entry_points; end

  # Returns the value of attribute possible_types.
  def possible_types; end

  # The introspection system is prepared with a bunch of LateBoundTypes.
  # Replace those with the objects that they refer to, since LateBoundTypes
  # aren't handled at runtime.
  def resolve_late_bindings; end

  # Returns the value of attribute types.
  def types; end

  private

  # This is probably not 100% robust -- but it has to be good enough to avoid modifying the built-in introspection types
  def dup_type_class(type_class); end

  def get_fields_from_class(class_sym:); end
  def load_constant(class_name); end
  def resolve_late_binding(late_bound_type); end
end

class GraphQL::Schema::IntrospectionSystem::PerFieldProxyResolve
  def initialize(object_class:, inner_resolve:); end

  def call(obj, args, ctx); end
end

# Error that is raised when [#Schema#from_definition] is passed an invalid schema definition string.
class GraphQL::Schema::InvalidDocumentError < ::GraphQL::Error; end

class GraphQL::Schema::InvalidTypeError < ::GraphQL::Error; end

# A stand-in for a type which will be resolved in a given schema, by name.
# TODO: support argument types too, make this a public API somehow
class GraphQL::Schema::LateBoundType
  def initialize(local_name); end

  def graphql_name; end
  def inspect; end
  def name; end
  def to_list_type; end
  def to_non_null_type; end
  def to_s; end
  def unwrap; end
end

module GraphQL::Schema::LazyHandlingMethods
  # Return a lazy if any of `maybe_lazies` are lazy,
  # otherwise, call the block eagerly and return the result.
  def after_any_lazies(maybe_lazies); end

  # Call the given block at the right time, either:
  # - Right away, if `value` is not registered with `lazy_resolve`
  # - After resolving `value`, if it's registered with `lazy_resolve` (eg, `Promise`)
  def after_lazy(value, &block); end

  def lazy?(obj); end
  def lazy_method_name(obj); end

  # Override this method to handle lazy objects in a custom way.
  def sync_lazy(value); end
end

# Represents a list type in the schema.
# Wraps a {Schema::Member} as a list type.
class GraphQL::Schema::List < ::GraphQL::Schema::Wrapper
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL
  include ::GraphQL::Schema::Member::ValidatesInput

  def coerce_input(value, ctx); end
  def coerce_result(value, ctx); end

  # Also for implementing introspection
  def description; end

  # This is for introspection, where it's expected the name will be `null`
  def graphql_name; end

  def kind; end
  def list?; end
  def to_type_signature; end
  def validate_non_null_input(value, ctx); end

  private

  def ensure_array(value); end
end

# You can use the result of {GraphQL::Introspection::INTROSPECTION_QUERY}
# to make a schema. This schema is missing some important details like
# `resolve` functions, but it does include the full type system,
# so you can use it to validate queries.
module GraphQL::Schema::Loader
  extend ::GraphQL::Schema::Loader

  # Create schema with the result of an introspection query.
  def load(introspection_result); end

  class << self
    def build_arguments(arg_owner, args, type_resolver); end
    def build_fields(type_defn, fields, type_resolver); end

    private

    def define_directive(directive, type_resolver); end
    def define_type(type, type_resolver); end
    def extract_default_value(default_value_str, input_value_ast); end
    def resolve_type(types, type); end
  end
end

GraphQL::Schema::Loader::NullScalarCoerce = T.let(T.unsafe(nil), Proc)

# The base class for things that make up the schema,
# eg objects, enums, scalars.
class GraphQL::Schema::Member
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::Member::BaseDSLMethods::ConfigurationExtension
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::Member::HasDirectives
end

# Support for legacy `accepts_definitions` functions.
#
# Keep the legacy handler hooked up. Class-based types and fields
# will call those legacy handlers during their `.to_graphql`
# methods.
#
# This can help out while transitioning from one to the other.
# Eventually, `GraphQL::{X}Type` objects will be removed entirely,
# But this can help during the transition.
module GraphQL::Schema::Member::AcceptsDefinition
  mixes_in_class_methods ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods

  class << self
    def extended(child); end
    def included(child); end
  end
end

module GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  def accepts_definition(name); end
  def accepts_definition_methods; end
  def own_accepts_definition_methods; end
end

module GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
  def initialize(*args, **kwargs, &block); end

  def accepts_definition_methods; end
end

module GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def to_graphql(*args, **kwargs); end
end

# DSL methods shared by lots of things in the GraphQL Schema.
module GraphQL::Schema::Member::BaseDSLMethods
  include ::GraphQL::Schema::FindInheritedValue
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects

  def accessible?(context); end
  def authorized?(object, context); end

  # Creates the default name for a schema member.
  # The default name is the Ruby constant name,
  # without any namespaces and with any `-Type` suffix removed
  def default_graphql_name; end

  # Call this method to provide a new description; OR
  # call it without an argument to get the description
  def description(new_description = T.unsafe(nil)); end

  # Call this with a new name to override the default name for this schema member; OR
  # call it without an argument to get the name of this schema member
  #
  # The default name is implemented in default_graphql_name
  def graphql_name(new_name = T.unsafe(nil)); end

  def introspection(new_introspection = T.unsafe(nil)); end
  def introspection?; end

  # The mutation this type was derived from, if it was derived from a mutation
  def mutation(mutation_class = T.unsafe(nil)); end

  # Just a convenience method to point out that people should use graphql_name instead
  def name(new_name = T.unsafe(nil)); end

  def overridden_graphql_name; end
  def to_graphql; end
  def unwrap; end
  def visible?(context); end
end

# This pushes some configurations _down_ the inheritance tree,
# in order to prevent repetitive lookups at runtime.
module GraphQL::Schema::Member::BaseDSLMethods::ConfigurationExtension
  def inherited(child_class); end
end

module GraphQL::Schema::Member::BuildType
  private

  def camelize(string); end

  # Resolves constant from string (based on Rails `ActiveSupport::Inflector.constantize`)
  def constantize(string); end

  def parse_type(type_expr, null:); end
  def to_type_name(something); end
  def underscore(string); end

  class << self
    def camelize(string); end

    # Resolves constant from string (based on Rails `ActiveSupport::Inflector.constantize`)
    def constantize(string); end

    def parse_type(type_expr, null:); end
    def to_type_name(something); end
    def underscore(string); end
  end
end

GraphQL::Schema::Member::BuildType::LIST_TYPE_ERROR = T.let(T.unsafe(nil), String)

# Adds a layer of caching over user-supplied `.to_graphql` methods.
# Users override `.to_graphql`, but all runtime code should use `.graphql_definition`.
module GraphQL::Schema::Member::CachedGraphQLDefinition
  def deprecated_to_graphql; end

  # A cached result of {.to_graphql}.
  # It's cached here so that user-overridden {.to_graphql} implementations
  # are also cached
  def graphql_definition(silence_deprecation_warning: T.unsafe(nil)); end

  # This is for a common interface with .define-based types
  def type_class; end

  private

  # Wipe out the cached graphql_definition so that `.to_graphql` will be called again.
  def initialize_copy(original); end
end

module GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL
  def to_graphql(silence_deprecation_warning: T.unsafe(nil)); end
end

# These constants are interpreted as GraphQL types when defining fields or arguments
module GraphQL::Schema::Member::GraphQLTypeNames; end

GraphQL::Schema::Member::GraphQLTypeNames::Boolean = T.let(T.unsafe(nil), String)
GraphQL::Schema::Member::GraphQLTypeNames::ID = T.let(T.unsafe(nil), String)
GraphQL::Schema::Member::GraphQLTypeNames::Int = T.let(T.unsafe(nil), String)

module GraphQL::Schema::Member::HasArguments
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader

  mixes_in_class_methods ::GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor

  # Register this argument with the class.
  def add_argument(arg_defn); end

  def all_argument_definitions; end
  def argument(*args, **kwargs, &block); end
  def argument_class(new_arg_class = T.unsafe(nil)); end
  def arguments(context = T.unsafe(nil)); end
  def arguments_statically_coercible?; end

  # If given a block, it will eventually yield the loaded args to the block.
  #
  # If no block is given, it will immediately dataload (but might return a Lazy).
  def coerce_arguments(parent_object, values, context, &block); end

  def get_argument(argument_name, context = T.unsafe(nil)); end
  def own_arguments; end

  # Usually, this is validated statically by RequiredArgumentsArePresent,
  # but not for directives.
  # TODO apply static validations on schema definitions?
  def validate_directive_argument(arg_defn, value); end

  class << self
    def extended(cls); end
    def included(cls); end
  end
end

module GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  def argument_class(new_arg_class = T.unsafe(nil)); end
end

module GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  def authorize_application_object(argument, id, context, loaded_application_object); end
  def load_and_authorize_application_object(argument, id, context); end
  def load_application_object(argument, id, context); end
  def load_application_object_failed(err); end

  # Look up the corresponding object for a provided ID.
  # By default, it uses Relay-style {Schema.object_from_id},
  # override this to find objects another way.
  def object_from_id(type, id, context); end
end

GraphQL::Schema::Member::HasArguments::NO_ARGUMENTS = T.let(T.unsafe(nil), Hash)

module GraphQL::Schema::Member::HasAstNode
  # If this schema was parsed from a `.graphql` file (or other SDL),
  # this is the AST node that defined this part of the schema.
  def ast_node(new_ast_node = T.unsafe(nil)); end
end

module GraphQL::Schema::Member::HasDeprecationReason
  def deprecation_reason; end

  # Set the deprecation reason for this member, or remove it by assigning `nil`
  def deprecation_reason=(text); end
end

module GraphQL::Schema::Member::HasDirectives
  # Create an instance of `dir_class` for `self`, using `options`.
  #
  # It removes a previously-attached instance of `dir_class`, if there is one.
  def directive(dir_class, **options); end

  def directives; end

  # Remove an attached instance of `dir_class`, if there is one
  def remove_directive(dir_class); end

  protected

  def own_directives; end

  private

  # Modify `target` by adding items from `dirs` such that:
  # - Any name conflict is overriden by the incoming member of `dirs`
  # - Any other member of `dirs` is appended
  def merge_directives(target, dirs); end
end

GraphQL::Schema::Member::HasDirectives::NO_DIRECTIVES = T.let(T.unsafe(nil), Array)

# Shared code for Objects, Interfaces, Mutations, Subscriptions
module GraphQL::Schema::Member::HasFields
  # Register this field with the class, overriding a previous one if needed.
  def add_field(field_defn, method_conflict_warning: T.unsafe(nil)); end

  def all_field_definitions; end

  # Add a field to this object or interface with the given definition
  sig { params(args: T.untyped, kwargs: T.untyped, block: T.nilable(T.proc.void)).void }
  def field(*args, **kwargs, &block); end

  def field_class(new_field_class = T.unsafe(nil)); end
  def fields(context = T.unsafe(nil)); end
  def get_field(field_name, context = T.unsafe(nil)); end
  def global_id_field(field_name, **kwargs); end
  def own_fields; end

  private

  def conflict_field_name_warning(field_defn); end

  # If `type` is an interface, and `self` has a type membership for `type`, then make sure it's visible.
  def visible_interface_implementation?(type, context, warden); end
end

# A list of field names that we should advise users to pick a different
# resolve method name.
GraphQL::Schema::Member::HasFields::CONFLICT_FIELD_NAMES = T.let(T.unsafe(nil), Set)

# A list of GraphQL-Ruby keywords.
GraphQL::Schema::Member::HasFields::GRAPHQL_RUBY_KEYWORDS = T.let(T.unsafe(nil), Array)

# A list of Ruby keywords.
GraphQL::Schema::Member::HasFields::RUBY_KEYWORDS = T.let(T.unsafe(nil), Array)

module GraphQL::Schema::Member::HasInterfaces
  def implements(*new_interfaces, **options); end
  def interface_type_memberships; end

  # param context [Query::Context] If omitted, skip filtering.
  def interfaces(context = T.unsafe(nil)); end

  def own_interface_type_memberships; end
end

module GraphQL::Schema::Member::HasPath
  def path; end
end

# Set up a type-specific error to make debugging & bug tracker integration better
module GraphQL::Schema::Member::HasUnresolvedTypeError
  private

  def add_unresolved_type_error(child_class); end
end

module GraphQL::Schema::Member::HasValidators
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects

  # Build {GraphQL::Schema::Validator}s based on the given configuration
  # and use them for this schema member
  def validates(validation_config); end

  def validators; end
end

module GraphQL::Schema::Member::Instrumentation
  private

  def after_query(_query); end
  def apply_proxy(field); end
  def before_query(query); end
  def instrument(type, field); end
  def list_depth(type, starting_at = T.unsafe(nil)); end

  class << self
    def after_query(_query); end
    def apply_proxy(field); end
    def before_query(query); end
    def instrument(type, field); end
    def list_depth(type, starting_at = T.unsafe(nil)); end
  end
end

class GraphQL::Schema::Member::Instrumentation::ProxiedResolve
  def initialize(inner_resolve:, list_depth:, inner_return_type:); end

  def call(obj, args, ctx); end

  private

  def execution_errors?(result); end
  def proxy_to_depth(inner_obj, depth, ctx); end
end

module GraphQL::Schema::Member::RelayShortcuts
  def connection_type; end
  def connection_type_class(new_connection_type_class = T.unsafe(nil)); end
  def edge_type; end
  def edge_type_class(new_edge_type_class = T.unsafe(nil)); end
end

module GraphQL::Schema::Member::Scoped
  # This is called when a field has `scope: true`.
  # The field's return type class receives this call.
  #
  # By default, it's a no-op. Override it to scope your objects.
  def scope_items(items, context); end
end

module GraphQL::Schema::Member::TypeSystemHelpers
  def kind; end
  def list?; end
  def non_null?; end
  def to_list_type; end
  def to_non_null_type; end
  def to_type_signature; end
end

module GraphQL::Schema::Member::ValidatesInput
  def coerce_isolated_input(v); end
  def coerce_isolated_result(v); end
  def valid_input?(val, ctx); end
  def valid_isolated_input?(v); end
  def validate_input(val, ctx); end
end

# Given {steps} and {arguments}, call steps in order, passing `(*arguments, next_step)`.
#
# Steps should call `next_step.call` to continue the chain, or _not_ call it to stop the chain.
class GraphQL::Schema::MiddlewareChain
  extend ::Forwardable

  def initialize(steps: T.unsafe(nil), final_step: T.unsafe(nil)); end

  def <<(callable); end
  def ==(other); end
  def [](*args, &block); end
  def concat(callables); end
  def delete(*args, &block); end
  def final_step; end
  def first(*args, &block); end
  def insert(*args, &block); end
  def invoke(arguments); end
  def push(callable); end
  def steps; end

  private

  def add_middleware(callable); end
  def initialize_copy(other); end
  def invoke_core(index, arguments); end
  def wrap(callable); end
end

# TODO: Remove this code once deprecated middleware becomes unsupported
class GraphQL::Schema::MiddlewareChain::MiddlewareWrapper
  def initialize(callable); end

  def call(*args, &next_middleware); end

  # Returns the value of attribute callable.
  def callable; end
end

# This base class accepts configuration for a mutation root field,
# then it can be hooked up to your mutation root object type.
#
# If you want to customize how this class generates types, in your base class,
# override the various `generate_*` methods.
class GraphQL::Schema::Mutation < ::GraphQL::Schema::Resolver
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Resolver::HasPayloadType

  class << self
    # Override this method to handle legacy-style usages of `MyMutation.field`
    def field(*args, **kwargs, &block); end

    def visible?(context); end

    private

    def conflict_field_name_warning(field_defn); end

    # Override this to attach self as `mutation`
    def generate_payload_type; end
  end
end

# Represents a non null type in the schema.
# Wraps a {Schema::Member} when it is required.
class GraphQL::Schema::NonNull < ::GraphQL::Schema::Wrapper
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL
  include ::GraphQL::Schema::Member::ValidatesInput

  def coerce_input(value, ctx); end
  def coerce_result(value, ctx); end

  # This is for implementing introspection
  def description; end

  # This is for introspection, where it's expected the name will be `null`
  def graphql_name; end

  def inspect; end
  def kind; end
  def list?; end
  def non_null?; end
  def to_type_signature; end
  def validate_input(value, ctx); end
end

module GraphQL::Schema::NullMask
  class << self
    def call(member, ctx); end
  end
end

class GraphQL::Schema::Object < ::GraphQL::Schema::Member
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasInterfaces
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL

  def initialize(object, context); end

  def context; end
  def dataloader; end
  def object; end

  # Call this in a field method to return a value that should be returned to the client
  # without any further handling by GraphQL.
  def raw_value(obj); end

  class << self
    # Make a new instance of this type _if_ the auth check passes,
    # otherwise, raise an error.
    #
    # Probably only the framework should call this method.
    #
    # This might return a {GraphQL::Execution::Lazy} if the user-provided `.authorized?`
    # hook returns some lazy value (like a Promise).
    #
    # The reason that the auth check is in this wrapper method instead of {.new} is because
    # of how it might return a Promise. It would be weird if `.new` returned a promise;
    # It would be a headache to try to maintain Promise-y state inside a {Schema::Object}
    # instance. So, hopefully this wrapper method will do the job.
    def authorized_new(object, context); end

    def fields(context = T.unsafe(nil)); end

    # Set up a type-specific invalid null error to use when this object's non-null fields wrongly return `nil`.
    # It should help with debugging and bug tracker integrations.
    def inherited(child_class); end

    def kind; end
  end
end

# Find the members of a union or interface within a given schema.
#
# (Although its members never change, unions are handled this way to simplify execution code.)
#
# Internally, the calculation is cached. It's assumed that schema members _don't_ change after creating the schema!
class GraphQL::Schema::PossibleTypes
  def initialize(schema); end

  def interface_implementers(ctx, type_defn); end
  def possible_types(type_defn, ctx); end
end

# Used to convert your {GraphQL::Schema} to a GraphQL schema string
class GraphQL::Schema::Printer < ::GraphQL::Language::Printer
  def initialize(schema, context: T.unsafe(nil), only: T.unsafe(nil), except: T.unsafe(nil), introspection: T.unsafe(nil)); end

  # Return a GraphQL schema string for the defined types in the schema
  def print_schema; end

  def print_type(type); end

  # Returns the value of attribute schema.
  def schema; end

  # Returns the value of attribute warden.
  def warden; end

  class << self
    # Return the GraphQL schema string for the introspection type system
    def print_introspection_schema; end

    # Return a GraphQL schema string for the defined types in the schema
    def print_schema(schema, **args); end
  end
end

class GraphQL::Schema::Printer::IntrospectionPrinter < ::GraphQL::Language::Printer
  def print_schema_definition(schema); end
end

# Mutations that extend this base class get some conventions added for free:
#
# - An argument called `clientMutationId` is _always_ added, but it's not passed
# to the resolve method. The value is re-inserted to the response. (It's for
# client libraries to manage optimistic updates.)
# - The returned object type always has a field called `clientMutationId` to support that.
# - The mutation accepts one argument called `input`, `argument`s defined in the mutation
# class are added to that input object, which is generated by the mutation.
#
# These conventions were first specified by Relay Classic, but they come in handy:
#
# - `clientMutationId` supports optimistic updates and cache rollbacks on the client
# - using a single `input:` argument makes it easy to post whole JSON objects to the mutation
# using one GraphQL variable (`$input`) instead of making a separate variable for each argument.
class GraphQL::Schema::RelayClassicMutation < ::GraphQL::Schema::Mutation
  # Override {GraphQL::Schema::Resolver#resolve_with_support} to
  # delete `client_mutation_id` from the kwargs.
  def resolve_with_support(**inputs); end

  private

  def authorize_arguments(args, values); end

  class << self
    # Also apply this argument to the input type:
    def argument(*args, **kwargs, &block); end

    # Extend {Schema::Mutation.field_options} to add the `input` argument
    def field_options; end

    # The base class for generated input object types
    def input_object_class(new_class = T.unsafe(nil)); end

    def input_type(new_input_type = T.unsafe(nil)); end

    private

    # Generate the input type for the `input:` argument
    # To customize how input objects are generated, override this method
    def generate_input_type; end
  end
end

# - Store a table of errors & handlers
# - Rescue errors in a middleware chain, then check for a handler
# - If a handler is found, use it & return a {GraphQL::ExecutionError}
# - If no handler is found, re-raise the error
class GraphQL::Schema::RescueMiddleware
  def initialize; end

  # Implement the requirement for {GraphQL::Schema::MiddlewareChain}
  def call(*args); end

  # Remove the handler for `error_classs`
  def remove_handler(*error_classes); end

  def rescue_from(*error_classes, &block); end
  def rescue_table; end

  private

  def attempt_rescue(err); end
end

# A class-based container for field configuration and resolution logic. It supports:
#
# - Arguments, via `.argument(...)` helper, which will be applied to the field.
# - Return type, via `.type(..., null: ...)`, which will be applied to the field.
# - Description, via `.description(...)`, which will be applied to the field
# - Resolution, via `#resolve(**args)` method, which will be called to resolve the field.
# - `#object` and `#context` accessors for use during `#resolve`.
#
# Resolvers can be attached with the `resolver:` option in a `field(...)` call.
#
# A resolver's configuration may be overridden with other keywords in the `field(...)` call.
#
# See the {.field_options} to see how a Resolver becomes a set of field configuration options.
class GraphQL::Schema::Resolver
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  include ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::Member::HasArguments
  extend ::GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  extend ::GraphQL::Schema::Member::HasValidators
  extend ::GraphQL::Schema::Member::HasPath

  def initialize(object:, context:, field:); end

  def arguments; end

  # Called after arguments are loaded, but before resolving.
  #
  # Override it to check everything before calling the mutation.
  def authorized?(**inputs); end

  def context; end
  def dataloader; end
  def field; end
  def object; end

  # Called before arguments are prepared.
  # Implement this hook to make checks before doing any work.
  #
  # If it returns a lazy object (like a promise), it will be synced by GraphQL
  # (but the resulting value won't be used).
  def ready?(**args); end

  # Do the work. Everything happens here.
  def resolve(**args); end

  # This method is _actually_ called by the runtime,
  # it does some preparation and then eventually calls
  # the user-defined `#resolve` method.
  def resolve_with_support(**args); end

  # Called when an object loaded by `loads:` fails the `.authorized?` check for its resolved GraphQL object type.
  #
  # By default, the error is re-raised and passed along to {{Schema.unauthorized_object}}.
  #
  # Any value returned here will be used _instead of_ of the loaded object.
  def unauthorized_object(err); end

  private

  def authorize_arguments(args, inputs); end
  def get_argument(name, context = T.unsafe(nil)); end
  def load_arguments(args); end

  class << self
    # Add an argument to this field's signature, but
    # also add some preparation hook methods which will be used for this argument
    def argument(*args, **kwargs, &block); end

    def broadcastable(new_broadcastable); end
    def broadcastable?; end

    # Specifies the complexity of the field. Defaults to `1`
    def complexity(new_complexity = T.unsafe(nil)); end

    # Registers new extension
    def extension(extension, **options); end

    def extensions; end

    # Additional info injected into {#resolve}
    def extras(new_extras = T.unsafe(nil)); end

    def field_options; end
    def has_max_page_size?; end

    # Get or set the `max_page_size:` which will be configured for fields using this resolver
    # (`nil` means "unlimited max page size".)
    def max_page_size(new_max_page_size = T.unsafe(nil)); end

    # If `true` (default), then the return type for this resolver will be nullable.
    # If `false`, then the return type is non-null.
    def null(allow_null = T.unsafe(nil)); end

    # Default `:resolve` set below.
    def resolve_method(new_method = T.unsafe(nil)); end

    # Call this method to get the return type of the field,
    # or use it as a configuration method to assign a return type
    # instead of generating one.
    # TODO unify with {#null}
    def type(new_type = T.unsafe(nil), null: T.unsafe(nil)); end

    # A non-normalized type configuration, without `null` applied
    def type_expr; end

    private

    def own_extensions; end
  end
end

# Adds `field(...)` helper to resolvers so that they can
# generate payload types.
#
# Or, an already-defined one can be attached with `payload_type(...)`.
module GraphQL::Schema::Resolver::HasPayloadType
  def field(*args, **kwargs, &block); end
  def field_class(new_class = T.unsafe(nil)); end

  # An object class to use for deriving return types
  def object_class(new_class = T.unsafe(nil)); end

  # Call this method to get the derived return type of the mutation,
  # or use it as a configuration method to assign a return type
  # instead of generating one.
  def payload_type(new_payload_type = T.unsafe(nil)); end

  # Call this method to get the derived return type of the mutation,
  # or use it as a configuration method to assign a return type
  # instead of generating one.
  def type(new_payload_type = T.unsafe(nil)); end

  # Call this method to get the derived return type of the mutation,
  # or use it as a configuration method to assign a return type
  # instead of generating one.
  def type_expr(new_payload_type = T.unsafe(nil)); end

  private

  # Build a subclass of {.object_class} based on `self`.
  # This value will be cached as `{.payload_type}`.
  # Override this hook to customize return type generation.
  def generate_payload_type; end
end

GraphQL::Schema::Resolver::HasPayloadType::NO_INTERFACES = T.let(T.unsafe(nil), Array)

class GraphQL::Schema::Scalar < ::GraphQL::Schema::Member
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::ValidatesInput
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL

  class << self
    def coerce_input(val, ctx); end
    def coerce_result(val, ctx); end
    def default_scalar(is_default = T.unsafe(nil)); end
    def default_scalar?; end
    def kind; end
    def specified_by_url(new_url = T.unsafe(nil)); end
    def validate_non_null_input(value, ctx); end
  end
end

# This class can be extended to create fields on your subscription root.
#
# It provides hooks for the different parts of the subscription lifecycle:
#
# - `#authorized?`: called before initial subscription and subsequent updates
# - `#subscribe`: called for the initial subscription
# - `#update`: called for subsequent update
#
# Also, `#unsubscribe` terminates the subscription.
class GraphQL::Schema::Subscription < ::GraphQL::Schema::Resolver
  extend ::GraphQL::Schema::Resolver::HasPayloadType
  extend ::GraphQL::Schema::Member::HasFields

  def initialize(object:, context:, field:); end

  # If an argument is flagged with `loads:` and no object is found for it,
  # remove this subscription (assuming that the object was deleted in the meantime,
  # or that it became inaccessible).
  def load_application_object_failed(err); end

  # Implement the {Resolve} API
  def resolve(**args); end

  # Wrap the user-defined `#subscribe` hook
  def resolve_subscribe(**args); end

  # Wrap the user-provided `#update` hook
  def resolve_update(**args); end

  def resolve_with_support(**args); end

  # The default implementation returns nothing on subscribe.
  # Override it to return an object or
  # `:no_response` to (explicitly) return nothing.
  def subscribe(args = T.unsafe(nil)); end

  # Call this to halt execution and remove this subscription from the system
  def unsubscribe; end

  # The default implementation returns the root object.
  # Override it to return {NO_UPDATE} if you want to
  # skip updates sometimes. Or override it to return a different object.
  def update(args = T.unsafe(nil)); end

  class << self
    # Overriding Resolver#field_options to include subscription_scope
    def field_options; end

    # Call this method to provide a new subscription_scope; OR
    # call it without an argument to get the subscription_scope
    def subscription_scope(new_scope = T.unsafe(nil), optional: T.unsafe(nil)); end

    def subscription_scope_optional?; end

    # This is called during initial subscription to get a "name" for this subscription.
    # Later, when `.trigger` is called, this will be called again to build another "name".
    # Any subscribers with matching topic will begin the update flow.
    #
    # The default implementation creates a string using the field name, subscription scope, and argument keys and values.
    # In that implementation, only `.trigger` calls with _exact matches_ result in updates to subscribers.
    #
    # To implement a filtered stream-type subscription flow, override this method to return a string with field name and subscription scope.
    # Then, implement {#update} to compare its arguments to the current `object` and return {NO_UPDATE} when an
    # update should be filtered out.
    def topic_for(arguments:, field:, scope:); end
  end
end

GraphQL::Schema::Subscription::NO_UPDATE = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Subscription::READING_SCOPE = T.let(T.unsafe(nil), Object)

# This plugin will stop resolving new fields after `max_seconds` have elapsed.
# After the time has passed, any remaining fields will be `nil`, with errors added
# to the `errors` key. Any already-resolved fields will be in the `data` key, so
# you'll get a partial response.
#
# You can subclass `GraphQL::Schema::Timeout` and override `max_seconds` and/or `handle_timeout`
# to provide custom logic when a timeout error occurs.
#
# Note that this will stop a query _in between_ field resolutions, but
# it doesn't interrupt long-running `resolve` functions. Be sure to use
# timeout options for external connections. For more info, see
# www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/
class GraphQL::Schema::Timeout
  def initialize(max_seconds:); end

  # Invoked when a query times out.
  def handle_timeout(error, query); end

  # Called at the start of each query.
  # The default implementation returns the `max_seconds:` value from installing this plugin.
  def max_seconds(query); end

  def trace(key, data); end

  class << self
    def use(schema, **options); end
  end
end

# This error is raised when a query exceeds `max_seconds`.
# Since it's a child of {GraphQL::ExecutionError},
# its message will be added to the response's `errors` key.
#
# To raise an error that will stop query resolution, use a custom block
# to take this error and raise a new one which _doesn't_ descend from {GraphQL::ExecutionError},
# such as `RuntimeError`.
class GraphQL::Schema::Timeout::TimeoutError < ::GraphQL::ExecutionError
  def initialize(parent_type, field); end
end

# This middleware will stop resolving new fields after `max_seconds` have elapsed.
# After the time has passed, any remaining fields will be `nil`, with errors added
# to the `errors` key. Any already-resolved fields will be in the `data` key, so
# you'll get a partial response.
#
# You can provide a block which will be called with any timeout errors that occur.
#
# Note that this will stop a query _in between_ field resolutions, but
# it doesn't interrupt long-running `resolve` functions. Be sure to use
# timeout options for external connections. For more info, see
# www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/
class GraphQL::Schema::TimeoutMiddleware
  def initialize(max_seconds:, context_key: T.unsafe(nil), &block); end

  def call(parent_type, parent_object, field_definition, field_args, query_context); end

  # This is called when a field _would_ be resolved, except that we're over the time limit.
  def on_timeout(parent_type, parent_object, field_definition, field_args, field_context); end
end

# This error is raised when a query exceeds `max_seconds`.
# Since it's a child of {GraphQL::ExecutionError},
# its message will be added to the response's `errors` key.
#
# To raise an error that will stop query resolution, use a custom block
# to take this error and raise a new one which _doesn't_ descend from {GraphQL::ExecutionError},
# such as `RuntimeError`.
class GraphQL::Schema::TimeoutMiddleware::TimeoutError < ::GraphQL::ExecutionError
  def initialize(parent_type, field_defn); end
end

# This behaves like {GraphQL::Query} but {#context} returns
# the _field-level_ context, not the query-level context.
# This means you can reliably get the `irep_node` and `path`
# from it after the fact.
class GraphQL::Schema::TimeoutMiddleware::TimeoutQueryProxy < ::SimpleDelegator
  def initialize(query, ctx); end

  def context; end
end

# Visit the members of this schema and build up artifacts for runtime.
class GraphQL::Schema::Traversal
  def initialize(schema, introspection: T.unsafe(nil)); end

  def instrumented_field_map; end
  def type_map; end
  def type_reference_map; end
  def union_memberships; end

  private

  # A brute-force appraoch to late binding.
  # Just keep trying the whole list, hoping that they
  # eventually all resolve.
  # This could be replaced with proper dependency tracking.
  def resolve_late_bound_fields; end

  # The late-bound type may be wrapped with list or non-null types.
  # Apply the same wrapping to the resolve type and
  # return the maybe-wrapped type
  def rewrap_resolved_type(late_bound_type, resolved_inner_type); end

  def validate_type(member, context_description); end
  def visit(schema, member, context_description); end
  def visit_field_on_type(schema, type_defn, field_defn, dynamic_field: T.unsafe(nil)); end
  def visit_fields(schema, type_defn); end
end

module GraphQL::Schema::TypeExpression
  class << self
    # Fetch a type from a type map by its AST specification.
    # Return `nil` if not found.
    def build_type(type_owner, ast_node); end

    private

    def wrap_type(type, wrapper_method); end
  end
end

# This class joins an object type to an abstract type (interface or union) of which
# it is a member.
class GraphQL::Schema::TypeMembership
  # Called when an object is hooked up to an abstract type, such as {Schema::Union.possible_types}
  # or {Schema::Object.implements} (for interfaces).
  def initialize(abstract_type, object_type, **options); end

  def abstract_type; end
  def graphql_name; end
  def inspect; end
  def object_type; end
  def object_type=(_arg0); end
  def path; end
  def type_class; end
  def visible?(ctx); end
end

class GraphQL::Schema::Union < ::GraphQL::Schema::Member
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::HasUnresolvedTypeError
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL

  class << self
    def all_possible_types; end

    # Update a type membership whose `.object_type` is a string or late-bound type
    # so that the type membership's `.object_type` is the given `object_type`.
    # (This is used for updating the union after the schema as lazily loaded the union member.)
    def assign_type_membership_object_type(object_type); end

    def inherited(child_class); end
    def kind; end
    def possible_types(*types, context: T.unsafe(nil), **options); end
    def type_membership_class(membership_class = T.unsafe(nil)); end
    def type_memberships; end

    private

    def assert_valid_union_member(type_defn); end
  end
end

module GraphQL::Schema::UniqueWithinType
  private

  def decode(node_id, separator: T.unsafe(nil)); end
  def encode(type_name, object_value, separator: T.unsafe(nil)); end

  class << self
    def decode(node_id, separator: T.unsafe(nil)); end

    # Returns the value of attribute default_id_separator.
    def default_id_separator; end

    # Sets the attribute default_id_separator
    def default_id_separator=(_arg0); end

    def encode(type_name, object_value, separator: T.unsafe(nil)); end
  end
end

class GraphQL::Schema::UnresolvedLateBoundTypeError < ::GraphQL::Error
  def initialize(type:); end

  # Returns the value of attribute type.
  def type; end
end

# This module provides a function for validating GraphQL types.
#
# Its {RULES} contain objects that respond to `#call(type)`. Rules are
# looked up for given types (by class ancestry), then applied to
# the object until an error is returned.
#
# Remove this in GraphQL-Ruby 2.0 when schema instances are removed.
class GraphQL::Schema::Validation
  class << self
    # Lookup the rules for `object` based on its class,
    # Then returns an error message or `nil`
    def validate(object); end
  end
end

# A mapping of `{Class => [Proc, Proc...]}` pairs.
# To validate an instance, find entries where `object.is_a?(key)` is true.
# Then apply each rule from the matching values.
GraphQL::Schema::Validation::RULES = T.let(T.unsafe(nil), Hash)

module GraphQL::Schema::Validation::Rules
  class << self
    def assert_named_items_are_valid(item_name, get_items_proc); end
    def assert_property(property_name, *allowed_classes); end
    def assert_property_list_of(property_name, list_member_class); end
    def assert_property_mapping(property_name, from_class, to_class); end
    def count_at_least(item_name, minimum_count, get_items_proc); end
  end
end

GraphQL::Schema::Validation::Rules::ARGUMENTS_ARE_STRING_TO_ARGUMENT = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::ARGUMENTS_ARE_VALID = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::DEFAULT_VALUE_IS_VALID_FOR_TYPE = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::DEPRECATED_ARGUMENTS_ARE_OPTIONAL = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::DESCRIPTION_IS_STRING_OR_NIL = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::FIELDS_ARE_VALID = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::HAS_AT_LEAST_ONE_ARGUMENT = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::HAS_AT_LEAST_ONE_FIELD = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::HAS_ONE_OR_MORE_POSSIBLE_TYPES = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::INTERFACES_ARE_IMPLEMENTED = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::NAME_IS_STRING = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::RESERVED_NAME = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::RESERVED_TYPE_NAME = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::SCHEMA_CAN_FETCH_IDS = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::SCHEMA_CAN_GENERATE_IDS = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::SCHEMA_CAN_RESOLVE_TYPES = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::SCHEMA_INSTRUMENTERS_ARE_VALID = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::TYPE_IS_VALID_INPUT_TYPE = T.let(T.unsafe(nil), Proc)

class GraphQL::Schema::Validator
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects

  def initialize(validated:, allow_blank: T.unsafe(nil), allow_null: T.unsafe(nil)); end

  # This is like `String#%`, but it supports the case that only some of `string`'s
  # values are present in `substitutions`
  def partial_format(string, substitutions); end

  def permitted_empty_value?(value); end
  def validate(object, context, value); end

  # The thing being validated
  def validated; end

  class << self
    # Returns the value of attribute all_validators.
    def all_validators; end

    # Sets the attribute all_validators
    def all_validators=(_arg0); end

    def from_config(schema_member, validates_hash); end

    # Add `validator_class` to be initialized when `validates:` is given `name`.
    # (It's initialized with whatever options are given by the key `name`).
    def install(name, validator_class); end

    # Remove whatever validator class is {.install}ed at `name`, if there is one
    def uninstall(name); end

    def validate!(validators, object, context, value, as: T.unsafe(nil)); end
  end
end

# Use this to specifically reject values that respond to `.blank?` and respond truthy for that method.
class GraphQL::Schema::Validator::AllowBlankValidator < ::GraphQL::Schema::Validator
  def initialize(allow_blank_positional, allow_blank: T.unsafe(nil), message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

# Use this to specifically reject or permit `nil` values (given as `null` from GraphQL).
class GraphQL::Schema::Validator::AllowNullValidator < ::GraphQL::Schema::Validator
  def initialize(allow_null_positional, allow_null: T.unsafe(nil), message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

GraphQL::Schema::Validator::AllowNullValidator::MESSAGE = T.let(T.unsafe(nil), String)

# Use this to specifically reject values from an argument.
class GraphQL::Schema::Validator::ExclusionValidator < ::GraphQL::Schema::Validator
  def initialize(in:, message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

# Use this to assert that string values match (or don't match) the given RegExp.
class GraphQL::Schema::Validator::FormatValidator < ::GraphQL::Schema::Validator
  def initialize(with: T.unsafe(nil), without: T.unsafe(nil), message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

# You can use this to allow certain values for an argument.
#
# Usually, a {GraphQL::Schema::Enum} is better for this, because it's self-documenting.
class GraphQL::Schema::Validator::InclusionValidator < ::GraphQL::Schema::Validator
  def initialize(in:, message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

# Use this to enforce a `.length` restriction on incoming values. It works for both Strings and Lists.
class GraphQL::Schema::Validator::LengthValidator < ::GraphQL::Schema::Validator
  def initialize(maximum: T.unsafe(nil), too_long: T.unsafe(nil), minimum: T.unsafe(nil), too_short: T.unsafe(nil), is: T.unsafe(nil), within: T.unsafe(nil), wrong_length: T.unsafe(nil), message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

# Use this to assert numerical comparisons hold true for inputs.
class GraphQL::Schema::Validator::NumericalityValidator < ::GraphQL::Schema::Validator
  def initialize(greater_than: T.unsafe(nil), greater_than_or_equal_to: T.unsafe(nil), less_than: T.unsafe(nil), less_than_or_equal_to: T.unsafe(nil), equal_to: T.unsafe(nil), other_than: T.unsafe(nil), odd: T.unsafe(nil), even: T.unsafe(nil), within: T.unsafe(nil), message: T.unsafe(nil), null_message: T.unsafe(nil), **default_options); end

  def validate(object, context, value); end
end

# Use this validator to require _one_ of the named arguments to be present.
# Or, use Arrays of symbols to name a valid _set_ of arguments.
#
# (This is for specifying mutually exclusive sets of arguments.)
class GraphQL::Schema::Validator::RequiredValidator < ::GraphQL::Schema::Validator
  def initialize(one_of: T.unsafe(nil), argument: T.unsafe(nil), message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

class GraphQL::Schema::Validator::ValidationFailedError < ::GraphQL::ExecutionError
  def initialize(errors:); end

  # Returns the value of attribute errors.
  def errors; end
end

# Restrict access to a {GraphQL::Schema} with a user-defined filter.
#
# When validating and executing a query, all access to schema members
# should go through a warden. If you access the schema directly,
# you may show a client something that it shouldn't be allowed to see.
class GraphQL::Schema::Warden
  def initialize(filter, context:, schema:); end

  def arguments(argument_owner); end
  def directives; end
  def enum_values(enum_defn); end
  def fields(type_defn); end
  def get_argument(parent_type, argument_name); end
  def get_field(parent_type, field_name); end
  def get_type(type_name); end
  def interfaces(obj_type); end
  def possible_types(type_defn); end
  def reachable_type?(type_name); end
  def reachable_types; end
  def root_type_for_operation(op_name); end
  def types; end
  def visible_argument?(arg_defn, _ctx = T.unsafe(nil)); end
  def visible_enum_value?(enum_value, _ctx = T.unsafe(nil)); end
  def visible_field?(field_defn, _ctx = T.unsafe(nil), owner = T.unsafe(nil)); end
  def visible_type?(type_defn, _ctx = T.unsafe(nil)); end
  def visible_type_membership?(type_membership, _ctx = T.unsafe(nil)); end

  private

  # If this field was inherited from an interface, and the field on that interface is _hidden_,
  # then treat this inherited field as hidden.
  # (If it _wasn't_ inherited, then don't hide it for this reason.)
  def field_on_visible_interface?(field_defn, type_defn); end

  def orphan_type?(type_defn); end
  def reachable_type_set; end
  def read_through; end
  def referenced?(type_defn); end
  def root_type?(type_defn); end

  # We need this to tell whether a field was inherited by an interface
  # even when that interface is hidden from `#interfaces`
  def unfiltered_interfaces(type_defn); end

  def union_memberships(obj_type); end
  def visible?(member); end
  def visible_abstract_type?(type_defn); end
  def visible_and_reachable_type?(type_defn); end
  def visible_possible_types?(type_defn); end

  class << self
    def from_context(context); end
    def visible_entry?(visibility_method, entry, context, warden = T.unsafe(nil)); end
  end
end

GraphQL::Schema::Warden::NO_REFERENCES = T.let(T.unsafe(nil), Array)

# This is used when a caller provides a Hash for context.
# We want to call the schema's hooks, but we don't have a full-blown warden.
# The `context` arguments to these methods exist purely to simplify the code that
# calls methods on this object, so it will have everything it needs.
class GraphQL::Schema::Warden::PassThruWarden
  class << self
    def visible_argument?(arg, ctx); end
    def visible_enum_value?(ev, ctx); end
    def visible_field?(field, ctx); end
    def visible_type?(type, ctx); end
    def visible_type_membership?(tm, ctx); end
  end
end

class GraphQL::Schema::Wrapper
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition
  include ::GraphQL::Schema::Member::TypeSystemHelpers

  def initialize(of_type); end

  def ==(other); end
  def of_type; end
  def to_graphql; end
  def unwrap; end
end

module GraphQL::StaticValidation; end

# Default rules for {GraphQL::StaticValidation::Validator}
#
# Order is important here. Some validators return {GraphQL::Language::Visitor::SKIP}
# which stops the visit on that node. That way it doesn't try to find fields on types that
# don't exist, etc.
GraphQL::StaticValidation::ALL_RULES = T.let(T.unsafe(nil), Array)

module GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  def on_argument(node, parent); end
end

class GraphQL::StaticValidation::ArgumentLiteralsAreCompatibleError < ::GraphQL::StaticValidation::Error
  def initialize(message, type:, path: T.unsafe(nil), nodes: T.unsafe(nil), argument_name: T.unsafe(nil), extensions: T.unsafe(nil), coerce_extensions: T.unsafe(nil), argument: T.unsafe(nil), value: T.unsafe(nil)); end

  # Returns the value of attribute argument.
  def argument; end

  # Returns the value of attribute argument_name.
  def argument_name; end

  def code; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end

  # Returns the value of attribute value.
  def value; end
end

module GraphQL::StaticValidation::ArgumentNamesAreUnique
  include ::GraphQL::StaticValidation::Error::ErrorHelper

  def on_directive(node, parent); end
  def on_field(node, parent); end
  def validate_arguments(node); end
end

class GraphQL::StaticValidation::ArgumentNamesAreUniqueError < ::GraphQL::StaticValidation::Error
  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute name.
  def name; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::ArgumentsAreDefined
  def on_argument(node, parent); end

  private

  def node_type(parent); end
  def parent_definition(parent); end

  # TODO smell: these methods are added to all visitors, since they're included in a module.
  def parent_name(parent, type_defn); end
end

class GraphQL::StaticValidation::ArgumentsAreDefinedError < ::GraphQL::StaticValidation::Error
  def initialize(message, name:, type:, argument_name:, parent:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  # Returns the value of attribute argument_name.
  def argument_name; end

  def code; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute parent.
  def parent; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end
end

class GraphQL::StaticValidation::BaseVisitor < ::GraphQL::Language::Visitor
  def initialize(document, context); end

  # Returns the value of attribute context.
  def context; end

  def object_types; end
  def path; end

  # This will be overwritten by {InternalRepresentation::Rewrite} if it's included
  def rewrite_document; end

  private

  def add_error(error, path: T.unsafe(nil)); end

  class << self
    # Build a class to visit the AST and perform validation,
    # or use a pre-built class if rules is `ALL_RULES` or empty.
    def including_rules(rules, rewrite: T.unsafe(nil)); end
  end
end

module GraphQL::StaticValidation::BaseVisitor::ContextMethods
  def argument_definition; end
  def directive_definition; end
  def field_definition; end
  def on_argument(node, parent); end
  def on_directive(node, parent); end
  def on_field(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end
  def on_input_object(node, parent); end
  def on_operation_definition(node, parent); end
  def parent_type_definition; end
  def type_definition; end

  private

  def on_fragment_with_type(node); end
  def push_type(t); end
end

class GraphQL::StaticValidation::DefaultVisitor < ::GraphQL::StaticValidation::BaseVisitor
  include ::GraphQL::StaticValidation::DefinitionDependencies
  include ::GraphQL::StaticValidation::InputObjectNamesAreUnique
  include ::GraphQL::StaticValidation::SubscriptionRootExists
  include ::GraphQL::StaticValidation::QueryRootExists
  include ::GraphQL::StaticValidation::MutationRootExists
  include ::GraphQL::StaticValidation::VariableUsagesAreAllowed
  include ::GraphQL::StaticValidation::VariablesAreUsedAndDefined
  include ::GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  include ::GraphQL::StaticValidation::VariablesAreInputTypes
  include ::GraphQL::StaticValidation::VariableNamesAreUnique
  include ::GraphQL::StaticValidation::Error::ErrorHelper
  include ::GraphQL::StaticValidation::ArgumentNamesAreUnique
  include ::GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
  include ::GraphQL::StaticValidation::RequiredArgumentsArePresent
  include ::GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  include ::GraphQL::StaticValidation::ArgumentsAreDefined
  include ::GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  include ::GraphQL::StaticValidation::FieldsWillMerge
  include ::GraphQL::StaticValidation::FieldsAreDefinedOnType
  include ::GraphQL::StaticValidation::FragmentSpreadsArePossible
  include ::GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  include ::GraphQL::StaticValidation::FragmentTypesExist
  include ::GraphQL::StaticValidation::FragmentsAreUsed
  include ::GraphQL::StaticValidation::FragmentsAreNamed
  include ::GraphQL::StaticValidation::FragmentsAreFinite
  include ::GraphQL::StaticValidation::FragmentNamesAreUnique
  include ::GraphQL::StaticValidation::OperationNamesAreValid
  include ::GraphQL::StaticValidation::UniqueDirectivesPerLocation
  include ::GraphQL::Language
  include ::GraphQL::StaticValidation::DirectivesAreInValidLocations
  include ::GraphQL::StaticValidation::DirectivesAreDefined
  include ::GraphQL::StaticValidation::NoDefinitionsArePresent
  include ::GraphQL::InternalRepresentation::Rewrite
  include ::GraphQL::StaticValidation::BaseVisitor::ContextMethods
end

# Track fragment dependencies for operations
# and expose the fragment definitions which
# are used by a given operation
module GraphQL::StaticValidation::DefinitionDependencies
  def initialize(*_arg0); end

  # Returns the value of attribute dependencies.
  def dependencies; end

  # A map of operation definitions to an array of that operation's dependencies
  def dependency_map(&block); end

  def on_document(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_operation_definition(node, prev_node); end

  private

  # Return a hash of { node => [node, node ... ]} pairs
  # Keys are top-level definitions
  # Values are arrays of flattened dependencies
  def resolve_dependencies; end
end

# Map definition AST nodes to the definition AST nodes they depend on.
# Expose circular dependencies.
class GraphQL::StaticValidation::DefinitionDependencies::DependencyMap
  def initialize; end

  def [](definition_node); end
  def cyclical_definitions; end
  def unmet_dependencies; end
  def unused_dependencies; end
end

class GraphQL::StaticValidation::DefinitionDependencies::NodeWithPath
  extend ::Forwardable

  def initialize(node, path); end

  def eql?(*args, &block); end
  def hash(*args, &block); end
  def name(*args, &block); end

  # Returns the value of attribute node.
  def node; end

  # Returns the value of attribute path.
  def path; end
end

module GraphQL::StaticValidation::DirectivesAreDefined
  def initialize(*_arg0); end

  def on_directive(node, parent); end
end

class GraphQL::StaticValidation::DirectivesAreDefinedError < ::GraphQL::StaticValidation::Error
  def initialize(message, directive:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute directive_name.
  def directive_name; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::DirectivesAreInValidLocations
  include ::GraphQL::Language

  def on_directive(node, parent); end

  private

  def assert_includes_location(directive_defn, directive_ast, required_location); end
  def validate_location(ast_directive, ast_parent, directives); end
end

GraphQL::StaticValidation::DirectivesAreInValidLocations::LOCATION_MESSAGE_NAMES = T.let(T.unsafe(nil), Hash)
GraphQL::StaticValidation::DirectivesAreInValidLocations::SIMPLE_LOCATIONS = T.let(T.unsafe(nil), Hash)
GraphQL::StaticValidation::DirectivesAreInValidLocations::SIMPLE_LOCATION_NODES = T.let(T.unsafe(nil), Array)

class GraphQL::StaticValidation::DirectivesAreInValidLocationsError < ::GraphQL::StaticValidation::Error
  def initialize(message, target:, path: T.unsafe(nil), nodes: T.unsafe(nil), name: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute target_name.
  def target_name; end

  # A hash representation of this Message
  def to_h; end
end

# Generates GraphQL-compliant validation message.
class GraphQL::StaticValidation::Error
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  # Returns the value of attribute message.
  def message; end

  # Returns the value of attribute path.
  def path; end

  # Sets the attribute path
  def path=(_arg0); end

  # A hash representation of this Message
  def to_h; end

  private

  def locations; end

  # Returns the value of attribute nodes.
  def nodes; end
end

# Convenience for validators
module GraphQL::StaticValidation::Error::ErrorHelper
  # Error `error_message` is located at `node`
  def error(error_message, nodes, context: T.unsafe(nil), path: T.unsafe(nil), extensions: T.unsafe(nil)); end
end

module GraphQL::StaticValidation::FieldsAreDefinedOnType
  def on_field(node, parent); end
end

class GraphQL::StaticValidation::FieldsAreDefinedOnTypeError < ::GraphQL::StaticValidation::Error
  def initialize(message, type:, field:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute field_name.
  def field_name; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end
end

# Scalars _can't_ have selections
# Objects _must_ have selections
module GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  include ::GraphQL::StaticValidation::Error::ErrorHelper

  def on_field(node, parent); end
  def on_operation_definition(node, _parent); end

  private

  def validate_field_selections(ast_node, resolved_type); end
end

class GraphQL::StaticValidation::FieldsHaveAppropriateSelectionsError < ::GraphQL::StaticValidation::Error
  def initialize(message, node_name:, path: T.unsafe(nil), nodes: T.unsafe(nil), type: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute node_name.
  def node_name; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end
end

module GraphQL::StaticValidation::FieldsWillMerge
  def initialize(*_arg0); end

  def on_field(node, _parent); end
  def on_operation_definition(node, _parent); end

  private

  def arg_conflicts; end
  def compared_fragments_key(frag1, frag2, exclusive); end
  def conflicts_within_selection_set(node, parent_type); end
  def field_conflicts; end
  def fields_and_fragments_from_selection(node, owner_type:, parents:); end
  def find_conflict(response_key, field1, field2, mutually_exclusive: T.unsafe(nil)); end
  def find_conflicts_between(response_keys, response_keys2, mutually_exclusive:); end
  def find_conflicts_between_fields_and_fragment(fragment_spread, fields, mutually_exclusive:); end
  def find_conflicts_between_fragments(fragment_spread1, fragment_spread2, mutually_exclusive:); end
  def find_conflicts_between_sub_selection_sets(field1, field2, mutually_exclusive:); end
  def find_conflicts_within(response_keys); end
  def find_fields_and_fragments(selections, owner_type:, parents:, fields:, fragment_spreads:); end

  # Given two list of parents, find out if they are mutually exclusive
  # In this context, `parents` represends the "self scope" of the field,
  # what types may be found at this point in the query.
  def mutually_exclusive?(parents1, parents2); end

  def same_arguments?(field1, field2); end
  def serialize_arg(arg_value); end
  def serialize_field_args(field); end
  def setting_errors; end
end

class GraphQL::StaticValidation::FieldsWillMerge::Field < ::Struct
  # Returns the value of attribute definition
  def definition; end

  # Sets the attribute definition
  def definition=(_); end

  # Returns the value of attribute node
  def node; end

  # Sets the attribute node
  def node=(_); end

  # Returns the value of attribute owner_type
  def owner_type; end

  # Sets the attribute owner_type
  def owner_type=(_); end

  # Returns the value of attribute parents
  def parents; end

  # Sets the attribute parents
  def parents=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class GraphQL::StaticValidation::FieldsWillMerge::FragmentSpread < ::Struct
  # Returns the value of attribute name
  def name; end

  # Sets the attribute name
  def name=(_); end

  # Returns the value of attribute parents
  def parents; end

  # Sets the attribute parents
  def parents=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# Validates that a selection set is valid if all fields (including spreading any
# fragments) either correspond to distinct response names or can be merged
# without ambiguity.
#
# Original Algorithm: https://github.com/graphql/graphql-js/blob/master/src/validation/rules/OverlappingFieldsCanBeMerged.js
GraphQL::StaticValidation::FieldsWillMerge::NO_ARGS = T.let(T.unsafe(nil), Hash)

GraphQL::StaticValidation::FieldsWillMerge::NO_SELECTIONS = T.let(T.unsafe(nil), Array)

class GraphQL::StaticValidation::FieldsWillMergeError < ::GraphQL::StaticValidation::Error
  def initialize(kind:, field_name:); end

  def add_conflict(node, conflict_str); end
  def code; end
  def conflicts; end

  # Returns the value of attribute field_name.
  def field_name; end

  # Returns the value of attribute kind.
  def kind; end

  def message; end
  def path; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::FragmentNamesAreUnique
  def initialize(*_arg0); end

  def on_document(_n, _p); end
  def on_fragment_definition(node, parent); end
end

class GraphQL::StaticValidation::FragmentNamesAreUniqueError < ::GraphQL::StaticValidation::Error
  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute fragment_name.
  def fragment_name; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::FragmentSpreadsArePossible
  def initialize(*_arg0); end

  def on_document(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end

  private

  def validate_fragment_in_scope(parent_type, child_type, node, context, path); end
end

class GraphQL::StaticValidation::FragmentSpreadsArePossible::FragmentSpread
  def initialize(node:, parent_type:, path:); end

  # Returns the value of attribute node.
  def node; end

  # Returns the value of attribute parent_type.
  def parent_type; end

  # Returns the value of attribute path.
  def path; end
end

class GraphQL::StaticValidation::FragmentSpreadsArePossibleError < ::GraphQL::StaticValidation::Error
  def initialize(message, type:, fragment_name:, parent:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute fragment_name.
  def fragment_name; end

  # Returns the value of attribute parent_name.
  def parent_name; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end
end

module GraphQL::StaticValidation::FragmentTypesExist
  def on_fragment_definition(node, _parent); end
  def on_inline_fragment(node, _parent); end

  private

  def validate_type_exists(fragment_node); end
end

class GraphQL::StaticValidation::FragmentTypesExistError < ::GraphQL::StaticValidation::Error
  def initialize(message, type:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end
end

module GraphQL::StaticValidation::FragmentsAreFinite
  def on_document(_n, _p); end
end

class GraphQL::StaticValidation::FragmentsAreFiniteError < ::GraphQL::StaticValidation::Error
  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute fragment_name.
  def fragment_name; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::FragmentsAreNamed
  def on_fragment_definition(node, _parent); end
end

class GraphQL::StaticValidation::FragmentsAreNamedError < ::GraphQL::StaticValidation::Error
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  def on_fragment_definition(node, parent); end
  def on_inline_fragment(node, parent); end

  private

  def validate_type_is_composite(node); end
end

class GraphQL::StaticValidation::FragmentsAreOnCompositeTypesError < ::GraphQL::StaticValidation::Error
  def initialize(message, type:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  # Returns the value of attribute argument_name.
  def argument_name; end

  def code; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end
end

module GraphQL::StaticValidation::FragmentsAreUsed
  def on_document(node, parent); end
end

class GraphQL::StaticValidation::FragmentsAreUsedError < ::GraphQL::StaticValidation::Error
  def initialize(message, fragment:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute fragment_name.
  def fragment_name; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::InputObjectNamesAreUnique
  def on_input_object(node, parent); end

  private

  def validate_input_fields(node); end
end

class GraphQL::StaticValidation::InputObjectNamesAreUniqueError < ::GraphQL::StaticValidation::Error
  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute name.
  def name; end

  # A hash representation of this Message
  def to_h; end
end

class GraphQL::StaticValidation::InterpreterVisitor < ::GraphQL::StaticValidation::BaseVisitor
  include ::GraphQL::StaticValidation::DefinitionDependencies
  include ::GraphQL::StaticValidation::InputObjectNamesAreUnique
  include ::GraphQL::StaticValidation::SubscriptionRootExists
  include ::GraphQL::StaticValidation::QueryRootExists
  include ::GraphQL::StaticValidation::MutationRootExists
  include ::GraphQL::StaticValidation::VariableUsagesAreAllowed
  include ::GraphQL::StaticValidation::VariablesAreUsedAndDefined
  include ::GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  include ::GraphQL::StaticValidation::VariablesAreInputTypes
  include ::GraphQL::StaticValidation::VariableNamesAreUnique
  include ::GraphQL::StaticValidation::Error::ErrorHelper
  include ::GraphQL::StaticValidation::ArgumentNamesAreUnique
  include ::GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
  include ::GraphQL::StaticValidation::RequiredArgumentsArePresent
  include ::GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  include ::GraphQL::StaticValidation::ArgumentsAreDefined
  include ::GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  include ::GraphQL::StaticValidation::FieldsWillMerge
  include ::GraphQL::StaticValidation::FieldsAreDefinedOnType
  include ::GraphQL::StaticValidation::FragmentSpreadsArePossible
  include ::GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  include ::GraphQL::StaticValidation::FragmentTypesExist
  include ::GraphQL::StaticValidation::FragmentsAreUsed
  include ::GraphQL::StaticValidation::FragmentsAreNamed
  include ::GraphQL::StaticValidation::FragmentsAreFinite
  include ::GraphQL::StaticValidation::FragmentNamesAreUnique
  include ::GraphQL::StaticValidation::OperationNamesAreValid
  include ::GraphQL::StaticValidation::UniqueDirectivesPerLocation
  include ::GraphQL::Language
  include ::GraphQL::StaticValidation::DirectivesAreInValidLocations
  include ::GraphQL::StaticValidation::DirectivesAreDefined
  include ::GraphQL::StaticValidation::NoDefinitionsArePresent
  include ::GraphQL::StaticValidation::BaseVisitor::ContextMethods
end

# Test whether `ast_value` is a valid input for `type`
class GraphQL::StaticValidation::LiteralValidator
  def initialize(context:); end

  def validate(ast_value, type); end

  private

  # The GraphQL grammar supports variables embedded within scalars but graphql.js
  # doesn't support it so we won't either for simplicity
  def constant_scalar?(ast_value); end

  def ensure_array(value); end

  # When `error_bubbling` is false, we want to bail on the first failure that we find.
  # Use `throw` to escape the current call stack, returning the invalid response.
  def maybe_raise_if_invalid(ast_value); end

  def merge_results(results_list); end
  def present_input_field_values_are_valid(type, ast_node); end
  def recursively_validate(ast_value, type); end
  def required_input_fields_are_present(type, ast_node); end
end

module GraphQL::StaticValidation::MutationRootExists
  def on_operation_definition(node, _parent); end
end

class GraphQL::StaticValidation::MutationRootExistsError < ::GraphQL::StaticValidation::Error
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::NoDefinitionsArePresent
  include ::GraphQL::StaticValidation::Error::ErrorHelper

  def initialize(*_arg0); end

  def on_directive_definition(node, parent); end
  def on_document(node, parent); end
  def on_enum_type_definition(node, parent); end
  def on_enum_type_extension(node, parent); end
  def on_input_object_type_definition(node, parent); end
  def on_input_object_type_extension(node, parent); end
  def on_interface_type_definition(node, parent); end
  def on_interface_type_extension(node, parent); end
  def on_invalid_node(node, parent); end
  def on_object_type_definition(node, parent); end
  def on_object_type_extension(node, parent); end
  def on_scalar_type_definition(node, parent); end
  def on_scalar_type_extension(node, parent); end
  def on_schema_definition(node, parent); end
  def on_schema_extension(node, parent); end
  def on_union_type_definition(node, parent); end
  def on_union_type_extension(node, parent); end
end

class GraphQL::StaticValidation::NoDefinitionsArePresentError < ::GraphQL::StaticValidation::Error
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end
end

class GraphQL::StaticValidation::NoValidateVisitor < ::GraphQL::StaticValidation::BaseVisitor
  include ::GraphQL::Language
  include ::GraphQL::InternalRepresentation::Rewrite
  include ::GraphQL::StaticValidation::DefinitionDependencies
  include ::GraphQL::StaticValidation::BaseVisitor::ContextMethods
end

module GraphQL::StaticValidation::OperationNamesAreValid
  def initialize(*_arg0); end

  def on_document(node, parent); end
  def on_operation_definition(node, parent); end
end

class GraphQL::StaticValidation::OperationNamesAreValidError < ::GraphQL::StaticValidation::Error
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil), name: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute operation_name.
  def operation_name; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::QueryRootExists
  def on_operation_definition(node, _parent); end
end

class GraphQL::StaticValidation::QueryRootExistsError < ::GraphQL::StaticValidation::Error
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::RequiredArgumentsArePresent
  def on_directive(node, _parent); end
  def on_field(node, _parent); end

  private

  def assert_required_args(ast_node, defn); end
end

class GraphQL::StaticValidation::RequiredArgumentsArePresentError < ::GraphQL::StaticValidation::Error
  def initialize(message, class_name:, name:, arguments:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  # Returns the value of attribute arguments.
  def arguments; end

  # Returns the value of attribute class_name.
  def class_name; end

  def code; end

  # Returns the value of attribute name.
  def name; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
  def on_input_object(node, parent); end

  private

  def get_parent_type(context, parent); end
  def validate_input_object(ast_node, context, parent); end
end

class GraphQL::StaticValidation::RequiredInputObjectAttributesArePresentError < ::GraphQL::StaticValidation::Error
  def initialize(message, path:, nodes:, argument_type:, argument_name:, input_object_type:); end

  # Returns the value of attribute argument_name.
  def argument_name; end

  # Returns the value of attribute argument_type.
  def argument_type; end

  def code; end

  # Returns the value of attribute input_object_type.
  def input_object_type; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::SubscriptionRootExists
  def on_operation_definition(node, _parent); end
end

class GraphQL::StaticValidation::SubscriptionRootExistsError < ::GraphQL::StaticValidation::Error
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end
end

# - Ride along with `GraphQL::Language::Visitor`
# - Track type info, expose it to validators
class GraphQL::StaticValidation::TypeStack
  def initialize(schema, visitor); end

  def argument_definitions; end

  # Directives are pushed on, then popped off while traversing the tree
  def directive_definitions; end

  # When it enters a field, it's pushed on this stack (useful for nested fields, args).
  # When it exits, it's popped off.
  def field_definitions; end

  # When it enters an object (starting with query or mutation root), it's pushed on this stack.
  # When it exits, it's popped off.
  def object_types; end

  def path; end
  def schema; end
end

module GraphQL::StaticValidation::TypeStack::ArgumentStrategy
  private

  def pop(stack, node); end

  # Push `argument_defn` onto the stack.
  # It's possible that `argument_defn` will be nil.
  # Push it anyways so `pop` has something to pop.
  def push(stack, node); end

  class << self
    def pop(stack, node); end

    # Push `argument_defn` onto the stack.
    # It's possible that `argument_defn` will be nil.
    # Push it anyways so `pop` has something to pop.
    def push(stack, node); end
  end
end

module GraphQL::StaticValidation::TypeStack::DirectiveStrategy
  private

  def pop(stack, node); end
  def push(stack, node); end

  class << self
    def pop(stack, node); end
    def push(stack, node); end
  end
end

class GraphQL::StaticValidation::TypeStack::EnterWithStrategy
  def initialize(stack, strategy); end

  def call(node, parent); end
end

module GraphQL::StaticValidation::TypeStack::FieldStrategy
  private

  def pop(stack, node); end
  def push(stack, node); end

  class << self
    def pop(stack, node); end
    def push(stack, node); end
  end
end

module GraphQL::StaticValidation::TypeStack::FragmentDefinitionStrategy
  extend ::GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy

  private

  def push_path_member(stack, node); end

  class << self
    def push_path_member(stack, node); end
  end
end

module GraphQL::StaticValidation::TypeStack::FragmentSpreadStrategy
  private

  def pop(stack, node); end
  def push(stack, node); end

  class << self
    def pop(stack, node); end
    def push(stack, node); end
  end
end

module GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy
  def pop(stack, node); end
  def push(stack, node); end
end

module GraphQL::StaticValidation::TypeStack::InlineFragmentStrategy
  extend ::GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy

  private

  def push_path_member(stack, node); end

  class << self
    def push_path_member(stack, node); end
  end
end

class GraphQL::StaticValidation::TypeStack::LeaveWithStrategy
  def initialize(stack, strategy); end

  def call(node, parent); end
end

module GraphQL::StaticValidation::TypeStack::OperationDefinitionStrategy
  private

  def pop(stack, node); end
  def push(stack, node); end

  class << self
    def pop(stack, node); end
    def push(stack, node); end
  end
end

GraphQL::StaticValidation::TypeStack::PUSH_STRATEGIES = T.let(T.unsafe(nil), Hash)

# These are jumping-off points for infering types down the tree
GraphQL::StaticValidation::TypeStack::TYPE_INFERRENCE_ROOTS = T.let(T.unsafe(nil), Array)

module GraphQL::StaticValidation::UniqueDirectivesPerLocation
  def on_enum_type_definition(node, parent); end
  def on_enum_value_definition(node, parent); end
  def on_field(node, parent); end
  def on_field_definition(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end
  def on_input_object_type_definition(node, parent); end
  def on_input_value_definition(node, parent); end
  def on_interface_type_definition(node, parent); end
  def on_object_type_definition(node, parent); end
  def on_operation_definition(node, parent); end
  def on_scalar_type_definition(node, parent); end
  def on_union_type_definition(node, parent); end

  private

  def validate_directive_location(node); end
end

GraphQL::StaticValidation::UniqueDirectivesPerLocation::DIRECTIVE_NODE_HOOKS = T.let(T.unsafe(nil), Array)

class GraphQL::StaticValidation::UniqueDirectivesPerLocationError < ::GraphQL::StaticValidation::Error
  def initialize(message, directive:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute directive_name.
  def directive_name; end

  # A hash representation of this Message
  def to_h; end
end

# The validation context gets passed to each validator.
#
# It exposes a {GraphQL::Language::Visitor} where validators may add hooks. ({Language::Visitor#visit} is called in {Validator#validate})
#
# It provides access to the schema & fragments which validators may read from.
#
# It holds a list of errors which each validator may add to.
#
# It also provides limited access to the {TypeStack} instance,
# which tracks state as you climb in and out of different fields.
class GraphQL::StaticValidation::ValidationContext
  extend ::Forwardable

  def initialize(query, visitor_class, max_errors); end

  def argument_definition(*args, &block); end
  def dependencies(*args, &block); end
  def directive_definition(*args, &block); end
  def document(*args, &block); end

  # Returns the value of attribute errors.
  def errors; end

  def field_definition(*args, &block); end
  def fragments(*args, &block); end

  # Returns the value of attribute max_errors.
  def max_errors; end

  def object_types(*args, &block); end
  def on_dependency_resolve(&handler); end

  # Returns the value of attribute on_dependency_resolve_handlers.
  def on_dependency_resolve_handlers; end

  def operations(*args, &block); end
  def parent_type_definition(*args, &block); end
  def path(*args, &block); end

  # Returns the value of attribute query.
  def query; end

  def schema(*args, &block); end
  def schema_directives; end
  def too_many_errors?; end
  def type_definition(*args, &block); end
  def validate_literal(ast_value, type); end

  # Returns the value of attribute visitor.
  def visitor; end

  def warden(*args, &block); end
end

class GraphQL::StaticValidation::ValidationTimeoutError < ::GraphQL::StaticValidation::Error
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end
end

# Initialized with a {GraphQL::Schema}, then it can validate {GraphQL::Language::Nodes::Documents}s based on that schema.
#
# By default, it's used by {GraphQL::Query}
class GraphQL::StaticValidation::Validator
  def initialize(schema:, rules: T.unsafe(nil)); end

  # Invoked when static validation times out.
  def handle_timeout(query, context); end

  # Validate `query` against the schema. Returns an array of message hashes.
  def validate(query, validate: T.unsafe(nil), timeout: T.unsafe(nil), max_errors: T.unsafe(nil)); end
end

module GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  def on_variable_definition(node, parent); end
end

class GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTypedError < ::GraphQL::StaticValidation::Error
  def initialize(message, name:, error_type:, path: T.unsafe(nil), nodes: T.unsafe(nil), type: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end

  # Returns the value of attribute variable_name.
  def variable_name; end

  # Returns the value of attribute violation.
  def violation; end
end

GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTypedError::VIOLATIONS = T.let(T.unsafe(nil), Hash)

module GraphQL::StaticValidation::VariableNamesAreUnique
  def on_operation_definition(node, parent); end
end

class GraphQL::StaticValidation::VariableNamesAreUniqueError < ::GraphQL::StaticValidation::Error
  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute variable_name.
  def variable_name; end
end

module GraphQL::StaticValidation::VariableUsagesAreAllowed
  def initialize(*_arg0); end

  def on_argument(node, parent); end
  def on_operation_definition(node, parent); end

  private

  def create_error(error_message, var_type, ast_var, arg_defn, arg_node); end
  def depth_of_array(array); end
  def list_dimension(type); end
  def non_null_levels_match(arg_type, var_type); end
  def validate_usage(argument_owner, arg_node, ast_var); end
  def wrap_var_type_with_depth_of_arg(var_type, arg_node); end
end

class GraphQL::StaticValidation::VariableUsagesAreAllowedError < ::GraphQL::StaticValidation::Error
  def initialize(message, type:, name:, argument:, error:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  # Returns the value of attribute argument_name.
  def argument_name; end

  def code; end

  # Returns the value of attribute error_message.
  def error_message; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end

  # Returns the value of attribute variable_name.
  def variable_name; end
end

module GraphQL::StaticValidation::VariablesAreInputTypes
  def on_variable_definition(node, parent); end

  private

  def get_type_name(ast_type); end
end

class GraphQL::StaticValidation::VariablesAreInputTypesError < ::GraphQL::StaticValidation::Error
  def initialize(message, type:, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end

  # Returns the value of attribute variable_name.
  def variable_name; end
end

# The problem is
# - Variable $usage must be determined at the OperationDefinition level
# - You can't tell how fragments use variables until you visit FragmentDefinitions (which may be at the end of the document)
#
# So, this validator includes some crazy logic to follow fragment spreads recursively, while avoiding infinite loops.
#
# `graphql-js` solves this problem by:
# - re-visiting the AST for each validator
# - allowing validators to say `followSpreads: true`
module GraphQL::StaticValidation::VariablesAreUsedAndDefined
  def initialize(*_arg0); end

  def on_document(node, parent); end
  def on_fragment_definition(node, parent); end

  # For FragmentSpreads:
  # - find the context on the stack
  # - mark the context as containing this spread
  def on_fragment_spread(node, parent); end

  def on_operation_definition(node, parent); end

  # For VariableIdentifiers:
  # - mark the variable as used
  # - assign its AST node
  def on_variable_identifier(node, parent); end

  private

  # Determine all the error messages,
  # Then push messages into the validation context
  def create_errors(node_variables); end

  # Follow spreads in `node`, looking them up from `spreads_for_context` and finding their match in `fragment_definitions`.
  # Use those fragments to update {VariableUsage}s in `parent_variables`.
  # Avoid infinite loops by skipping anything in `visited_fragments`.
  def follow_spreads(node, parent_variables, spreads_for_context, fragment_definitions, visited_fragments); end
end

class GraphQL::StaticValidation::VariablesAreUsedAndDefined::VariableUsage
  # Returns the value of attribute ast_node.
  def ast_node; end

  # Sets the attribute ast_node
  def ast_node=(_arg0); end

  def declared?; end

  # Returns the value of attribute declared_by.
  def declared_by; end

  # Sets the attribute declared_by
  def declared_by=(_arg0); end

  # Returns the value of attribute path.
  def path; end

  # Sets the attribute path
  def path=(_arg0); end

  def used?; end

  # Returns the value of attribute used_by.
  def used_by; end

  # Sets the attribute used_by
  def used_by=(_arg0); end
end

class GraphQL::StaticValidation::VariablesAreUsedAndDefinedError < ::GraphQL::StaticValidation::Error
  def initialize(message, name:, error_type:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute variable_name.
  def variable_name; end

  # Returns the value of attribute violation.
  def violation; end
end

GraphQL::StaticValidation::VariablesAreUsedAndDefinedError::VIOLATIONS = T.let(T.unsafe(nil), Hash)

class GraphQL::StringEncodingError < ::GraphQL::RuntimeTypeError
  def initialize(str, context:); end

  # Returns the value of attribute field.
  def field; end

  # Returns the value of attribute path.
  def path; end

  # Returns the value of attribute string.
  def string; end
end

class GraphQL::Subscriptions
  def initialize(schema:, broadcast: T.unsafe(nil), default_broadcastable: T.unsafe(nil), **rest); end

  def broadcastable?(query_str, **query_options); end
  def build_id; end
  def default_broadcastable; end

  # A subscription was terminated server-side.
  # Clean up the database.
  def delete_subscription(subscription_id); end

  # A subscription query was re-evaluated, returning `result`.
  # The result should be send to `subscription_id`.
  def deliver(subscription_id, result); end

  # Run the update query for this subscription and deliver it
  def execute(subscription_id, event, object); end

  # Event `event` occurred on `object`,
  # Update all subscribers.
  def execute_all(event, object); end

  # `event` was triggered on `object`, and `subscription_id` was subscribed,
  # so it should be updated.
  #
  # Load `subscription_id`'s GraphQL data, re-evaluate the query and return the result.
  def execute_update(subscription_id, event, object); end

  # Convert a user-provided event name or argument
  # to the equivalent in GraphQL.
  #
  # By default, it converts the identifier to camelcase.
  # Override this in a subclass to change the transformation.
  def normalize_name(event_or_arg_name); end

  # The system wants to send an update to this subscription.
  # Read its data and return it.
  def read_subscription(subscription_id); end

  # Fetch subscriptions matching this field + arguments pair
  # And pass them off to the queue.
  def trigger(event_name, args, object, scope: T.unsafe(nil)); end

  # `query` was executed and found subscriptions to `events`.
  # Update the database to reflect this new state.
  def write_subscription(query, events); end

  private

  # Recursively normalize `args` as belonging to `arg_owner`:
  # - convert symbols to strings,
  # - if needed, camelize the string (using {#normalize_name})
  def normalize_arguments(event_name, arg_owner, args, context); end

  class << self
    def use(defn, options = T.unsafe(nil)); end
  end
end

# A subscriptions implementation that sends data
# as ActionCable broadcastings.
#
# Some things to keep in mind:
#
# - No queueing system; ActiveJob should be added
# - Take care to reload context when re-delivering the subscription. (see {Query#subscription_update?})
# - Avoid the async ActionCable adapter and use the redis or PostgreSQL adapters instead. Otherwise calling #trigger won't work from background jobs or the Rails console.
class GraphQL::Subscriptions::ActionCableSubscriptions < ::GraphQL::Subscriptions
  def initialize(serializer: T.unsafe(nil), namespace: T.unsafe(nil), action_cable: T.unsafe(nil), action_cable_coder: T.unsafe(nil), **rest); end

  # The channel was closed, forget about it.
  def delete_subscription(subscription_id); end

  # This subscription was re-evaluated.
  # Send it to the specific stream where this client was waiting.
  def deliver(subscription_id, result); end

  # An event was triggered; Push the data over ActionCable.
  # Subscribers will re-evaluate locally.
  def execute_all(event, object); end

  # This is called to turn an ActionCable-broadcasted string (JSON)
  # into a query-ready application object.
  def load_action_cable_message(message, context); end

  # Return the query from "storage" (in memory)
  def read_subscription(subscription_id); end

  # Every subscribing channel is listening here, but only one of them takes any action.
  # This is so we can reuse payloads when possible, and make one payload to send to
  # all subscribers.
  #
  # But the problem is, any channel could close at any time, so each channel has to
  # be ready to take over the primary position.
  #
  # To make sure there's always one-and-only-one channel building payloads,
  # let the listener belonging to the first event on the list be
  # the one to build and publish payloads.
  def setup_stream(channel, initial_event); end

  # A query was run where these events were subscribed to.
  # Store them in memory in _this_ ActionCable frontend.
  # It will receive notifications when events come in
  # and re-evaluate the query locally.
  def write_subscription(query, events); end

  private

  def stream_event_name(event); end
  def stream_subscription_name(subscription_id); end
end

GraphQL::Subscriptions::ActionCableSubscriptions::EVENT_PREFIX = T.let(T.unsafe(nil), String)
GraphQL::Subscriptions::ActionCableSubscriptions::SUBSCRIPTION_PREFIX = T.let(T.unsafe(nil), String)

# Detect whether the current operation:
# - Is a subscription operation
# - Is completely broadcastable
#
# Assign the result to `context.namespace(:subscriptions)[:subscription_broadcastable]`
class GraphQL::Subscriptions::BroadcastAnalyzer < ::GraphQL::Analysis::AST::Analyzer
  def initialize(subject); end

  # Only analyze subscription operations
  def analyze?; end

  def on_enter_field(node, parent, visitor); end

  # Assign the result to context.
  # (This method is allowed to return an error, but we don't need to)
  def result; end

  private

  # Modify `@subscription_broadcastable` based on `field_defn`'s configuration (and/or the default value)
  def apply_broadcastable(field_defn); end
end

class GraphQL::Subscriptions::DefaultSubscriptionResolveExtension < ::GraphQL::Subscriptions::SubscriptionRoot::Extension
  def resolve(context:, object:, arguments:); end
end

# This thing can be:
# - Subscribed to by `subscription { ... }`
# - Triggered by `MySchema.subscriber.trigger(name, arguments, obj)`
class GraphQL::Subscriptions::Event
  def initialize(name:, arguments:, field: T.unsafe(nil), context: T.unsafe(nil), scope: T.unsafe(nil)); end

  def arguments; end
  def context; end
  def fingerprint; end
  def name; end
  def topic; end

  class << self
    def serialize(_name, arguments, field, scope:, context: T.unsafe(nil)); end

    private

    def deep_sort_array_hashes(array_to_inspect); end

    # This method does not support cyclic references in the Hash,
    # nor does it support Hashes whose keys are not sortable
    # with respect to their peers ( cases where a <=> b might throw an error )
    def deep_sort_hash_keys(hash_to_sort); end

    def get_arg_definition(arg_owner, arg_name, context); end
    def stringify_args(arg_owner, args, context); end
  end
end

# Wrap the root fields of the subscription type with special logic for:
# - Registering the subscription during the first execution
# - Evaluating the triggered portion(s) of the subscription during later execution
class GraphQL::Subscriptions::Instrumentation
  def initialize(schema:); end

  # After checking the root fields, pass the gathered events to the store
  def after_query(query); end

  # If needed, prepare to gather events which this query subscribes to
  def before_query(query); end

  def instrument(type, field); end
end

class GraphQL::Subscriptions::Instrumentation::SubscriptionRegistrationResolve
  def initialize(inner_proc); end

  # Wrap the proc with subscription registration logic
  def call(obj, args, ctx); end
end

# Raised when either:
# - the triggered `event_name` doesn't match a field in the schema; or
# - one or more arguments don't match the field arguments
class GraphQL::Subscriptions::InvalidTriggerError < ::GraphQL::Error; end

# Serialization helpers for passing subscription data around.
module GraphQL::Subscriptions::Serialize
  private

  def dump(obj); end

  # This is for turning objects into subscription scopes.
  # It's a one-way transformation, can't reload this :'(
  def dump_recursive(obj); end

  def load(str); end

  class << self
    def dump(obj); end

    # This is for turning objects into subscription scopes.
    # It's a one-way transformation, can't reload this :'(
    def dump_recursive(obj); end

    def load(str); end

    private

    def dump_value(obj); end
    def load_value(value); end
  end
end

GraphQL::Subscriptions::Serialize::GLOBALID_KEY = T.let(T.unsafe(nil), String)
GraphQL::Subscriptions::Serialize::OPEN_STRUCT_KEY = T.let(T.unsafe(nil), String)
GraphQL::Subscriptions::Serialize::SYMBOL_KEY = T.let(T.unsafe(nil), String)
GraphQL::Subscriptions::Serialize::SYMBOL_KEYS_KEY = T.let(T.unsafe(nil), String)

# eg '2020-01-01 23:59:59.123456789+05:00'
GraphQL::Subscriptions::Serialize::TIMESTAMP_FORMAT = T.let(T.unsafe(nil), String)

GraphQL::Subscriptions::Serialize::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)

module GraphQL::Subscriptions::SubscriptionRoot
  def field(*args, extensions: T.unsafe(nil), **rest, &block); end

  class << self
    def extended(child_cls); end
  end
end

class GraphQL::Subscriptions::SubscriptionRoot::Extension < ::GraphQL::Schema::FieldExtension
  def after_resolve(value:, context:, object:, arguments:, **rest); end

  private

  def arguments_without_field_extras(arguments:); end
end

# This is for maintaining backwards compatibility:
# if a subscription field is created without a `subscription:` resolver class,
# then implement the method with the previous default behavior.
module GraphQL::Subscriptions::SubscriptionRoot::InstanceMethods
  def skip_subscription_root(*_arg0); end
end

# Raised when either:
# - An initial subscription didn't have a value for `context[subscription_scope]`
# - Or, an update didn't pass `.trigger(..., scope:)`
# When raised, the initial subscription or update fails completely.
class GraphQL::Subscriptions::SubscriptionScopeMissingError < ::GraphQL::Error; end

# Library entry point for performance metric reporting.
#
# Events:
#
# Key | Metadata
# ----|---------
# lex | `{ query_string: String }`
# parse | `{ query_string: String }`
# validate | `{ query: GraphQL::Query, validate: Boolean }`
# analyze_multiplex |  `{ multiplex: GraphQL::Execution::Multiplex }`
# analyze_query | `{ query: GraphQL::Query }`
# execute_multiplex | `{ multiplex: GraphQL::Execution::Multiplex }`
# execute_query | `{ query: GraphQL::Query }`
# execute_query_lazy | `{ query: GraphQL::Query?, multiplex: GraphQL::Execution::Multiplex? }`
# execute_field | `{ owner: Class, field: GraphQL::Schema::Field, query: GraphQL::Query, path: Array<String, Integer>, ast_node: GraphQL::Language::Nodes::Field}`
# execute_field_lazy | `{ owner: Class, field: GraphQL::Schema::Field, query: GraphQL::Query, path: Array<String, Integer>, ast_node: GraphQL::Language::Nodes::Field}`
# authorized | `{ context: GraphQL::Query::Context, type: Class, object: Object, path: Array<String, Integer> }`
# authorized_lazy | `{ context: GraphQL::Query::Context, type: Class, object: Object, path: Array<String, Integer> }`
# resolve_type | `{ context: GraphQL::Query::Context, type: Class, object: Object, path: Array<String, Integer> }`
# resolve_type_lazy | `{ context: GraphQL::Query::Context, type: Class, object: Object, path: Array<String, Integer> }`
#
# Note that `execute_field` and `execute_field_lazy` receive different data in different settings:
#
# - When using {GraphQL::Execution::Interpreter}, they receive `{field:, path:, query:}`
# - Otherwise, they receive `{context: ...}`
module GraphQL::Tracing; end

# This implementation forwards events to ActiveSupport::Notifications
# with a `graphql` suffix.
module GraphQL::Tracing::ActiveSupportNotificationsTracing
  class << self
    def trace(key, metadata, &blk); end
  end
end

# A cache of frequently-used keys to avoid needless string allocations
GraphQL::Tracing::ActiveSupportNotificationsTracing::KEYS = T.let(T.unsafe(nil), Hash)

GraphQL::Tracing::ActiveSupportNotificationsTracing::NOTIFICATIONS_ENGINE = T.let(T.unsafe(nil), GraphQL::Tracing::NotificationsTracing)

# This class uses the AppopticsAPM SDK from the appoptics_apm gem to create
# traces for GraphQL.
#
# There are 4 configurations available. They can be set in the
# appoptics_apm config file or in code. Please see:
# {https://docs.appoptics.com/kb/apm_tracing/ruby/configure}
#
# AppOpticsAPM::Config[:graphql][:enabled] = true|false
# AppOpticsAPM::Config[:graphql][:transaction_name]  = true|false
# AppOpticsAPM::Config[:graphql][:sanitize_query] = true|false
# AppOpticsAPM::Config[:graphql][:remove_comments] = true|false
class GraphQL::Tracing::AppOpticsTracing < ::GraphQL::Tracing::PlatformTracing
  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, _key, data); end

  private

  def gql_config; end
  def graphql_context(context, layer); end
  def graphql_multiplex(data); end
  def graphql_query(query); end
  def graphql_query_string(query_string); end
  def metadata(data, layer); end
  def multiplex_transaction_name(names); end
  def remove_comments(query); end
  def sanitize(query); end
  def span_name(key); end
  def transaction_name(query); end

  class << self
    # During auto-instrumentation this version of AppOpticsTracing is compared
    # with the version provided in the appoptics_apm gem, so that the newer
    # version of the class can be used
    def version; end
  end
end

# These GraphQL events will show up as 'graphql.execute' spans
GraphQL::Tracing::AppOpticsTracing::EXEC_KEYS = T.let(T.unsafe(nil), Array)

# These GraphQL events will show up as 'graphql.prep' spans
GraphQL::Tracing::AppOpticsTracing::PREP_KEYS = T.let(T.unsafe(nil), Array)

class GraphQL::Tracing::AppsignalTracing < ::GraphQL::Tracing::PlatformTracing
  def initialize(options = T.unsafe(nil)); end

  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data); end
end

class GraphQL::Tracing::DataDogTracing < ::GraphQL::Tracing::PlatformTracing
  def analytics_available?; end
  def analytics_enabled?; end
  def analytics_sample_rate; end
  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data); end
  def service_name; end
  def tracer; end
end

class GraphQL::Tracing::NewRelicTracing < ::GraphQL::Tracing::PlatformTracing
  def initialize(options = T.unsafe(nil)); end

  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data); end
end

# This implementation forwards events to a notification handler (i.e.
# ActiveSupport::Notifications or Dry::Monitor::Notifications)
# with a `graphql` suffix.
class GraphQL::Tracing::NotificationsTracing
  # Initialize a new NotificationsTracing instance
  def initialize(notifications_engine); end

  # Sends a GraphQL tracing event to the notification handler
  #
  # . notifications_engine = Dry::Monitor::Notifications.new(:graphql)
  # . tracer = GraphQL::Tracing::NotificationsTracing.new(notifications_engine)
  # . tracer.trace("lex") { ... }
  def trace(key, metadata, &blk); end
end

# A cache of frequently-used keys to avoid needless string allocations
GraphQL::Tracing::NotificationsTracing::KEYS = T.let(T.unsafe(nil), Hash)

GraphQL::Tracing::NotificationsTracing::MAX_KEYS_SIZE = T.let(T.unsafe(nil), Integer)

module GraphQL::Tracing::NullTracer
  private

  def trace(k, v); end

  class << self
    def trace(k, v); end
  end
end

# Each platform provides:
# - `.platform_keys`
# - `#platform_trace`
# - `#platform_field_key(type, field)`
class GraphQL::Tracing::PlatformTracing
  def initialize(options = T.unsafe(nil)); end

  def instrument(type, field); end
  def trace(key, data); end
  def trace_field(type, field); end

  private

  # Different kind of schema objects have different kinds of keys:
  #
  # - Object types: `.authorized`
  # - Union/Interface types: `.resolve_type`
  # - Fields: execution
  #
  # So, they can all share one cache.
  #
  # If the key isn't present, the given block is called and the result is cached for `key`.
  def cached_platform_key(ctx, key); end

  def fallback_transaction_name(context); end
  def options; end

  # Get the transaction name based on the operation type and name if possible, or fall back to a user provided
  # one. Useful for anonymous queries.
  def transaction_name(query); end

  class << self
    def platform_keys; end
    def platform_keys=(_arg0); end
    def use(schema_defn, options = T.unsafe(nil)); end
  end
end

class GraphQL::Tracing::PrometheusTracing < ::GraphQL::Tracing::PlatformTracing
  def initialize(opts = T.unsafe(nil)); end

  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data, &block); end

  private

  def instrument_execution(platform_key, key, data, &block); end
  def observe(platform_key, key, duration); end
end

GraphQL::Tracing::PrometheusTracing::DEFAULT_COLLECTOR_TYPE = T.let(T.unsafe(nil), String)
GraphQL::Tracing::PrometheusTracing::DEFAULT_WHITELIST = T.let(T.unsafe(nil), Array)

class GraphQL::Tracing::ScoutTracing < ::GraphQL::Tracing::PlatformTracing
  def initialize(options = T.unsafe(nil)); end

  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data); end
end

GraphQL::Tracing::ScoutTracing::INSTRUMENT_OPTS = T.let(T.unsafe(nil), Hash)

class GraphQL::Tracing::SkylightTracing < ::GraphQL::Tracing::PlatformTracing
  def initialize(options = T.unsafe(nil)); end

  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data); end
end

class GraphQL::Tracing::StatsdTracing < ::GraphQL::Tracing::PlatformTracing
  def initialize(statsd:, **rest); end

  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data); end
end

# Objects may include traceable to gain a `.trace(...)` method.
# The object must have a `@tracers` ivar of type `Array<<#trace(k, d, &b)>>`.
module GraphQL::Tracing::Traceable
  def trace(key, metadata, &block); end

  private

  # If there's a tracer at `idx`, call it and then increment `idx`.
  # Otherwise, yield.
  def call_tracers(idx, key, metadata, &block); end
end

# Type kinds are the basic categories which a type may belong to (`Object`, `Scalar`, `Union`...)
module GraphQL::TypeKinds; end

GraphQL::TypeKinds::ENUM = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::INPUT_OBJECT = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::INTERFACE = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::LIST = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::NON_NULL = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::OBJECT = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::SCALAR = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::TYPE_KINDS = T.let(T.unsafe(nil), Array)

# These objects are singletons, eg `GraphQL::TypeKinds::UNION`, `GraphQL::TypeKinds::SCALAR`.
class GraphQL::TypeKinds::TypeKind
  def initialize(name, abstract: T.unsafe(nil), fields: T.unsafe(nil), wraps: T.unsafe(nil), input: T.unsafe(nil), description: T.unsafe(nil)); end

  # Is this TypeKind abstract?
  def abstract?; end

  # Is this TypeKind composed of many values?
  def composite?; end

  # Returns the value of attribute description.
  def description; end

  def enum?; end

  # Does this TypeKind have queryable fields?
  def fields?; end

  # Is this TypeKind a valid query input?
  def input?; end

  def input_object?; end
  def interface?; end
  def list?; end

  # Returns the value of attribute name.
  def name; end

  def non_null?; end
  def object?; end

  # Does this TypeKind have multiple possible implementors?
  def resolves?; end

  def scalar?; end
  def to_s; end
  def union?; end

  # Does this TypeKind modify another type?
  def wraps?; end
end

GraphQL::TypeKinds::UNION = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
module GraphQL::Types; end

class GraphQL::Types::BigInt < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _ctx); end
    def coerce_result(value, _ctx); end
    def parse_int(value); end
  end
end

class GraphQL::Types::Boolean < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _ctx); end
    def coerce_result(value, _ctx); end
  end
end

class GraphQL::Types::Float < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _ctx); end
    def coerce_result(value, _ctx); end
  end
end

class GraphQL::Types::ID < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _ctx); end
    def coerce_result(value, _ctx); end
  end
end

# This scalar takes `Date`s and transmits them as strings,
# using ISO 8601 format.
#
# Use it for fields or arguments as follows:
#
# field :published_at, GraphQL::Types::ISO8601Date, null: false
#
# argument :deliver_at, GraphQL::Types::ISO8601Date, null: false
#
# Alternatively, use this built-in scalar as inspiration for your
# own Date type.
class GraphQL::Types::ISO8601Date < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, ctx); end
    def coerce_result(value, _ctx); end
  end
end

# This scalar takes `Time`s and transmits them as strings,
# using ISO 8601 format.
#
# Use it for fields or arguments as follows:
#
# field :created_at, GraphQL::Types::ISO8601DateTime, null: false
#
# argument :deliver_at, GraphQL::Types::ISO8601DateTime, null: false
#
# Alternatively, use this built-in scalar as inspiration for your
# own DateTime type.
class GraphQL::Types::ISO8601DateTime < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(str_value, _ctx); end
    def coerce_result(value, _ctx); end
    def time_precision; end
    def time_precision=(value); end
  end
end

# It's not compatible with Rails' default,
# i.e. ActiveSupport::JSON::Encoder.time_precision (3 by default)
GraphQL::Types::ISO8601DateTime::DEFAULT_TIME_PRECISION = T.let(T.unsafe(nil), Integer)

class GraphQL::Types::Int < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, ctx); end
    def coerce_result(value, ctx); end
  end
end

GraphQL::Types::Int::MAX = T.let(T.unsafe(nil), Integer)
GraphQL::Types::Int::MIN = T.let(T.unsafe(nil), Integer)

# An untyped JSON scalar that maps to Ruby hashes, arrays, strings, integers, floats, booleans and nils.
# This should be used judiciously because it subverts the GraphQL type system.
#
# Use it for fields or arguments as follows:
#
# field :template_parameters, GraphQL::Types::JSON, null: false
#
# argument :template_parameters, GraphQL::Types::JSON, null: false
class GraphQL::Types::JSON < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _context); end
    def coerce_result(value, _context); end
  end
end

# This module contains some types and fields that could support Relay conventions in GraphQL.
#
# You can use these classes out of the box if you want, but if you want to use your _own_
# GraphQL extensions along with the features in this code, you could also
# open up the source files and copy the relevant methods and configuration into
# your own classes.
#
# For example, the provided object types extend {Types::Relay::BaseObject},
# but you might want to:
#
# 1. Migrate the extensions from {Types::Relay::BaseObject} into _your app's_ base object
# 2. Copy {Relay::BaseConnection}, {Relay::BaseEdge}, etc into _your app_, and
# change them to extend _your_ base object.
#
# Similarly, `BaseField`'s extensions could be migrated to your app
# and `Node` could be implemented to mix in your base interface module.
module GraphQL::Types::Relay
  class << self
    # Don't use this directly, instead, use one of these:
    def const_missing(const_name); end
  end
end

# Use this to implement Relay connections, or take it as inspiration
# for Relay classes in your own app.
#
# You may wish to copy this code into your own base class,
# so you can extend your own `BaseObject` instead of `GraphQL::Schema::Object`.
class GraphQL::Types::Relay::BaseConnection < ::GraphQL::Schema::Object
  include ::GraphQL::Types::Relay::ConnectionBehaviors
  extend ::GraphQL::Types::Relay::ConnectionBehaviors::ClassMethods
  extend ::GraphQL::Types::Relay::DefaultRelay
end

class GraphQL::Types::Relay::BaseConnection::InvalidNullError < ::GraphQL::InvalidNullError; end

# A class-based definition for Relay edges.
#
# Use this as a parent class in your app, or use it as inspiration for your
# own base `Edge` class.
#
# For example, you may want to extend your own `BaseObject` instead of the
# built-in `GraphQL::Schema::Object`.
class GraphQL::Types::Relay::BaseEdge < ::GraphQL::Schema::Object
  include ::GraphQL::Types::Relay::EdgeBehaviors
  extend ::GraphQL::Types::Relay::EdgeBehaviors::ClassMethods
end

class GraphQL::Types::Relay::BaseEdge::InvalidNullError < ::GraphQL::InvalidNullError; end

module GraphQL::Types::Relay::ConnectionBehaviors
  extend ::Forwardable

  mixes_in_class_methods ::GraphQL::Types::Relay::ConnectionBehaviors::ClassMethods
  mixes_in_class_methods ::GraphQL::Types::Relay::DefaultRelay

  def cursor_from_node(*args, &block); end
  def edges; end

  # By default this calls through to the ConnectionWrapper's edge nodes method,
  # but sometimes you need to override it to support the `nodes` field
  def nodes; end

  def parent(*args, &block); end

  class << self
    def add_page_info_field(obj_type); end
    def included(child_class); end
  end
end

module GraphQL::Types::Relay::ConnectionBehaviors::ClassMethods
  def accessible?(ctx); end
  def authorized?(obj, ctx); end
  def edge_class; end

  # Set the default `edge_nullable` for this class and its child classes. (Defaults to `true`.)
  # Use `edge_nullable(false)` in your base class to make non-null `edge` fields.
  def edge_nullable(new_value = T.unsafe(nil)); end

  # Configure this connection to return `edges` and `nodes` based on `edge_type_class`.
  #
  # This method will use the inputs to create:
  # - `edges` field
  # - `nodes` field
  # - description
  #
  # It's called when you subclass this base connection, trying to use the
  # class name to set defaults. You can call it again in the class definition
  # to override the default (or provide a value, if the default lookup failed).
  def edge_type(edge_type_class, edge_class: T.unsafe(nil), node_type: T.unsafe(nil), nodes_field: T.unsafe(nil), node_nullable: T.unsafe(nil), edges_nullable: T.unsafe(nil), edge_nullable: T.unsafe(nil), field_options: T.unsafe(nil)); end

  # Set the default `edges_nullable` for this class and its child classes. (Defaults to `true`.)
  # Use `edges_nullable(false)` in your base class to make non-null `edges` fields.
  def edges_nullable(new_value = T.unsafe(nil)); end

  # Set the default `nodes_field` for this class and its child classes. (Defaults to `true`.)
  # Use `nodes_field(false)` in your base class to prevent adding of a nodes field.
  def has_nodes_field(new_value = T.unsafe(nil)); end

  # Set the default `node_nullable` for this class and its child classes. (Defaults to `true`.)
  # Use `node_nullable(false)` in your base class to make non-null `node` and `nodes` fields.
  def node_nullable(new_value = T.unsafe(nil)); end

  def node_type; end

  # Add the shortcut `nodes` field to this connection and its subclasses
  def nodes_field(node_nullable: T.unsafe(nil), field_options: T.unsafe(nil)); end

  # Filter this list according to the way its node type would scope them
  def scope_items(items, context); end

  def visible?(ctx); end

  private

  def define_nodes_field(nullable, field_options: T.unsafe(nil)); end
end

module GraphQL::Types::Relay::DefaultRelay
  def default_relay(new_value); end
  def default_relay?; end
  def to_graphql; end

  class << self
    def extended(child_class); end
  end
end

# Don't use this field directly, instead, use one of these approaches:
GraphQL::Types::Relay::DeprecatedNodeField = T.let(T.unsafe(nil), GraphQL::Schema::Field)

GraphQL::Types::Relay::DeprecatedNodesField = T.let(T.unsafe(nil), GraphQL::Schema::Field)

module GraphQL::Types::Relay::EdgeBehaviors
  mixes_in_class_methods ::GraphQL::Types::Relay::EdgeBehaviors::ClassMethods

  class << self
    def included(child_class); end
  end
end

module GraphQL::Types::Relay::EdgeBehaviors::ClassMethods
  def accessible?(ctx); end
  def authorized?(obj, ctx); end

  # Set the default `node_nullable` for this class and its child classes. (Defaults to `true`.)
  # Use `node_nullable(false)` in your base class to make non-null `node` field.
  def node_nullable(new_value = T.unsafe(nil)); end

  # Get or set the Object type that this edge wraps.
  def node_type(node_type = T.unsafe(nil), null: T.unsafe(nil), field_options: T.unsafe(nil)); end

  def visible?(ctx); end
end

# Include this module to your root Query type to get a Relay-compliant `node(id: ID!): Node` field that uses the schema's `object_from_id` hook.
module GraphQL::Types::Relay::HasNodeField
  class << self
    def field_block; end
    def field_options; end
    def included(child_class); end
  end
end

# Include this module to your root Query type to get a Relay-style `nodes(id: ID!): [Node]` field that uses the schema's `object_from_id` hook.
module GraphQL::Types::Relay::HasNodesField
  class << self
    def field_block; end
    def field_options; end
    def included(child_class); end
  end
end

# This can be used for Relay's `Node` interface,
# or you can take it as inspiration for your own implementation
# of the `Node` interface.
module GraphQL::Types::Relay::Node
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  include ::GraphQL::Schema::Interface
  include ::GraphQL::Types::Relay::NodeBehaviors
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::Member::HasUnresolvedTypeError
  extend ::GraphQL::Schema::Member::HasDirectives
  extend ::GraphQL::Schema::Member::HasInterfaces
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Interface::DefinitionMethods
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Types::Relay::Node::DefinitionMethods
  extend ::GraphQL::Types::Relay::DefaultRelay
end

module GraphQL::Types::Relay::Node::DefinitionMethods; end
class GraphQL::Types::Relay::Node::UnresolvedTypeError < ::GraphQL::UnresolvedTypeError; end

module GraphQL::Types::Relay::NodeBehaviors
  mixes_in_class_methods ::GraphQL::Types::Relay::DefaultRelay

  class << self
    def included(child_module); end
  end
end

# The return type of a connection's `pageInfo` field
class GraphQL::Types::Relay::PageInfo < ::GraphQL::Schema::Object
  include ::GraphQL::Types::Relay::PageInfoBehaviors
  extend ::GraphQL::Types::Relay::DefaultRelay
end

class GraphQL::Types::Relay::PageInfo::InvalidNullError < ::GraphQL::InvalidNullError; end

module GraphQL::Types::Relay::PageInfoBehaviors
  mixes_in_class_methods ::GraphQL::Types::Relay::DefaultRelay

  class << self
    def included(child_class); end
  end
end

class GraphQL::Types::String < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _ctx); end
    def coerce_result(value, ctx); end
  end
end

# When an `authorized?` hook returns false, this error is used to communicate the failure.
# It's passed to {Schema.unauthorized_object}.
#
# Alternatively, custom code in `authorized?` may raise this error. It will be routed the same way.
class GraphQL::UnauthorizedError < ::GraphQL::Error
  def initialize(message = T.unsafe(nil), object: T.unsafe(nil), type: T.unsafe(nil), context: T.unsafe(nil)); end

  def context; end
  def context=(_arg0); end
  def object; end
  def type; end
end

class GraphQL::UnauthorizedFieldError < ::GraphQL::UnauthorizedError
  def initialize(message = T.unsafe(nil), object: T.unsafe(nil), type: T.unsafe(nil), context: T.unsafe(nil), field: T.unsafe(nil)); end

  def field; end
  def field=(_arg0); end
end

class GraphQL::UnionType < ::GraphQL::BaseType
  extend ::GraphQL::Define::InstanceDefinable::DeprecatedDefine

  def initialize; end

  def add_possible_types(types, **options); end

  # Get a possible type of this {UnionType} by type name
  def get_possible_type(type_name, ctx); end

  def include?(child_type_defn, ctx = T.unsafe(nil)); end
  def kind; end

  # Check if a type is a possible type of this {UnionType}
  def possible_type?(type, ctx); end

  def possible_types(ctx = T.unsafe(nil)); end
  def possible_types=(types); end
  def resolve_type(value, ctx); end
  def resolve_type=(new_resolve_type_proc); end
  def resolve_type_proc; end
  def resolve_type_proc=(_arg0); end
  def type_membership_class; end
  def type_membership_class=(_arg0); end
  def type_memberships; end
  def type_memberships=(type_memberships); end

  private

  def initialize_copy(other); end
  def possible_types_for_context(ctx); end
end

# Rubocop was unhappy about the syntax when this was a proc literal
class GraphQL::UnionType::AcceptPossibleTypesDefinition
  class << self
    def call(target, possible_types, options = T.unsafe(nil)); end
  end
end

# Error raised when the value provided for a field
# can't be resolved to one of the possible types for the field.
class GraphQL::UnresolvedTypeError < ::GraphQL::RuntimeTypeError
  def initialize(value, field, parent_type, resolved_type, possible_types); end

  def field; end
  def parent_type; end
  def possible_types; end
  def resolved_type; end
  def value; end
end

GraphQL::VERSION = T.let(T.unsafe(nil), String)
