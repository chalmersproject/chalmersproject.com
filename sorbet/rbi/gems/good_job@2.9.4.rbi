# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `good_job` gem.
# Please instead update this file by running `bin/tapioca gem good_job`.

module ActiveJob
  extend ::ActiveSupport::Autoload

  class << self
    def gem_version; end
    def version; end
  end
end

module ActiveJob::QueueAdapters
  extend ::ActiveSupport::Autoload

  class << self
    def lookup(name); end
  end
end

# See {GoodJob::Adapter} for details.
class ActiveJob::QueueAdapters::GoodJobAdapter < ::GoodJob::Adapter; end

# GoodJob is a multithreaded, Postgres-based, ActiveJob backend for Ruby on Rails.
#
# +GoodJob+ is the top-level namespace and exposes configuration attributes.
module GoodJob
  include ::GoodJob::Dependencies
  extend ::GoodJob::Dependencies::ClassMethods

  def _active_job_loaded; end
  def _active_job_loaded=(val); end
  def _active_record_loaded; end
  def _active_record_loaded=(val); end
  def _rails_after_initialize_hook_called; end
  def _rails_after_initialize_hook_called=(val); end
  def active_record_parent_class; end
  def active_record_parent_class=(val); end
  def logger; end
  def logger=(val); end
  def on_thread_error; end
  def on_thread_error=(val); end
  def preserve_job_records; end
  def preserve_job_records=(val); end
  def retry_on_unhandled_error; end
  def retry_on_unhandled_error=(val); end

  class << self
    def _active_job_loaded; end
    def _active_job_loaded=(val); end
    def _active_record_loaded; end
    def _active_record_loaded=(val); end
    def _executables; end

    # Called with exception when a GoodJob thread raises an exception
    def _on_thread_error(exception); end

    def _rails_after_initialize_hook_called; end
    def _rails_after_initialize_hook_called=(val); end

    # Sends +#shutdown+ or +#restart+ to executable objects ({GoodJob::Notifier}, {GoodJob::Poller}, {GoodJob::Scheduler}, {GoodJob::MultiScheduler}, {GoodJob::CronManager})
    def _shutdown_all(executables, method_name = T.unsafe(nil), timeout: T.unsafe(nil)); end

    # The ActiveRecord parent class inherited by +GoodJob::Execution+ (default: +ActiveRecord::Base+).
    # Use this when using multiple databases or other custom ActiveRecord configuration.
    def active_record_parent_class; end

    # The ActiveRecord parent class inherited by +GoodJob::Execution+ (default: +ActiveRecord::Base+).
    # Use this when using multiple databases or other custom ActiveRecord configuration.
    def active_record_parent_class=(val); end

    # Deletes preserved job records.
    # By default, GoodJob deletes job records when the job is performed and this
    # method is not necessary. However, when `GoodJob.preserve_job_records = true`,
    # the jobs will be preserved in the database. This is useful when wanting to
    # analyze or inspect job performance.
    # If you are preserving job records this way, use this method regularly to
    # delete old records and preserve space in your database.
    def cleanup_preserved_jobs(older_than: T.unsafe(nil)); end

    # The logger used by GoodJob (default: +Rails.logger+).
    # Use this to redirect logs to a special location or file.
    def logger; end

    # The logger used by GoodJob (default: +Rails.logger+).
    # Use this to redirect logs to a special location or file.
    def logger=(val); end

    # This callable will be called when an exception reaches GoodJob (default: +nil+).
    # It can be useful for logging errors to bug tracking services, like Sentry or Airbrake.
    def on_thread_error; end

    # This callable will be called when an exception reaches GoodJob (default: +nil+).
    # It can be useful for logging errors to bug tracking services, like Sentry or Airbrake.
    def on_thread_error=(val); end

    # Whether to preserve job records in the database after they have finished (default: +false+).
    # By default, GoodJob deletes job records after the job is completed successfully.
    # If you want to preserve jobs for latter inspection, set this to +true+.
    # If you want to preserve only jobs that finished with error for latter inspection, set this to +:on_unhandled_error+.
    # If +true+, you will need to clean out jobs using the +good_job cleanup_preserved_jobs+ CLI command or
    # by using +Goodjob.cleanup_preserved_jobs+.
    def preserve_job_records; end

    # Whether to preserve job records in the database after they have finished (default: +false+).
    # By default, GoodJob deletes job records after the job is completed successfully.
    # If you want to preserve jobs for latter inspection, set this to +true+.
    # If you want to preserve only jobs that finished with error for latter inspection, set this to +:on_unhandled_error+.
    # If +true+, you will need to clean out jobs using the +good_job cleanup_preserved_jobs+ CLI command or
    # by using +Goodjob.cleanup_preserved_jobs+.
    def preserve_job_records=(val); end

    def railtie_helpers_paths; end
    def railtie_namespace; end
    def railtie_routes_url_helpers(include_path_helpers = T.unsafe(nil)); end

    # Stops and restarts executing jobs.
    # GoodJob does its work in pools of background threads.
    # When forking processes you should shut down these background threads before forking, and restart them after forking.
    # For example, you should use +shutdown+ and +restart+ when using async execution mode with Puma.
    # See the {file:README.md#executing-jobs-async--in-process} for more explanation and examples.
    def restart(timeout: T.unsafe(nil)); end

    # Whether to re-perform a job when a type of +StandardError+ is raised to GoodJob (default: +true+).
    # If +true+, causes jobs to be re-queued and retried if they raise an instance of +StandardError+.
    # If +false+, jobs will be discarded or marked as finished if they raise an instance of +StandardError+.
    # Instances of +Exception+, like +SIGINT+, will *always* be retried, regardless of this attribute's value.
    def retry_on_unhandled_error; end

    # Whether to re-perform a job when a type of +StandardError+ is raised to GoodJob (default: +true+).
    # If +true+, causes jobs to be re-queued and retried if they raise an instance of +StandardError+.
    # If +false+, jobs will be discarded or marked as finished if they raise an instance of +StandardError+.
    # Instances of +Exception+, like +SIGINT+, will *always* be retried, regardless of this attribute's value.
    def retry_on_unhandled_error=(val); end

    # Stop executing jobs.
    # GoodJob does its work in pools of background threads.
    # When forking processes you should shut down these background threads before forking, and restart them after forking.
    # For example, you should use +shutdown+ and +restart+ when using async execution mode with Puma.
    # See the {file:README.md#executing-jobs-async--in-process} for more explanation and examples.
    def shutdown(timeout: T.unsafe(nil)); end

    # Tests whether jobs have stopped executing.
    def shutdown?; end

    def table_name_prefix; end
    def use_relative_model_naming?; end
  end
end

module GoodJob::ActiveJobExtensions; end

module GoodJob::ActiveJobExtensions::Concurrency
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::GoodJob::ActiveJobExtensions::Concurrency::ClassMethods

  def good_job_concurrency_key; end

  module GeneratedClassMethods
    def good_job_concurrency_config; end
    def good_job_concurrency_config=(value); end
    def good_job_concurrency_config?; end
  end

  module GeneratedInstanceMethods; end
end

module GoodJob::ActiveJobExtensions::Concurrency::ClassMethods
  def good_job_control_concurrency_with(config); end
end

class GoodJob::ActiveJobExtensions::Concurrency::ConcurrencyExceededError < ::StandardError
  def backtrace; end
end

# ActiveRecord model that represents an +ActiveJob+ job.
# There is not a table in the database whose discrete rows represents "Jobs".
# The +good_jobs+ table is a table of individual {GoodJob::Execution}s that share the same +active_job_id+.
# A single row from the +good_jobs+ table of executions is fetched to represent an ActiveJobJob
class GoodJob::ActiveJobJob < ::GoodJob::BaseRecord
  include ::GoodJob::ActiveJobJob::GeneratedAttributeMethods
  include ::GoodJob::ActiveJobJob::GeneratedAssociationMethods
  include ::GoodJob::Filterable
  include ::GoodJob::Lockable
  extend ::GoodJob::Filterable::ClassMethods
  extend ::GoodJob::Lockable::ClassMethods

  # Utility method to determine which execution record is used to represent this job
  def _execution_id; end

  # Utility method to test whether this job's underlying attributes represents its most recent execution.
  def _head?; end

  def advisory_lockable_function; end
  def advisory_lockable_function=(_arg0); end
  def advisory_lockable_function?; end
  def autosave_associated_records_for_executions(*args); end
  def create_with_advisory_lock; end
  def create_with_advisory_lock=(_arg0); end

  # Discard a job so that it will not be executed further.
  # This action will add a {DiscardJobError} to the job's {Execution} and mark it as finished.
  def discard_job(message); end

  # The number of times this job has been executed, according to ActiveJob's serialized state.
  def executions_count; end

  # This job's most recent {Execution}
  def head_execution(reload: T.unsafe(nil)); end

  # The job's ActiveJob UUID
  def id; end

  # The ActiveJob job class, as a string
  def job_class; end

  # The number of times this job has been executed, according to the number of GoodJob {Execution} records.
  def preserved_executions_count; end

  # The most recent error message.
  # If the job has been retried, the error will be fetched from the previous {Execution} record.
  def recent_error; end

  # Reschedule a scheduled job so that it executes immediately (or later) by the next available execution thread.
  def reschedule_job(scheduled_at = T.unsafe(nil)); end

  # Retry a job that has errored and been discarded.
  # This action will create a new job {Execution} record.
  def retry_job; end

  # Tests whether the job is being executed right now.
  def running?; end

  # The status of the Job, based on the state of its most recent execution.
  # There are 3 buckets of non-overlapping statuses:
  # 1. The job will be executed
  # - queued: The job will execute immediately when an execution thread becomes available.
  # - scheduled: The job is scheduled to execute in the future.
  # - retried: The job previously errored on execution and will be re-executed in the future.
  # 2. The job is being executed
  # - running: the job is actively being executed by an execution thread
  # 3. The job will not execute
  # - finished: The job executed successfully
  # - discarded: The job previously errored on execution and will not be re-executed in the future.
  def status; end

  # This job's initial/oldest {Execution}
  def tail_execution; end

  def validate_associated_records_for_executions(*args); end

  class << self
    def __callbacks; end
    def _reflections; end
    def _validators; end
    def advisory_lock(*args); end
    def advisory_lockable_column; end
    def advisory_lockable_column=(value); end
    def advisory_lockable_column?; end
    def advisory_lockable_function; end
    def advisory_lockable_function=(value); end
    def advisory_lockable_function?; end
    def advisory_locked(*args); end
    def advisory_unlocked(*args); end
    def default_scopes; end
    def defined_enums; end
    def discarded(*args); end
    def display_all(*args); end
    def finished(*args); end

    # Get Jobs finished before the given timestamp.
    def finished_before(*args); end

    # Get Jobs with given class name
    def job_class(*args); end

    def joins_advisory_locks(*args); end
    def owns_advisory_locked(*args); end
    def queued(*args); end
    def retried(*args); end
    def running(*args); end
    def scheduled(*args); end
    def search_text(*args); end
  end
end

# Raised when an inappropriate action is applied to a Job based on its state.
class GoodJob::ActiveJobJob::ActionForStateMismatchError < ::StandardError; end

# Raised when an action requires GoodJob to be the ActiveJob Queue Adapter but GoodJob is not.
class GoodJob::ActiveJobJob::AdapterNotGoodJobError < ::StandardError; end

# Attached to a Job's Execution when the Job is discarded.
class GoodJob::ActiveJobJob::DiscardJobError < ::StandardError; end

module GoodJob::ActiveJobJob::GeneratedAssociationMethods
  def execution_ids; end
  def execution_ids=(ids); end
  def executions; end
  def executions=(value); end
end

module GoodJob::ActiveJobJob::GeneratedAttributeMethods; end

# ActiveJob Adapter.
class GoodJob::Adapter
  def initialize(execution_mode: T.unsafe(nil), queues: T.unsafe(nil), max_threads: T.unsafe(nil), poll_interval: T.unsafe(nil), start_async_on_initialize: T.unsafe(nil)); end

  # Whether the async executors are running
  def async_started?; end

  # Enqueues the ActiveJob job to be performed.
  # For use by Rails; you should generally not call this directly.
  def enqueue(active_job); end

  # Enqueues an ActiveJob job to be run at a specific time.
  # For use by Rails; you should generally not call this directly.
  def enqueue_at(active_job, timestamp); end

  # Whether in +:async+ execution mode.
  def execute_async?; end

  # Whether in +:external+ execution mode.
  def execute_externally?; end

  # Whether in +:inline+ execution mode.
  def execute_inline?; end

  # Shut down the thread pool executors.
  def shutdown(timeout: T.unsafe(nil)); end

  # Start async executors
  def start_async; end

  private

  # Whether running in a web server process.
  def in_server_process?; end

  class << self
    # List of all instantiated Adapters in the current process.
    def instances; end
  end
end

module GoodJob::ApplicationHelper
  def relative_time(timestamp); end
end

class GoodJob::AssetsController < ::ActionController::Base
  def bootstrap_css; end
  def bootstrap_js; end
  def chartjs_js; end
  def rails_ujs_js; end
  def scripts_js; end
  def style_css; end

  private

  def _layout(lookup_context, formats); end

  class << self
    def __callbacks; end
    def middleware_stack; end
  end
end

# Extends an ActiveRecord odel to override the connection and use
# an explicit connection that has been removed from the pool.
module GoodJob::AssignableConnection
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::GoodJob::AssignableConnection::ClassMethods
end

module GoodJob::AssignableConnection::ClassMethods
  def connection; end
  def connection=(conn); end
  def with_connection(conn); end
end

class GoodJob::BaseController < ::ActionController::Base
  private

  def _layout(lookup_context, formats); end
  def switch_locale(&action); end

  class << self
    def __callbacks; end
    def middleware_stack; end
  end
end

class GoodJob::BaseFilter
  def initialize(params, base_query = T.unsafe(nil)); end

  def base_query; end
  def base_query=(_arg0); end
  def filtered_query; end
  def job_classes; end
  def last; end
  def params; end
  def params=(_arg0); end
  def queues; end
  def records; end
  def states; end
  def to_params(override = T.unsafe(nil)); end

  private

  def default_base_query; end
end

GoodJob::BaseFilter::DEFAULT_LIMIT = T.let(T.unsafe(nil), Integer)
GoodJob::BaseFilter::EMPTY = T.let(T.unsafe(nil), String)

# Base ActiveRecord class that all GoodJob models inherit from.
# Parent class can be configured with +GoodJob.active_record_parent_class+.
class GoodJob::BaseRecord < ::ActiveRecord::Base
  include ::GoodJob::BaseRecord::GeneratedAttributeMethods
  include ::GoodJob::BaseRecord::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
  extend ::Kaminari::ConfigurationMethods::ClassMethods

  class << self
    def _validators; end
    def defined_enums; end
    def migration_pending_warning!; end
    def page(num = T.unsafe(nil)); end
  end
end

module GoodJob::BaseRecord::GeneratedAssociationMethods; end
module GoodJob::BaseRecord::GeneratedAttributeMethods; end

# Implements the +good_job+ command-line tool, which executes jobs and
# provides other utilities. The actual entry point is in +exe/good_job+, but
# it just sets up and calls this class.
#
# The +good_job+ command-line tool is based on Thor, a CLI framework for
# Ruby. For more on general usage, see http://whatisthor.com/ and
# https://github.com/erikhuda/thor/wiki.
class GoodJob::CLI < ::Thor
  # The +good_job cleanup_preserved_jobs+ command. Deletes preserved job records.
  def cleanup_preserved_jobs; end

  def set_up_application!; end

  # The +good_job start+ command. Executes queued jobs.
  def start; end

  class << self
    def exit_on_failure?; end

    # Whether to log to STDOUT
    def log_to_stdout; end

    # Whether to log to STDOUT
    def log_to_stdout=(_arg0); end

    # Whether to log to STDOUT
    def log_to_stdout?; end

    # Whether the CLI is running from the executable
    def within_exe; end

    # Whether the CLI is running from the executable
    def within_exe=(_arg0); end

    # Whether the CLI is running from the executable
    def within_exe?; end
  end
end

# Path to the local Rails application's environment configuration.
# Requiring this loads the application's configuration and classes.
GoodJob::CLI::RAILS_ENVIRONMENT_RB = T.let(T.unsafe(nil), String)

# Tracks thresholds for cleaning up old jobs.
class GoodJob::CleanupTracker
  def initialize(cleanup_interval_seconds: T.unsafe(nil), cleanup_interval_jobs: T.unsafe(nil)); end

  # Whether a cleanup should be run.
  def cleanup?; end

  # Returns the value of attribute cleanup_interval_jobs.
  def cleanup_interval_jobs; end

  # Sets the attribute cleanup_interval_jobs
  def cleanup_interval_jobs=(_arg0); end

  # Returns the value of attribute cleanup_interval_seconds.
  def cleanup_interval_seconds; end

  # Sets the attribute cleanup_interval_seconds
  def cleanup_interval_seconds=(_arg0); end

  # Increments job count.
  def increment; end

  # Returns the value of attribute job_count.
  def job_count; end

  # Sets the attribute job_count
  def job_count=(_arg0); end

  # Returns the value of attribute last_at.
  def last_at; end

  # Sets the attribute last_at
  def last_at=(_arg0); end

  # Resets the counters.
  def reset; end
end

# +GoodJob::Configuration+ provides normalized configuration information to
# the rest of GoodJob. It combines environment information with explicitly
# set options to get the final values for each option.
class GoodJob::Configuration
  def initialize(options, env: T.unsafe(nil)); end

  # Number of jobs a {Scheduler} will execute before cleaning up preserved jobs.
  def cleanup_interval_jobs; end

  # Number of seconds a {Scheduler} will wait before cleaning up preserved jobs.
  def cleanup_interval_seconds; end

  # Number of seconds to preserve jobs when using the +good_job cleanup_preserved_jobs+ CLI command.
  # This configuration is only used when {GoodJob.preserve_job_records} is +true+.
  def cleanup_preserved_jobs_before_seconds_ago; end

  def cron; end
  def cron_entries; end

  # Tests whether to daemonize the process.
  def daemonize?; end

  # Whether to run cron
  def enable_cron; end

  # Whether to run cron
  def enable_cron?; end

  # The environment from which to read GoodJob's environment variables. By
  # default, this is the current process's environment, but it can be set
  # to something else in {#initialize}.
  def env; end

  # Specifies how and where jobs should be executed. See {Adapter#initialize}
  # for more details on possible values.
  def execution_mode; end

  # The maximum number of future-scheduled jobs to store in memory.
  # Storing future-scheduled jobs in memory reduces execution latency
  # at the cost of increased memory usage. 10,000 stored jobs = ~20MB.
  def max_cache; end

  # Indicates the number of threads to use per {Scheduler}. Note that
  # {#queue_string} may provide more specific thread counts to use with
  # individual schedulers.
  def max_threads; end

  # The options that were explicitly set when initializing +Configuration+.
  def options; end

  # Path of the pidfile to create when running as a daemon.
  def pidfile; end

  # The number of seconds between polls for jobs. GoodJob will execute jobs
  # on queues continuously until a queue is empty, at which point it will
  # poll (using this interval) for new queued jobs to execute.
  def poll_interval; end

  # Port of the probe server
  def probe_port; end

  # Describes which queues to execute jobs from and how those queues should
  # be grouped into {Scheduler} instances. See
  # {file:README.md#optimize-queues-threads-and-processes} for more details
  # on the format of this string.
  def queue_string; end

  # The number of seconds to wait for jobs to finish when shutting down
  # before stopping the thread. +-1+ is forever.
  def shutdown_timeout; end

  def validate!; end

  private

  def rails_config; end
end

# Default number of seconds to preserve jobs for {CLI#cleanup_preserved_jobs} and {GoodJob.cleanup_preserved_jobs}
GoodJob::Configuration::DEFAULT_CLEANUP_PRESERVED_JOBS_BEFORE_SECONDS_AGO = T.let(T.unsafe(nil), Integer)

# Default poll interval for async in development environment
GoodJob::Configuration::DEFAULT_DEVELOPMENT_ASYNC_POLL_INTERVAL = T.let(T.unsafe(nil), Integer)

# Default number of threads to use per {Scheduler}
GoodJob::Configuration::DEFAULT_MAX_CACHE = T.let(T.unsafe(nil), Integer)

# Default number of threads to use per {Scheduler}
GoodJob::Configuration::DEFAULT_MAX_THREADS = T.let(T.unsafe(nil), Integer)

# Default number of seconds between polls for jobs
GoodJob::Configuration::DEFAULT_POLL_INTERVAL = T.let(T.unsafe(nil), Integer)

# Default to always wait for jobs to finish for {Adapter#shutdown}
GoodJob::Configuration::DEFAULT_SHUTDOWN_TIMEOUT = T.let(T.unsafe(nil), Integer)

# Valid execution modes.
GoodJob::Configuration::EXECUTION_MODES = T.let(T.unsafe(nil), Array)

class GoodJob::CronEntriesController < ::GoodJob::BaseController
  def enqueue; end
  def index; end
  def show; end

  private

  def _layout(lookup_context, formats); end

  class << self
    def middleware_stack; end
  end
end

# A CronEntry represents a single scheduled item's properties.
class GoodJob::CronEntry
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Conversion
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::API
  include ::ActiveModel::Model
  extend ::ActiveModel::Validations::ClassMethods
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Validations::HelperMethods
  extend ::ActiveModel::Conversion::ClassMethods

  def initialize(params = T.unsafe(nil)); end

  def __callbacks; end
  def __callbacks?; end
  def _run_validate_callbacks(&block); end
  def _validate_callbacks; end
  def _validators; end
  def _validators?; end
  def args; end
  def cron; end
  def description; end
  def display_properties; end
  def enqueue(cron_at = T.unsafe(nil)); end
  def fugit; end
  def id; end
  def job_class; end
  def jobs; end
  def key; end
  def last_at; end
  def last_job; end
  def model_name(*_arg0, &_arg1); end
  def next_at; end

  # Returns the value of attribute params.
  def params; end

  def schedule; end
  def set; end
  def to_param; end
  def validation_context; end

  private

  def args_value; end
  def display_property(value); end
  def set_value; end
  def validation_context=(_arg0); end

  class << self
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _validate_callbacks; end
    def _validate_callbacks=(value); end
    def _validators; end
    def _validators=(value); end
    def _validators?; end
    def all(configuration: T.unsafe(nil)); end
    def find(key, configuration: T.unsafe(nil)); end
  end
end

# CronManagers enqueue jobs on a repeating schedule.
class GoodJob::CronManager
  def initialize(cron_entries = T.unsafe(nil), start_on_initialize: T.unsafe(nil)); end

  # Enqueues a scheduled task
  def create_task(cron_entry); end

  # Execution configuration to be scheduled
  def cron_entries; end

  # Stop and restart
  def restart(timeout: T.unsafe(nil)); end

  # Tests whether the manager is running.
  def running?; end

  # Stop/cancel any scheduled tasks
  def shutdown(timeout: T.unsafe(nil)); end

  # Tests whether the manager is shutdown.
  def shutdown?; end

  # Schedule tasks that will enqueue jobs based on their schedule
  def start; end

  class << self
    # List of all instantiated CronManagers in the current process.
    def instances; end

    # Task observer for cron task
    def task_observer(time, output, thread_error); end
  end
end

# Thread-local attributes for passing values from Instrumentation.
# (Cannot use ActiveSupport::CurrentAttributes because ActiveJob resets it)
module GoodJob::CurrentThread
  def cron_at; end
  def cron_at=(obj); end
  def cron_key; end
  def cron_key=(obj); end
  def error_on_discard; end
  def error_on_discard=(obj); end
  def error_on_retry; end
  def error_on_retry=(obj); end
  def execution; end
  def execution=(obj); end

  class << self
    def active_job_id; end

    # Cron At
    def cron_at; end

    # Cron At
    def cron_at=(obj); end

    # Cron Key
    def cron_key; end

    # Cron Key
    def cron_key=(obj); end

    # Error captured by discard_on
    def error_on_discard; end

    # Error captured by discard_on
    def error_on_discard=(obj); end

    # Error captured by retry_on
    def error_on_retry; end

    # Error captured by retry_on
    def error_on_retry=(obj); end

    def execution; end
    def execution=(obj); end
    def process_id; end

    # Resets attributes
    def reset(values = T.unsafe(nil)); end

    def thread_name; end

    # Exports values to hash
    def to_h; end

    # Wrap the yielded block with CurrentThread values and reset after the block
    def within; end
  end
end

# Resettable accessors for thread-local values.
GoodJob::CurrentThread::ACCESSORS = T.let(T.unsafe(nil), Array)

GoodJob::DEFAULT_LOGGER = T.let(T.unsafe(nil), ActiveSupport::Logger)

# Manages daemonization of the current process.
class GoodJob::Daemon
  def initialize(pidfile:); end

  # Daemonizes the current process and writes out a pidfile.
  def daemonize; end

  # The path of the generated pidfile.
  def pidfile; end

  private

  def check_pid; end
  def delete_pid; end
  def pid_status(pidfile); end
  def write_pid; end
end

# Extends GoodJob module to track Rails boot dependencies.
module GoodJob::Dependencies
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::GoodJob::Dependencies::ClassMethods
end

module GoodJob::Dependencies::ClassMethods
  def async_ready?; end
  def start_async_adapters; end
end

class GoodJob::Engine < ::Rails::Engine; end

# ActiveRecord model that represents an +ActiveJob+ job.
class GoodJob::Execution < ::GoodJob::BaseRecord
  include ::GoodJob::Execution::GeneratedAttributeMethods
  include ::GoodJob::Execution::GeneratedAssociationMethods
  include ::GoodJob::Lockable
  include ::GoodJob::Filterable
  extend ::GoodJob::Lockable::ClassMethods
  extend ::GoodJob::Filterable::ClassMethods

  def active_job; end
  def advisory_lockable_function; end
  def advisory_lockable_function=(_arg0); end
  def advisory_lockable_function?; end
  def autosave_associated_records_for_job(*args); end
  def create_with_advisory_lock; end
  def create_with_advisory_lock=(_arg0); end

  # Tests whether this job is safe to be executed by this thread.
  def executable?; end

  # Execute the ActiveJob job this {Execution} represents.
  def perform; end

  private

  def active_job_data; end
  def execute; end

  class << self
    def __callbacks; end
    def _reflections; end
    def _validators; end

    # Get Jobs with given ActiveJob ID
    def active_job_id(*args); end

    def advisory_lock(*args); end
    def advisory_lockable_column; end
    def advisory_lockable_column=(value); end
    def advisory_lockable_column?; end
    def advisory_lockable_function; end
    def advisory_lockable_function=(value); end
    def advisory_lockable_function?; end
    def advisory_locked(*args); end
    def advisory_unlocked(*args); end
    def dead(*args); end
    def defined_enums; end
    def display_all(*args); end

    # Places an ActiveJob job on a queue by creating a new {Execution} record.
    def enqueue(active_job, scheduled_at: T.unsafe(nil), create_with_advisory_lock: T.unsafe(nil)); end

    # Get Jobs were completed before the given timestamp. If no timestamp is
    # provided, get all jobs that have been completed. By default, GoodJob
    # deletes jobs after they are completed and this will find no jobs.
    # However, if you have changed {GoodJob.preserve_job_records}, this may
    # find completed Jobs.
    def finished(*args); end

    def head(*args); end

    # Get Jobs with given class name
    def job_class(*args); end

    def joins_advisory_locks(*args); end

    # Fetches the scheduled execution time of the next eligible Execution(s).
    def next_scheduled_at(after: T.unsafe(nil), limit: T.unsafe(nil), now_limit: T.unsafe(nil)); end

    # Get Jobs that are not scheduled for a later time than now (i.e. jobs that
    # are not scheduled or scheduled for earlier than the current time).
    def only_scheduled(*args); end

    def owns_advisory_locked(*args); end

    # Finds the next eligible Execution, acquire an advisory lock related to it, and
    # executes the job.
    def perform_with_advisory_lock; end

    # Order jobs by priority (highest priority first).
    def priority_ordered(*args); end

    # Parse a string representing a group of queues into a more readable data
    # structure.
    def queue_parser(string); end

    # Get Jobs on queues that match the given queue string.
    def queue_string(*args); end

    # Get Jobs have errored that will not be retried further
    def running(*args); end

    # Order jobs by scheduled (unscheduled or soonest first).
    def schedule_ordered(*args); end

    def search_text(*args); end

    # Get Jobs that have not yet been completed.
    def unfinished(*args); end
  end
end

# ActiveJob jobs without a +priority+ attribute are given this priority.
GoodJob::Execution::DEFAULT_PRIORITY = T.let(T.unsafe(nil), Integer)

# ActiveJob jobs without a +queue_name+ attribute are placed on this queue.
GoodJob::Execution::DEFAULT_QUEUE_NAME = T.let(T.unsafe(nil), String)

# String separating Error Class from Error Message
GoodJob::Execution::ERROR_MESSAGE_SEPARATOR = T.let(T.unsafe(nil), String)

module GoodJob::Execution::GeneratedAssociationMethods
  def build_job(*args, &block); end
  def create_job(*args, &block); end
  def create_job!(*args, &block); end
  def job; end
  def job=(value); end
  def job_changed?; end
  def job_previously_changed?; end
  def reload_job; end
end

module GoodJob::Execution::GeneratedAttributeMethods; end

# Raised if something attempts to execute a previously completed Execution again.
class GoodJob::Execution::PreviouslyPerformedError < ::StandardError; end

# Stores the results of job execution
class GoodJob::ExecutionResult
  def initialize(value:, handled_error: T.unsafe(nil), unhandled_error: T.unsafe(nil)); end

  def handled_error; end
  def unhandled_error; end
  def value; end
end

class GoodJob::ExecutionsController < ::GoodJob::BaseController
  def destroy; end
  def index; end

  private

  def _layout(lookup_context, formats); end

  class << self
    def middleware_stack; end
  end
end

class GoodJob::ExecutionsFilter < ::GoodJob::BaseFilter
  def filtered_query; end
  def states; end

  private

  def default_base_query; end
end

# Shared methods for filtering Execution/Job records from the +good_jobs+ table.
module GoodJob::Filterable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::GoodJob::Filterable::ClassMethods
end

module GoodJob::Filterable::ClassMethods
  def database_supports_websearch_to_tsquery?; end
end

class GoodJob::Job < ::GoodJob::Execution
  include ::GoodJob::Job::GeneratedAttributeMethods
  include ::GoodJob::Job::GeneratedAssociationMethods

  class << self
    def __callbacks; end
    def _validators; end
    def defined_enums; end
  end
end

module GoodJob::Job::GeneratedAssociationMethods; end
module GoodJob::Job::GeneratedAttributeMethods; end

# JobPerformer queries the database for jobs and performs them on behalf of a
# {Scheduler}. It mainly functions as glue between a {Scheduler} and the jobs
# it should be executing.
#
# The JobPerformer must be safe to execute across multiple threads.
class GoodJob::JobPerformer
  def initialize(queue_string); end

  # Delete expired preserved jobs
  def cleanup; end

  # A meaningful name to identify the performer in logs and for debugging.
  def name; end

  # Perform the next eligible job
  def next; end

  # Tests whether this performer should be used in GoodJob's current state.
  #
  # For example, state will be a LISTEN/NOTIFY message that is passed down
  # from the Notifier to the Scheduler. The Scheduler is able to ask
  # its performer "does this message relate to you?", and if not, ignore it
  # to minimize thread wake-ups, database queries, and thundering herds.
  def next?(state = T.unsafe(nil)); end

  # The Returns timestamps of when next tasks may be available.
  def next_at(after: T.unsafe(nil), limit: T.unsafe(nil), now_limit: T.unsafe(nil)); end

  private

  def job_query; end
  def parsed_queues; end

  # Returns the value of attribute queue_string.
  def queue_string; end
end

class GoodJob::JobsController < ::GoodJob::BaseController
  def discard; end
  def index; end
  def reschedule; end
  def retry; end
  def show; end

  private

  def _layout(lookup_context, formats); end
  def redirect_on_error(exception); end

  class << self
    def middleware_stack; end
    def rescue_handlers; end
  end
end

class GoodJob::JobsFilter < ::GoodJob::BaseFilter
  def filtered_query; end
  def states; end

  private

  def default_base_query; end
end

# Adds Postgres advisory locking capabilities to an ActiveRecord record.
# For details on advisory locks, see the Postgres documentation:
# - {https://www.postgresql.org/docs/current/explicit-locking.html#ADVISORY-LOCKS Advisory Locks Overview}
# - {https://www.postgresql.org/docs/current/functions-admin.html#FUNCTIONS-ADVISORY-LOCKS Advisory Locks Functions}
module GoodJob::Lockable
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::GoodJob::Lockable::ClassMethods

  # Acquires an advisory lock on this record if it is not already locked by
  # another database session. Be careful to ensure you release the lock when
  # you are done with {#advisory_unlock} (or {#advisory_unlock!} to release
  # all remaining locks).
  def advisory_lock(key: T.unsafe(nil), function: T.unsafe(nil)); end

  # Acquires an advisory lock on this record or raises
  # {RecordAlreadyAdvisoryLockedError} if it is already locked by another
  # database session.
  def advisory_lock!(key: T.unsafe(nil), function: T.unsafe(nil)); end

  # Tests whether this record has an advisory lock on it.
  def advisory_locked?(key: T.unsafe(nil)); end

  # Releases an advisory lock on this record if it is locked by this database
  # session. Note that advisory locks stack, so you must call
  # {#advisory_unlock} and {#advisory_lock} the same number of times.
  def advisory_unlock(key: T.unsafe(nil), function: T.unsafe(nil)); end

  # Releases all advisory locks on the record that are held by the current
  # database session.
  def advisory_unlock!(key: T.unsafe(nil), function: T.unsafe(nil)); end

  # Tests whether this record does not have an advisory lock on it.
  def advisory_unlocked?(key: T.unsafe(nil)); end

  # Default Advisory Lock key for column-based locking
  def lockable_column_key(column: T.unsafe(nil)); end

  # Default Advisory Lock key
  def lockable_key; end

  # Tests whether this record is locked by the current database session.
  def owns_advisory_lock?(key: T.unsafe(nil)); end

  def pg_or_jdbc_query(*_arg0, &_arg1); end

  # Acquires an advisory lock on this record and safely releases it after the
  # passed block is completed. If the record is locked by another database
  # session, this raises {RecordAlreadyAdvisoryLockedError}.
  def with_advisory_lock(key: T.unsafe(nil), function: T.unsafe(nil)); end

  module GeneratedClassMethods
    def advisory_lockable_column; end
    def advisory_lockable_column=(value); end
    def advisory_lockable_column?; end
    def advisory_lockable_function; end
    def advisory_lockable_function=(value); end
    def advisory_lockable_function?; end
  end

  module GeneratedInstanceMethods
    def advisory_lockable_function; end
    def advisory_lockable_function=(value); end
    def advisory_lockable_function?; end
  end
end

module GoodJob::Lockable::ClassMethods
  def _advisory_lockable_column; end
  def advisory_unlock_session; end
  def advisory_unlockable_function(function = T.unsafe(nil)); end
  def pg_or_jdbc_query(query); end
  def supports_cte_materialization_specifiers?; end
  def with_advisory_lock(column: T.unsafe(nil), function: T.unsafe(nil), unlock_session: T.unsafe(nil)); end
end

# Indicates an advisory lock is already held on a record by another
# database session.
class GoodJob::Lockable::RecordAlreadyAdvisoryLockedError < ::StandardError; end

# Listens to GoodJob notifications and logs them.
#
# Each method corresponds to the name of a notification. For example, when
# the {Scheduler} shuts down, it sends a notification named
# +"scheduler_shutdown.good_job"+ and the {#scheduler_shutdown} method will
# be called here. See the
# {https://api.rubyonrails.org/classes/ActiveSupport/LogSubscriber.html ActiveSupport::LogSubscriber}
# documentation for more.
class GoodJob::LogSubscriber < ::ActiveSupport::LogSubscriber
  # Responds to the +cleanup_preserved_jobs.good_job+ notification.
  def cleanup_preserved_jobs(event); end

  # Responds to the +create.good_job+ notification.
  def create(event); end

  # Responds to the +cron_manager_start.good_job+ notification.
  def cron_manager_start(event); end

  def debug(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end
  def error(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end
  def fatal(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end

  # Responds to the +finished_job_task.good_job+ notification.
  def finished_job_task(event); end

  # Responds to the +finished_timer_task.good_job+ notification.
  def finished_timer_task(event); end

  def info(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end

  # Get the logger associated with this {LogSubscriber} instance.
  def logger; end

  # Responds to the +notifier_listen.good_job+ notification.
  def notifier_listen(event); end

  # Responds to the +notifier_notified.good_job+ notification.
  def notifier_notified(event); end

  # Responds to the +notifier_notify_error.good_job+ notification.
  def notifier_notify_error(event); end

  # Responds to the +notifier_unlisten.good_job+ notification.
  def notifier_unlisten(event); end

  # Responds to the +perform_job.good_job+ notification.
  def perform_job(event); end

  # Responds to the +scheduler_create_pool.good_job+ notification.
  def scheduler_create_pool(event); end

  # Responds to the +scheduler_restart_pools.good_job+ notification.
  def scheduler_restart_pools(event); end

  # Responds to the +scheduler_shutdown.good_job+ notification.
  def scheduler_shutdown(event); end

  # Responds to the +scheduler_shutdown_start.good_job+ notification.
  def scheduler_shutdown_start(event); end

  def unknown(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end
  def warn(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end

  private

  # Add "GoodJob" plus any specified tags to every
  # {ActiveSupport::TaggedLogging} logger in {LogSubscriber.loggers}. Tags
  # are only applicable inside the block passed to this method.
  def tag_logger(*tags, &block); end

  class << self
    # Represents all the loggers attached to {LogSubscriber} with a single
    # logging interface. Writing to this logger is a shortcut for writing to
    # each of the loggers in {LogSubscriber.loggers}.
    def logger; end

    # Tracks all loggers that {LogSubscriber} is writing to. You can write to
    # multiple logs by appending to this array. After updating it, you should
    # usually call {LogSubscriber.reset_logger} to make sure they are all
    # written to.
    #
    # Defaults to {GoodJob.logger}.
    def loggers; end

    # Reset {LogSubscriber.logger} and force it to rebuild a new shortcut to
    # all the loggers in {LogSubscriber.loggers}. You should usually call
    # this after modifying the {LogSubscriber.loggers} array.
    def reset_logger; end
  end
end

# Delegates the interface of a single {Scheduler} to multiple Schedulers.
class GoodJob::MultiScheduler
  def initialize(schedulers); end

  # Delegates to {Scheduler#create_thread}.
  def create_thread(state = T.unsafe(nil)); end

  # Delegates to {Scheduler#restart}.
  def restart(timeout: T.unsafe(nil)); end

  # Delegates to {Scheduler#running?}.
  def running?; end

  def schedulers; end

  # Delegates to {Scheduler#shutdown}.
  def shutdown(timeout: T.unsafe(nil)); end

  # Delegates to {Scheduler#shutdown?}.
  def shutdown?; end
end

# Notifiers hook into Postgres LISTEN/NOTIFY functionality to emit and listen for notifications across processes.
#
# Notifiers can emit NOTIFY messages through Postgres.
# A notifier will LISTEN for messages by creating a background thread that runs in an instance of +Concurrent::ThreadPoolExecutor+.
# When a message is received, the notifier passes the message to each of its recipients.
class GoodJob::Notifier
  include ::ActiveSupport::Callbacks
  include ::GoodJob::Notifier::ProcessRegistration
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker

  def initialize(*recipients); end

  def __callbacks; end
  def __callbacks?; end
  def _listen_callbacks; end
  def _run_listen_callbacks(&block); end
  def _run_unlisten_callbacks(&block); end
  def _unlisten_callbacks; end
  def connection; end
  def connection=(obj); end

  # Invoked on completion of ThreadPoolExecutor task
  def listen_observer(_time, _result, thread_error); end

  # Tests whether the notifier is active and listening for new messages.
  def listening?; end

  # List of recipients that will receive notifications.
  def recipients; end

  # Restart the notifier.
  # When shutdown, start; or shutdown and start.
  def restart(timeout: T.unsafe(nil)); end

  # Tests whether the notifier is running.
  def running?(*_arg0, &_arg1); end

  # Shut down the notifier.
  # This stops the background LISTENing thread.
  # Use {#shutdown?} to determine whether threads have stopped.
  def shutdown(timeout: T.unsafe(nil)); end

  # Tests whether the scheduler is shutdown.
  def shutdown?(*_arg0, &_arg1); end

  private

  def create_executor; end

  # Returns the value of attribute executor.
  def executor; end

  def listen(delay: T.unsafe(nil)); end
  def wait_for_notify; end
  def with_connection; end

  class << self
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _listen_callbacks; end
    def _listen_callbacks=(value); end
    def _unlisten_callbacks; end
    def _unlisten_callbacks=(value); end

    # ActiveRecord Connection that has been established for the Notifier.
    def connection; end

    # ActiveRecord Connection that has been established for the Notifier.
    def connection=(obj); end

    # List of all instantiated Notifiers in the current process.
    def instances; end

    # Send a message via Postgres NOTIFY
    def notify(message); end
  end
end

# Default Postgres channel for LISTEN/NOTIFY
GoodJob::Notifier::CHANNEL = T.let(T.unsafe(nil), String)

# Connection errors that will wait {RECONNECT_INTERVAL} before reconnecting
GoodJob::Notifier::CONNECTION_ERRORS = T.let(T.unsafe(nil), Array)

# Defaults for instance of Concurrent::ThreadPoolExecutor
GoodJob::Notifier::EXECUTOR_OPTIONS = T.let(T.unsafe(nil), Hash)

# Extends the Notifier to register the process in the database.
module GoodJob::Notifier::ProcessRegistration
  extend ::ActiveSupport::Concern

  # Deregisters the current process.
  def deregister_process; end

  # Registers the current process.
  def register_process; end
end

# Seconds to wait if database cannot be connected to
GoodJob::Notifier::RECONNECT_INTERVAL = T.let(T.unsafe(nil), Integer)

# Seconds to block while LISTENing for a message
GoodJob::Notifier::WAIT_INTERVAL = T.let(T.unsafe(nil), Integer)

# Pollers regularly wake up execution threads to check for new work.
class GoodJob::Poller
  def initialize(*recipients, poll_interval: T.unsafe(nil)); end

  # List of recipients that will receive notifications.
  def recipients; end

  # Restart the poller.
  # When shutdown, start; or shutdown and start.
  def restart(timeout: T.unsafe(nil)); end

  # Tests whether the timer is running.
  def running?(*_arg0, &_arg1); end

  # Shut down the poller.
  # Use {#shutdown?} to determine whether threads have stopped.
  def shutdown(timeout: T.unsafe(nil)); end

  # Tests whether the timer is shutdown.
  def shutdown?; end

  # Invoked on completion of TimerTask task.
  def timer_observer(time, executed_task, thread_error); end

  private

  def create_timer; end
  def timer; end

  class << self
    # Creates GoodJob::Poller from a GoodJob::Configuration instance.
    def from_configuration(configuration); end

    # List of all instantiated Pollers in the current process.
    def instances; end
  end
end

# Defaults for instance of Concurrent::TimerTask.
# The timer controls how and when sleeping threads check for new work.
GoodJob::Poller::DEFAULT_TIMER_OPTIONS = T.let(T.unsafe(nil), Hash)

GoodJob::Poller::TIMEOUT_INTERVAL = T.let(T.unsafe(nil), Integer)

class GoodJob::ProbeServer
  def initialize(port:); end

  def call(env); end
  def running?; end
  def start; end
  def stop; end

  class << self
    def task_observer(time, output, thread_error); end
  end
end

GoodJob::ProbeServer::RACK_SERVER = T.let(T.unsafe(nil), String)

# ActiveRecord model that represents an GoodJob process (either async or CLI).
class GoodJob::Process < ::GoodJob::BaseRecord
  include ::GoodJob::Process::GeneratedAttributeMethods
  include ::GoodJob::Process::GeneratedAssociationMethods
  include ::GoodJob::AssignableConnection
  include ::GoodJob::Lockable
  extend ::GoodJob::AssignableConnection::ClassMethods
  extend ::GoodJob::Lockable::ClassMethods

  def _connection; end
  def _connection=(obj); end
  def _current_id; end
  def _current_id=(val); end
  def _pid; end
  def _pid=(val); end
  def advisory_lockable_function; end
  def advisory_lockable_function=(_arg0); end
  def advisory_lockable_function?; end
  def create_with_advisory_lock; end
  def create_with_advisory_lock=(_arg0); end

  # Unregisters the instance.
  def deregister; end

  def mutex; end

  class << self
    def __callbacks; end
    def _connection; end
    def _connection=(obj); end
    def _current_id; end
    def _current_id=(val); end
    def _pid; end
    def _pid=(val); end
    def _validators; end

    # Processes that are inactive and unlocked (e.g. SIGKILLed)
    def active(*args); end

    def advisory_lock(*args); end
    def advisory_lockable_column; end
    def advisory_lockable_column=(value); end
    def advisory_lockable_column?; end
    def advisory_lockable_function; end
    def advisory_lockable_function=(value); end
    def advisory_lockable_function?; end
    def advisory_locked(*args); end
    def advisory_unlocked(*args); end

    # Deletes all inactive process records.
    def cleanup; end

    # UUID that is unique to the current process and changes when forked.
    def current_id; end

    # Hash representing metadata about the current process.
    def current_state; end

    def defined_enums; end
    def inactive(*args); end
    def joins_advisory_locks(*args); end

    # Whether the +good_job_processes+ table exsists.
    def migrated?; end

    def mutex; end
    def owns_advisory_locked(*args); end

    # Registers the current process in the database
    def register; end
  end
end

module GoodJob::Process::GeneratedAssociationMethods; end
module GoodJob::Process::GeneratedAttributeMethods; end

class GoodJob::ProcessesController < ::GoodJob::BaseController
  def index; end

  private

  def _layout(lookup_context, formats); end

  class << self
    def middleware_stack; end
  end
end

# Ruby on Rails integration.
class GoodJob::Railtie < ::Rails::Railtie; end

class GoodJob::ScheduledByQueueChart
  def initialize(filter); end

  def data; end
  def string_to_hsl(string); end
end

# Schedulers are generic thread pools that are responsible for
# periodically checking for available tasks, executing tasks within a thread,
# and efficiently scaling active threads.
#
# Every scheduler has a single {JobPerformer} that will execute tasks.
# The scheduler is responsible for calling its performer efficiently across threads managed by an instance of +Concurrent::ThreadPoolExecutor+.
# If a performer does not have work, the thread will go to sleep.
# The scheduler maintains an instance of +Concurrent::TimerTask+, which wakes sleeping threads and causes them to check whether the performer has new work.
class GoodJob::Scheduler
  def initialize(performer, max_threads: T.unsafe(nil), max_cache: T.unsafe(nil), warm_cache_on_initialize: T.unsafe(nil), cleanup_interval_seconds: T.unsafe(nil), cleanup_interval_jobs: T.unsafe(nil)); end

  # Preload existing runnable and future-scheduled jobs
  def cleanup; end

  # Wakes a thread to allow the performer to execute a task.
  def create_thread(state = T.unsafe(nil)); end

  # Human readable name of the scheduler that includes configuration values.
  def name; end

  # Restart the Scheduler.
  # When shutdown, start; or shutdown and start.
  def restart(timeout: T.unsafe(nil)); end

  # Tests whether the scheduler is running.
  def running?(*_arg0, &_arg1); end

  # Shut down the scheduler.
  # This stops all threads in the thread pool.
  # Use {#shutdown?} to determine whether threads have stopped.
  def shutdown(timeout: T.unsafe(nil)); end

  # Tests whether the scheduler is shutdown.
  def shutdown?(*_arg0, &_arg1); end

  # Information about the Scheduler
  def stats; end

  # Invoked on completion of ThreadPoolExecutor task
  def task_observer(time, output, thread_error); end

  # Preload existing runnable and future-scheduled jobs
  def warm_cache; end

  private

  def cache_count; end
  def create_executor; end
  def create_task(delay = T.unsafe(nil)); end

  # Returns the value of attribute executor.
  def executor; end

  def instrument(name, payload = T.unsafe(nil), &block); end

  # Returns the value of attribute performer.
  def performer; end

  def remaining_cache_count; end

  # Returns the value of attribute timer_set.
  def timer_set; end

  class << self
    # Creates GoodJob::Scheduler(s) and Performers from a GoodJob::Configuration instance.
    def from_configuration(configuration, warm_cache_on_initialize: T.unsafe(nil)); end

    # List of all instantiated Schedulers in the current process.
    def instances; end
  end
end

# Defaults for instance of Concurrent::ThreadPoolExecutor
# The thread pool executor is where work is performed.
GoodJob::Scheduler::DEFAULT_EXECUTOR_OPTIONS = T.let(T.unsafe(nil), Hash)

# Custom sub-class of +Concurrent::ThreadPoolExecutor+ to add additional worker status.
class GoodJob::Scheduler::ThreadPoolExecutor < ::Concurrent::ThreadPoolExecutor
  # Number of inactive threads available to execute tasks.
  # https://github.com/ruby-concurrency/concurrent-ruby/issues/684#issuecomment-427594437
  def ready_worker_count; end
end

# Custom sub-class of +Concurrent::TimerSet+ for additional behavior.
class GoodJob::Scheduler::TimerSet < ::Concurrent::TimerSet
  # Number of scheduled jobs in the queue
  def length; end

  # Clear the queue
  def reset; end
end

# GoodJob gem version.
GoodJob::VERSION = T.let(T.unsafe(nil), String)
