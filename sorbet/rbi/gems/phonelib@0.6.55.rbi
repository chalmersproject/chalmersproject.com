# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `phonelib` gem.
# Please instead update this file by running `bin/tapioca gem phonelib`.

# Validator class for phone validations
#
# ==== Examples
#
# Validates that attribute is a valid phone number.
# If empty value passed for attribute it fails.
#
# class Phone < ActiveRecord::Base
# attr_accessible :number
# validates :number, phone: true
# end
#
# Validates that attribute is a possible phone number.
# If empty value passed for attribute it fails.
#
# class Phone < ActiveRecord::Base
# attr_accessible :number
# validates :number, phone: { possible: true }
# end
#
# Validates that attribute is a valid phone number.
# Empty value is allowed to be passed.
#
# class Phone < ActiveRecord::Base
# attr_accessible :number
# validates :number, phone: { allow_blank: true }
# end
#
# Validates that attribute is a valid phone number of specified type(s).
# It is also possible to check that attribute is a possible number of specified
# type(s). Symbol or array accepted.
#
# class Phone < ActiveRecord::Base
# attr_accessible :number, :mobile
# validates :number, phone: { types: [:mobile, :fixed], allow_blank: true }
# validates :mobile, phone: { possible: true, types: :mobile  }
# end
#
# validates that phone is valid and it is from specified country or countries
#
# class Phone < ActiveRecord::Base
# attr_accessible :number
# validates :number, phone: { countries: [:us, :ca] }
# end
#
# Validates that attribute does not include an extension.
# The default setting is to allow extensions
#
# class Phone < ActiveRecord::Base
# attr_accessible :number
# validates :number, phone: { extensions: false }
# end
class PhoneValidator < ::ActiveModel::EachValidator
  include ::Phonelib::Core

  # Validation method
  def validate_each(record, attribute, value); end

  private

  def countries; end
  def message; end
  def phone_countries; end
  def phone_types; end
  def phone_valid?; end
  def specified_country(record); end
  def types; end
  def valid_country?; end
  def valid_extensions?; end
  def valid_types?; end
end

# main Phonelib module definition
module Phonelib
  extend ::Phonelib::Core
end

# main module that includes all basic data and methods
module Phonelib::Core
  def add_additional_regex(country, type, national_regex); end
  def additional_regexes; end

  # setter for data file to use
  def additional_regexes=(data); end

  # getter method for default_country variable
  def default_country; end

  # setter method for default_country variable
  def default_country=(country); end

  def dump_additional_regexes; end

  # getter method for extension_separate_symbols variable
  def extension_separate_symbols; end

  # setter method for extension_separate_symbols variable
  def extension_separate_symbols=(separator); end

  # getter method for extension_separator variable
  def extension_separator; end

  # setter method for extension_separator variable
  def extension_separator=(separator); end

  # method checks if passed phone number is impossible
  def impossible?(phone_number); end

  # method checks if passed phone number is invalid
  def invalid?(phone_number); end

  # method checks if passed phone number is invalid for provided country
  def invalid_for_country?(phone_number, country); end

  def override_phone_data; end

  # setter for data file to use
  def override_phone_data=(file_path); end

  # method for parsing phone number.
  # On first run fills @@phone_data with data present in yaml file
  def parse(phone, passed_country = T.unsafe(nil)); end

  # getter for flag for special phone types parsing
  def parse_special; end

  # setter for flag for special phone types parsing
  def parse_special=(special); end

  # getter for phone data for other modules of gem, can be used outside
  def phone_data; end

  def phone_ext_data; end
  def phone_regexp_cache; end

  # method checks if passed phone number is possible
  def possible?(phone_number); end

  # getter for sanitize regex
  def sanitize_regex; end

  # setter for sanitize regex
  def sanitize_regex=(regex); end

  # getter for strict check flag
  def strict_check; end

  # setter for strict check flag
  def strict_check=(strict); end

  # getter for strict double prefix check flag
  def strict_double_prefix_check; end

  # setter for strict double prefix check flag
  def strict_double_prefix_check=(strict); end

  # method checks if passed phone number is valid
  def valid?(phone_number); end

  # method checks if passed phone number is valid for provided country
  def valid_for_country?(phone_number, country); end

  def vanity_conversion; end

  # setter for vanity phone numbers chars replacement
  def vanity_conversion=(value); end

  private

  def load_data; end
  def load_ext_data; end
end

Phonelib::Core::AREA_CODE_MOBILE_COUNTRIES = T.let(T.unsafe(nil), Array)
Phonelib::Core::AREA_CODE_MOBILE_TOKENS = T.let(T.unsafe(nil), Hash)
Phonelib::Core::AREA_CODE_OPTIONAL = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::AREA_CODE_TYPES = T.let(T.unsafe(nil), Array)
Phonelib::Core::CARRIER_SELECTION_CODES = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::CARRIER_SERVICES = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::CARRIER_SPECIFIC = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::COUNTRY_CODE = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::DEFAULT_NUMBER_FORMAT = T.let(T.unsafe(nil), Hash)
Phonelib::Core::DIRECTORY_SERVICES = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::DOUBLE_COUNTRY_PREFIX_FLAG = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::EMERGENCY = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::EXPANDED_EMERGENCY = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::EXT_CARRIERS = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::EXT_CARRIER_KEY = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::EXT_COUNTRY_NAMES = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::EXT_GEO_NAMES = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::EXT_GEO_NAME_KEY = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::EXT_PREFIXES = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::EXT_TIMEZONES = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::EXT_TIMEZONE_KEY = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::FILE_EXT_DATA = T.let(T.unsafe(nil), String)
Phonelib::Core::FILE_MAIN_DATA = T.let(T.unsafe(nil), String)
Phonelib::Core::FIXED_LINE = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::FIXED_OR_MOBILE = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::FORMATS = T.let(T.unsafe(nil), Symbol)

# Validation patterns keys constants
Phonelib::Core::GENERAL = T.let(T.unsafe(nil), Symbol)

Phonelib::Core::INTERNATIONAL_PREFIX = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::LEADING_DIGITS = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::MAIN_COUNTRY_FOR_CODE = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::MOBILE = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::NATIONAL_PREFIX = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::NATIONAL_PREFIX_FOR_PARSING = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::NATIONAL_PREFIX_RULE = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::NATIONAL_PREFIX_TRANSFORM_RULE = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::NO_INTERNATIONAL_DIALING = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::PAGER = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::PATTERN = T.let(T.unsafe(nil), Symbol)

# and may be routed to either a MOBILE or FIXED_LINE number.
Phonelib::Core::PERSONAL_NUMBER = T.let(T.unsafe(nil), Symbol)

Phonelib::Core::PLUS_SIGN = T.let(T.unsafe(nil), String)
Phonelib::Core::POSSIBLE_PATTERN = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::PREMIUM_RATE = T.let(T.unsafe(nil), Symbol)

# between caller and recipient, and is hence typically less than
# PREMIUM_RATE calls
Phonelib::Core::SHARED_COST = T.let(T.unsafe(nil), Symbol)

Phonelib::Core::SHORT = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::SHORT_CODE = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::SHORT_CODES = T.let(T.unsafe(nil), Array)
Phonelib::Core::SMS_SERVICES = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::STANDARD_RATE = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::TOLL_FREE = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::TYPES = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::TYPES_DESC = T.let(T.unsafe(nil), Hash)
Phonelib::Core::UAN = T.let(T.unsafe(nil), Symbol)

# Internal use keys for validations
Phonelib::Core::VALID_PATTERN = T.let(T.unsafe(nil), Symbol)

Phonelib::Core::VANITY_4_LETTERS_KEYS_REGEX = T.let(T.unsafe(nil), Regexp)
Phonelib::Core::VOICEMAIL = T.let(T.unsafe(nil), Symbol)
Phonelib::Core::VOIP = T.let(T.unsafe(nil), Symbol)

# class for parsed phone number, includes validation and formatting methods
class Phonelib::Phone
  include ::Phonelib::PhoneAnalyzerHelper
  include ::Phonelib::PhoneAnalyzer
  include ::Phonelib::PhoneExtendedData
  include ::Phonelib::PhoneFormatter

  # class initialization method
  def initialize(phone, country = T.unsafe(nil)); end

  # Compare a phone number against a string or other parsed number
  def ==(other); end

  # Returns all countries that matched valid patterns
  def countries; end

  # Returns first country that matched valid patterns
  def country; end

  def extension; end

  # Return human representation of phone type
  def human_type; end

  # Returns human representation of all matched phone types
  def human_types; end

  # Returns whether a current parsed phone number is impossible
  def impossible?; end

  # Returns whether a current parsed phone number is invalid
  def invalid?; end

  # Returns whether a current parsed phone number is invalid for specified
  # country
  def invalid_for_country?(country); end

  # returns local number
  def local_number; end

  def national_number; end
  def original; end

  # Returns whether a current parsed phone number is possible
  def possible?; end

  # Returns all possible types that matched possible patterns
  def possible_types; end

  # method to get sanitized phone number (only numbers)
  def sanitized; end

  # method returns string representation of parsed phone
  def to_s; end

  # Returns first phone type that matched
  def type; end

  # Returns all phone types that matched valid patterns
  def types; end

  # Returns whether a current parsed phone number is valid
  def valid?; end

  # Return countries with valid patterns
  def valid_countries; end

  # Return valid country
  def valid_country; end

  # Returns whether a current parsed phone number is valid for specified
  # country
  def valid_for_country?(country); end

  private

  def main_country(countries_array); end
  def separate_extension(original); end
end

module Phonelib::PhoneAnalyzer
  include ::Phonelib::PhoneAnalyzerHelper

  # parses provided phone if it is valid for  country data and
  # returns result of analyze
  #
  # ==== Attributes
  #
  # * +phone+ - Phone number for parsing
  # * +passed_country+ - Country provided for parsing. Must be ISO code of
  # country (2 letters) like 'US', 'us' or :us for United States
  def analyze(phone, passed_country); end

  private

  # Returns all valid and possible phone number types for currently parsed
  # phone for provided data hash.
  #
  # ==== Attributes
  #
  # * +phone+ - phone number for parsing
  # * +data+  - country data
  # * +not_valid+ - specifies that number is not valid by general desc pattern
  def all_number_types(phone, data, not_valid = T.unsafe(nil)); end

  # method checks which result is better to return
  def better_result(base_result, result = T.unsafe(nil)); end

  # Create phone representation in e164 format
  #
  # ==== Attributes
  #
  # * +phone+ - phone number for parsing
  # * +data+  - country data to be based on for creating e164 representation
  def convert_to_e164(phone, data); end

  # method tries to detect what is the country for provided phone
  #
  # ==== Attributes
  #
  # * +phone+ - phone number for parsing
  def detect_and_parse(phone, country); end

  # Returns possible and valid patterns for validation for provided type
  #
  # ==== Attributes
  #
  # * +all_patterns+ - hash of all patterns for validation
  # * +type+ - type of phone to get patterns for
  def get_patterns(all_patterns, type); end

  # returns national number and analyzing results for provided phone number
  #
  # ==== Attributes
  #
  # * +data+ - country data
  # * +country_match+ - result of match of phone within full regex
  # * +not_valid+ - specifies that number is not valid by general desc pattern
  def national_and_data(data, country_match, not_valid = T.unsafe(nil)); end

  # Gets matched number formatting rule or default one
  #
  # ==== Attributes
  #
  # * +national+ - national phone number
  # * +format_data+  - formatting data from country data
  def number_format(national, format_data); end

  # trying to parse phone for single country including international prefix
  # check for provided country
  #
  # ==== Attributes
  #
  # * +phone+ - phone for parsing
  # * +country+ - country to parse phone with
  def parse_country(phone, country); end

  # method checks if phone is valid against single provided country data
  #
  # ==== Attributes
  #
  # * +e164+ - e164 representation of phone for parsing
  # * +data+ - country data for single country for parsing
  def parse_single_country(e164, data); end

  # replacing national prefix to simplified format
  def with_replaced_national_prefix(phone, data); end
end

# array of types not included for validation check in cycle
Phonelib::PhoneAnalyzer::NOT_FOR_CHECK = T.let(T.unsafe(nil), Array)

module Phonelib::PhoneAnalyzerHelper
  private

  # changes phone to with/without double country prefix
  def changed_dp_phone(country, phone); end

  # defines whether country can have double country prefix in number
  def country_can_dp?(country); end

  # Get country that was provided or default country in needable format
  #
  # ==== Attributes
  #
  # * +country+ - country passed for parsing
  def country_or_default_country(country); end

  # returns country prefix for provided country or nil
  def country_prefix(country); end

  # caches regular expression, reusing it for later lookups
  def cr(regexp); end

  # checks if country can have numbers with double country prefixes
  #
  # ==== Attributes
  #
  # * +data+ - country data used for parsing
  # * +phone+ - phone number being parsed
  # * +parsed+ - parsed regex match for phone
  def double_prefix_allowed?(data, phone, parsed = T.unsafe(nil)); end

  # Checks if fixed line pattern and mobile pattern are the same and returns
  # appropriate keys
  #
  # ==== Attributes
  #
  # * +data+  - country data
  def fixed_and_mobile_keys(data); end

  # constructs full regex for phone validation for provided phone data
  # (international prefix, country code, national prefix, valid number)
  #
  # ==== Attributes
  #
  # * +data+ - country data hash
  # * +country_optional+ - whether to put country code as optional group
  def full_regex_for_data(data, type, country_optional = T.unsafe(nil)); end

  # Checks number against regex and compares match length
  #
  # ==== Attributes
  #
  # * +number+ - phone number for validation
  # * +regex+ - regex for perfoming a validation
  def number_match?(number, regex); end

  # Checks if passed number matches valid and possible patterns
  #
  # ==== Attributes
  #
  # * +number+ - phone number for validation
  # * +p_regex+ - possible regex pattern for validation
  # * +v_regex+ - valid regex pattern for validation
  # * +not_valid+ - specifies that number is not valid by general desc pattern
  def number_valid_and_possible?(number, p_regex, v_regex, not_valid = T.unsafe(nil)); end

  # Returns original number passed if it's a string or empty string otherwise
  def original_s; end

  def original_starts_with_plus?; end

  # defines if to validate against single country or not
  def passed_country(country); end

  # Check if phone match country data
  #
  # ==== Attributes
  #
  # * +phone+ - phone number for parsing
  # * +data+  - country data
  def phone_match_data?(phone, data, possible = T.unsafe(nil)); end

  # checks if types has both :mobile and :fixed_line and replaces it with
  # :fixed_or_mobile in case both present
  def sanitize_fixed_mobile(types); end

  # Returns regex for type with special types if needed
  #
  # ==== Attributes
  #
  # * +data+ - country types data for single type
  # * +type+ - possible or valid regex type needed
  def type_regex(data, type); end

  # returns array of phone types for check for current country data
  #
  # ==== Attributes
  #
  # * +data+  - country data hash
  def types_for_check(data); end

  # converts symbols in phone to numbers
  def vanity_converted(phone); end
end

# module provides extended data methods for parsed phone
module Phonelib::PhoneExtendedData
  # Returns carrier of parsed phone number or nil if number is invalid or
  # there is no carrier specified in db for this number
  def carrier; end

  # Returns geo name of parsed phone number or nil if number is invalid or
  # there is no geo name specified in db for this number
  def geo_name; end

  # Returns timezone of parsed phone number or nil if number is invalid or
  # there is no timezone specified in db for this number
  def timezone; end

  # returns valid country name
  def valid_country_name; end

  private

  def default_ext_data; end
  def ext_data; end

  # ==== Attributes
  #
  # * +name_key+ - names array key from extended data hash
  # * +id_key+   - parameter id key in resolved extended data for number
  def get_ext_name(names_key, id_key); end
end

Phonelib::PhoneExtendedData::EXT_KEYS = T.let(T.unsafe(nil), Array)

# module includes all formatting methods
module Phonelib::PhoneFormatter
  # returns area code of parsed number
  def area_code; end

  # Returns the country code from the original phone number.
  def country_code; end

  # Returns e164 unformatted phone number
  def e164(prefix = T.unsafe(nil)); end

  # returns e164 format of phone with extension added
  def full_e164(prefix = T.unsafe(nil)); end

  # returns international formatted number with extension added
  def full_international(prefix = T.unsafe(nil)); end

  # returns national formatted number with extension added
  def full_national; end

  # Returns e164 formatted phone number. Method can receive single string parameter that will be defined as prefix
  def international(formatted = T.unsafe(nil), prefix = T.unsafe(nil)); end

  def method_missing(method, *args); end

  # Returns formatted national number
  def national(formatted = T.unsafe(nil)); end

  # Returns the raw national number that was defined during parsing
  def raw_national; end

  private

  def area_code_possible?; end
  def country_prefix_or_not; end
  def formatted_extension; end
  def formatting_data; end
end
