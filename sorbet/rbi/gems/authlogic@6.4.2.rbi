# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `authlogic` gem.
# Please instead update this file by running `bin/tapioca gem authlogic`.

module Authlogic; end
module Authlogic::ActsAsAuthentic; end

# Provides the base functionality for acts_as_authentic
module Authlogic::ActsAsAuthentic::Base
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Authlogic::Config
  mixes_in_class_methods ::Authlogic::ActsAsAuthentic::Base::Config

  class << self
    def included(klass); end
  end

  module GeneratedClassMethods
    def acts_as_authentic_config; end
    def acts_as_authentic_config=(value); end
    def acts_as_authentic_config?; end
    def acts_as_authentic_modules; end
    def acts_as_authentic_modules=(value); end
    def acts_as_authentic_modules?; end
  end

  module GeneratedInstanceMethods
    def acts_as_authentic_config; end
    def acts_as_authentic_config=(value); end
    def acts_as_authentic_config?; end
    def acts_as_authentic_modules; end
    def acts_as_authentic_modules=(value); end
    def acts_as_authentic_modules?; end
  end
end

# The primary configuration of a model (often, `User`) for use with
# authlogic. These methods become class methods of ::ActiveRecord::Base.
module Authlogic::ActsAsAuthentic::Base::Config
  # This includes a lot of helpful methods for authenticating records
  # which the Authlogic::Session module relies on. To use it just do:
  #
  # class User < ApplicationRecord
  # acts_as_authentic
  # end
  #
  # Configuration is easy:
  #
  # acts_as_authentic do |c|
  # c.my_configuration_option = my_value
  # end
  #
  # See the various sub modules for the configuration they provide.
  def acts_as_authentic; end

  # Since this part of Authlogic deals with another class, ActiveRecord,
  # we can't just start including things in ActiveRecord itself. A lot of
  # these module includes need to be triggered by the acts_as_authentic
  # method call. For example, you don't want to start adding in email
  # validations and what not into a model that has nothing to do with
  # Authlogic.
  #
  # That being said, this is your tool for extending Authlogic and
  # "hooking" into the acts_as_authentic call.
  def add_acts_as_authentic_module(mod, action = T.unsafe(nil)); end

  # Some Authlogic modules requires a database connection with a existing
  # users table by the moment when you call the `acts_as_authentic`
  # method. If you try to call `acts_as_authentic` without a database
  # connection, it will raise a `Authlogic::ModelSetupError`.
  #
  # If you rely on the User model before the database is setup correctly,
  # set this field to false.
  # * <tt>Default:</tt> false
  # * <tt>Accepts:</tt> Boolean
  def raise_on_model_setup_error(value = T.unsafe(nil)); end

  # Some Authlogic modules requires a database connection with a existing
  # users table by the moment when you call the `acts_as_authentic`
  # method. If you try to call `acts_as_authentic` without a database
  # connection, it will raise a `Authlogic::ModelSetupError`.
  #
  # If you rely on the User model before the database is setup correctly,
  # set this field to false.
  # * <tt>Default:</tt> false
  # * <tt>Accepts:</tt> Boolean
  def raise_on_model_setup_error=(value = T.unsafe(nil)); end

  # This is the same as add_acts_as_authentic_module, except that it
  # removes the module from the list.
  def remove_acts_as_authentic_module(mod); end

  private

  def db_setup?; end
  def first_column_to_exist(*columns_to_check); end
end

# Sometimes models won't have an explicit "login" or "username" field.
# Instead they want to use the email field. In this case, authlogic provides
# validations to make sure the email submited is actually a valid email.
# Don't worry, if you do have a login or username field, Authlogic will
# still validate your email field. One less thing you have to worry about.
module Authlogic::ActsAsAuthentic::Email
  mixes_in_class_methods ::Authlogic::ActsAsAuthentic::Email::Config

  class << self
    def included(klass); end
  end
end

# Configuration to modify how Authlogic handles the email field.
module Authlogic::ActsAsAuthentic::Email::Config
  # The name of the field that stores email addresses.
  #
  # * <tt>Default:</tt> :email, if it exists
  # * <tt>Accepts:</tt> Symbol
  def email_field(value = T.unsafe(nil)); end

  # The name of the field that stores email addresses.
  #
  # * <tt>Default:</tt> :email, if it exists
  # * <tt>Accepts:</tt> Symbol
  def email_field=(value = T.unsafe(nil)); end
end

# Since web applications are stateless there is not sure fire way to tell if
# a user is logged in or not, from the database perspective. The best way to
# do this is to provide a "timeout" based on inactivity. So if that user is
# inactive for a certain amount of time we assume they are logged out.
# That's what this module is all about.
module Authlogic::ActsAsAuthentic::LoggedInStatus
  mixes_in_class_methods ::Authlogic::ActsAsAuthentic::LoggedInStatus::Config

  class << self
    def included(klass); end
  end
end

# All configuration for the logged in status feature set.
module Authlogic::ActsAsAuthentic::LoggedInStatus::Config
  # The timeout to determine when a user is logged in or not.
  #
  # * <tt>Default:</tt> 10.minutes
  # * <tt>Accepts:</tt> Fixnum
  def logged_in_timeout(value = T.unsafe(nil)); end

  # The timeout to determine when a user is logged in or not.
  #
  # * <tt>Default:</tt> 10.minutes
  # * <tt>Accepts:</tt> Fixnum
  def logged_in_timeout=(value = T.unsafe(nil)); end
end

# All methods for the logged in status feature seat.
module Authlogic::ActsAsAuthentic::LoggedInStatus::Methods
  class << self
    def included(klass); end
  end
end

module Authlogic::ActsAsAuthentic::LoggedInStatus::Methods::InstanceMethods
  # Returns true if the last_request_at > logged_in_timeout.
  def logged_in?; end

  # Opposite of logged_in?
  def logged_out?; end

  private

  def logged_in_timeout; end
end

# Handles everything related to the login field.
module Authlogic::ActsAsAuthentic::Login
  mixes_in_class_methods ::Authlogic::ActsAsAuthentic::Login::Config

  class << self
    def included(klass); end
  end
end

# Configuration for the login field.
module Authlogic::ActsAsAuthentic::Login::Config
  # This method allows you to find a record with the given login. If you
  # notice, with Active Record you have the UniquenessValidator class.
  # They give you a :case_sensitive option. I handle this in the same
  # manner that they handle that. If you are using the login field, set
  # false for the :case_sensitive option in
  # validates_uniqueness_of_login_field_options and the column doesn't
  # have a case-insensitive collation, this method will modify the query
  # to look something like:
  #
  # "LOWER(#{quoted_table_name}.#{login_field}) = LOWER(#{login})"
  #
  # If you don't specify this it just uses a regular case-sensitive search
  # (with the binary modifier if necessary):
  #
  # "BINARY #{login_field} = #{login}"
  #
  # The above also applies for using email as your login, except that you
  # need to set the :case_sensitive in
  # validates_uniqueness_of_email_field_options to false.
  def find_by_smart_case_login_field(login); end

  # The name of the login field in the database.
  #
  # * <tt>Default:</tt> :login or :username, if they exist
  # * <tt>Accepts:</tt> Symbol
  def login_field(value = T.unsafe(nil)); end

  # The name of the login field in the database.
  #
  # * <tt>Default:</tt> :login or :username, if they exist
  # * <tt>Accepts:</tt> Symbol
  def login_field=(value = T.unsafe(nil)); end

  private

  def find_with_case(field, value, sensitive); end
end

# Magic columns are like ActiveRecord's created_at and updated_at columns.
# They are "magically" maintained for you. Authlogic has the same thing, but
# these are maintained on the session side. Please see "Magic Columns" in
# `Session::Base` for more details. This module merely adds validations for
# the magic columns if they exist.
module Authlogic::ActsAsAuthentic::MagicColumns
  class << self
    def included(klass); end
  end
end

# Methods relating to the magic columns
module Authlogic::ActsAsAuthentic::MagicColumns::Methods
  class << self
    def included(klass); end
  end
end

# This module has a lot of neat functionality. It is responsible for encrypting your
# password, salting it, and verifying it. It can also help you transition to a new
# encryption algorithm. See the Config sub module for configuration options.
module Authlogic::ActsAsAuthentic::Password
  mixes_in_class_methods ::Authlogic::ActsAsAuthentic::Password::Config

  class << self
    def included(klass); end
  end
end

# Callbacks / hooks to allow other modules to modify the behavior of this module.
module Authlogic::ActsAsAuthentic::Password::Callbacks
  class << self
    def included(klass); end
  end
end

# Does the order of this array matter?
Authlogic::ActsAsAuthentic::Password::Callbacks::METHODS = T.let(T.unsafe(nil), Array)

# All configuration for the password aspect of acts_as_authentic.
module Authlogic::ActsAsAuthentic::Password::Config
  # When calling valid_password?("some pass") do you want to check that password
  # against what's in that object or whats in the database. Take this example:
  #
  # u = User.first
  # u.password = "new pass"
  # u.valid_password?("old pass")
  #
  # Should the last line above return true or false? The record hasn't been saved
  # yet, so most would assume true. Other would assume false. So I let you decide by
  # giving you this option.
  #
  # * <tt>Default:</tt> true
  # * <tt>Accepts:</tt> Boolean
  def check_passwords_against_database(value = T.unsafe(nil)); end

  # When calling valid_password?("some pass") do you want to check that password
  # against what's in that object or whats in the database. Take this example:
  #
  # u = User.first
  # u.password = "new pass"
  # u.valid_password?("old pass")
  #
  # Should the last line above return true or false? The record hasn't been saved
  # yet, so most would assume true. Other would assume false. So I let you decide by
  # giving you this option.
  #
  # * <tt>Default:</tt> true
  # * <tt>Accepts:</tt> Boolean
  def check_passwords_against_database=(value = T.unsafe(nil)); end

  # The name of the crypted_password field in the database.
  #
  # * <tt>Default:</tt> :crypted_password, :encrypted_password, :password_hash, or :pw_hash
  # * <tt>Accepts:</tt> Symbol
  def crypted_password_field(value = T.unsafe(nil)); end

  # The name of the crypted_password field in the database.
  #
  # * <tt>Default:</tt> :crypted_password, :encrypted_password, :password_hash, or :pw_hash
  # * <tt>Accepts:</tt> Symbol
  def crypted_password_field=(value = T.unsafe(nil)); end

  # The class you want to use to encrypt and verify your encrypted
  # passwords. See the Authlogic::CryptoProviders module for more info on
  # the available methods and how to create your own.
  #
  # The family of adaptive hash functions (BCrypt, SCrypt, PBKDF2) is the
  # best choice for password storage today. We recommend SCrypt. Other
  # one-way functions like SHA512 are inferior, but widely used.
  # Reversible functions like AES256 are the worst choice, and we no
  # longer support them.
  #
  # You can use the `transition_from_crypto_providers` option to gradually
  # transition to a better crypto provider without causing your users any
  # pain.
  #
  # * <tt>Default:</tt> There is no longer a default value. Prior to
  # Authlogic 6, the default was `CryptoProviders::SCrypt`. If you try
  # to read this config option before setting it, it will raise a
  # `NilCryptoProvider` error. See that error's message for further
  # details, and rationale for this change.
  # * <tt>Accepts:</tt> Class
  def crypto_provider; end

  def crypto_provider=(value); end

  # By default passwords are required when a record is new or the crypted_password
  # is blank, but if both of these things are met a password is not required. In
  # this case, blank passwords are ignored.
  #
  # Think about a profile page, where the user can edit all of their information,
  # including changing their password. If they do not want to change their password
  # they just leave the fields blank. This will try to set the password to a blank
  # value, in which case is incorrect behavior. As such, Authlogic ignores this. But
  # let's say you have a completely separate page for resetting passwords, you might
  # not want to ignore blank passwords. If this is the case for you, then just set
  # this value to false.
  #
  # * <tt>Default:</tt> true
  # * <tt>Accepts:</tt> Boolean
  def ignore_blank_passwords(value = T.unsafe(nil)); end

  # By default passwords are required when a record is new or the crypted_password
  # is blank, but if both of these things are met a password is not required. In
  # this case, blank passwords are ignored.
  #
  # Think about a profile page, where the user can edit all of their information,
  # including changing their password. If they do not want to change their password
  # they just leave the fields blank. This will try to set the password to a blank
  # value, in which case is incorrect behavior. As such, Authlogic ignores this. But
  # let's say you have a completely separate page for resetting passwords, you might
  # not want to ignore blank passwords. If this is the case for you, then just set
  # this value to false.
  #
  # * <tt>Default:</tt> true
  # * <tt>Accepts:</tt> Boolean
  def ignore_blank_passwords=(value = T.unsafe(nil)); end

  # The name of the password_salt field in the database.
  #
  # * <tt>Default:</tt> :password_salt, :pw_salt, :salt, nil if none exist
  # * <tt>Accepts:</tt> Symbol
  def password_salt_field(value = T.unsafe(nil)); end

  # The name of the password_salt field in the database.
  #
  # * <tt>Default:</tt> :password_salt, :pw_salt, :salt, nil if none exist
  # * <tt>Accepts:</tt> Symbol
  def password_salt_field=(value = T.unsafe(nil)); end

  # Whether or not to require a password confirmation. If you don't want your users
  # to confirm their password just set this to false.
  #
  # * <tt>Default:</tt> true
  # * <tt>Accepts:</tt> Boolean
  def require_password_confirmation(value = T.unsafe(nil)); end

  # Whether or not to require a password confirmation. If you don't want your users
  # to confirm their password just set this to false.
  #
  # * <tt>Default:</tt> true
  # * <tt>Accepts:</tt> Boolean
  def require_password_confirmation=(value = T.unsafe(nil)); end

  # Let's say you originally encrypted your passwords with Sha1. Sha1 is
  # starting to join the party with MD5 and you want to switch to
  # something stronger. No problem, just specify your new and improved
  # algorithm with the crypt_provider option and then let Authlogic know
  # you are transitioning from Sha1 using this option. Authlogic will take
  # care of everything, including transitioning your users to the new
  # algorithm. The next time a user logs in, they will be granted access
  # using the old algorithm and their password will be resaved with the
  # new algorithm. All new users will obviously use the new algorithm as
  # well.
  #
  # Lastly, if you want to transition again, you can pass an array of
  # crypto providers. So you can transition from as many algorithms as you
  # want.
  #
  # * <tt>Default:</tt> nil
  # * <tt>Accepts:</tt> Class or Array
  def transition_from_crypto_providers(value = T.unsafe(nil)); end

  # Let's say you originally encrypted your passwords with Sha1. Sha1 is
  # starting to join the party with MD5 and you want to switch to
  # something stronger. No problem, just specify your new and improved
  # algorithm with the crypt_provider option and then let Authlogic know
  # you are transitioning from Sha1 using this option. Authlogic will take
  # care of everything, including transitioning your users to the new
  # algorithm. The next time a user logs in, they will be granted access
  # using the old algorithm and their password will be resaved with the
  # new algorithm. All new users will obviously use the new algorithm as
  # well.
  #
  # Lastly, if you want to transition again, you can pass an array of
  # crypto providers. So you can transition from as many algorithms as you
  # want.
  #
  # * <tt>Default:</tt> nil
  # * <tt>Accepts:</tt> Class or Array
  def transition_from_crypto_providers=(value = T.unsafe(nil)); end
end

# The methods related to the password field.
module Authlogic::ActsAsAuthentic::Password::Methods
  class << self
    def included(klass); end
  end
end

module Authlogic::ActsAsAuthentic::Password::Methods::InstanceMethods
  # The password
  def password; end

  # This is a virtual method. Once a password is passed to it, it will
  # create new password salt as well as encrypt the password.
  def password=(pass); end

  # Resets the password to a random friendly token.
  def randomize_password; end

  # Resets the password to a random friendly token and then saves the record.
  def randomize_password!; end

  # Resets the password to a random friendly token.
  def reset_password; end

  # Resets the password to a random friendly token and then saves the record.
  def reset_password!; end

  # Accepts a raw password to determine if it is the correct password.
  #
  # - attempted_password [String] - password entered by user
  # - check_against_database [boolean] - Should we check the password
  # against the value in the database or the value in the object?
  # Default taken from config option check_passwords_against_database.
  # See config method for more information.
  def valid_password?(attempted_password, check_against_database = T.unsafe(nil)); end

  private

  def check_passwords_against_database?; end
  def crypted_password_field; end
  def crypted_password_to_validate_against(check_against_database); end
  def crypto_provider; end
  def crypto_providers; end

  # Returns an array of arguments to be passed to a crypto provider, either its
  # `matches?` or its `encrypt` method.
  def encrypt_arguments(raw_password, check_against_database); end

  # Given `encryptor`, does `attempted_password` match the `crypted` password?
  def encryptor_matches?(crypted, encryptor, attempted_password, check_against_database); end

  def ignore_blank_passwords?; end
  def password_changed?; end
  def password_salt_field; end
  def require_password?; end
  def reset_password_changed; end
  def transition_from_crypto_providers; end
  def transition_password(attempted_password); end

  # Determines if we need to transition the password.
  #
  # - If the index > 0 then we are using a "transition from" crypto
  # provider.
  # - If the encryptor has a cost and the cost it outdated.
  # - If we aren't using database values
  # - If we are using database values, only if the password hasn't
  # changed so we don't overwrite any changes
  def transition_password?(index, encryptor, check_against_database); end
end

# This provides a handy token that is "perishable", meaning the token is
# only good for a certain amount of time.
#
# This is useful for resetting password, confirming accounts, etc. Typically
# during these actions you send them this token in an email. Once they use
# the token and do what they need to do, that token should expire.
#
# Don't worry about maintaining the token, changing it, or expiring it
# yourself. Authlogic does all of this for you. See the sub modules for all
# of the tools Authlogic provides to you.
module Authlogic::ActsAsAuthentic::PerishableToken
  mixes_in_class_methods ::Authlogic::ActsAsAuthentic::PerishableToken::Config

  class << self
    def included(klass); end
  end
end

# Configure the perishable token.
module Authlogic::ActsAsAuthentic::PerishableToken::Config
  # Authlogic tries to expire and change the perishable token as much as
  # possible, without compromising its purpose. If you want to manage it
  # yourself, set this to true.
  #
  # * <tt>Default:</tt> false
  # * <tt>Accepts:</tt> Boolean
  def disable_perishable_token_maintenance(value = T.unsafe(nil)); end

  # Authlogic tries to expire and change the perishable token as much as
  # possible, without compromising its purpose. If you want to manage it
  # yourself, set this to true.
  #
  # * <tt>Default:</tt> false
  # * <tt>Accepts:</tt> Boolean
  def disable_perishable_token_maintenance=(value = T.unsafe(nil)); end

  # When using the find_using_perishable_token method the token can
  # expire. If the token is expired, no record will be returned. Use this
  # option to specify how long the token is valid for.
  #
  # * <tt>Default:</tt> 10.minutes
  # * <tt>Accepts:</tt> Fixnum
  def perishable_token_valid_for(value = T.unsafe(nil)); end

  # When using the find_using_perishable_token method the token can
  # expire. If the token is expired, no record will be returned. Use this
  # option to specify how long the token is valid for.
  #
  # * <tt>Default:</tt> 10.minutes
  # * <tt>Accepts:</tt> Fixnum
  def perishable_token_valid_for=(value = T.unsafe(nil)); end
end

# All methods relating to the perishable token.
module Authlogic::ActsAsAuthentic::PerishableToken::Methods
  class << self
    def included(klass); end
  end
end

module Authlogic::ActsAsAuthentic::PerishableToken::Methods::ClassMethods
  # Use this method to find a record with a perishable token. This
  # method does 2 things for you:
  #
  # 1. It ignores blank tokens
  # 2. It enforces the perishable_token_valid_for configuration option.
  #
  # If you want to use a different timeout value, just pass it as the
  # second parameter:
  #
  # User.find_using_perishable_token(token, 1.hour)
  def find_using_perishable_token(token, age = T.unsafe(nil)); end

  # This method will raise ActiveRecord::NotFound if no record is found.
  def find_using_perishable_token!(token, age = T.unsafe(nil)); end
end

module Authlogic::ActsAsAuthentic::PerishableToken::Methods::InstanceMethods
  # A convenience method based on the
  # disable_perishable_token_maintenance configuration option.
  def disable_perishable_token_maintenance?; end

  # Resets the perishable token to a random friendly token.
  def reset_perishable_token; end

  # Same as reset_perishable_token, but then saves the record afterwards.
  def reset_perishable_token!; end
end

# Maintains the persistence token, the token responsible for persisting sessions. This token
# gets stored in the session and the cookie.
module Authlogic::ActsAsAuthentic::PersistenceToken
  class << self
    def included(klass); end
  end
end

# Methods for the persistence token.
module Authlogic::ActsAsAuthentic::PersistenceToken::Methods
  include ::Authlogic::ActsAsAuthentic::PersistenceToken::Methods::InstanceMethods

  mixes_in_class_methods ::Authlogic::ActsAsAuthentic::PersistenceToken::Methods::ClassMethods

  class << self
    def included(klass); end
  end
end

module Authlogic::ActsAsAuthentic::PersistenceToken::Methods::ClassMethods
  # Resets ALL persistence tokens in the database, which will require
  # all users to re-authenticate.
  def forget_all; end
end

module Authlogic::ActsAsAuthentic::PersistenceToken::Methods::InstanceMethods
  # Same as reset_persistence_token, but then saves the record.
  def forget!; end

  # Resets the persistence_token field to a random hex value.
  def reset_persistence_token; end

  # Same as reset_persistence_token, but then saves the record.
  def reset_persistence_token!; end

  private

  def reset_persistence_token?; end
end

module Authlogic::ActsAsAuthentic::Queries; end

class Authlogic::ActsAsAuthentic::Queries::CaseSensitivity
  def initialize(model_class, attribute); end

  def sensitive?; end

  private

  def uniqueness_validator; end
  def uniqueness_validator_options; end
end

Authlogic::ActsAsAuthentic::Queries::CaseSensitivity::E_UNABLE_TO_DETERMINE_SENSITIVITY = T.let(T.unsafe(nil), String)

# The query used by public-API method `find_by_smart_case_login_field`.
#
# We use the rails methods `case_insensitive_comparison` and
# `case_sensitive_comparison`. These methods nicely take into account
# MySQL collations. (Consider the case where a user *says* they want a
# case-sensitive uniqueness validation, but then they configure their
# database to have an insensitive collation. Rails will handle this for
# us, by downcasing, see
# `active_record/connection_adapters/abstract_mysql_adapter.rb`) So that's
# great! But, these methods are not part of rails' public API, so there
# are no docs. So, everything we know about how to use the methods
# correctly comes from mimicing what we find in
# `active_record/validations/uniqueness.rb`.
class Authlogic::ActsAsAuthentic::Queries::FindWithCase
  def initialize(model_class, field, value, sensitive); end

  def execute; end

  private

  def comparison; end
  def insensitive_comparison; end
  def sensitive_comparison; end
end

# Dup ActiveRecord.gem_version before freezing, in case someone
# else wants to modify it. Freezing modifies an object in place.
# https://github.com/binarylogic/authlogic/pull/590
Authlogic::ActsAsAuthentic::Queries::FindWithCase::AR_GEM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# This is one of my favorite features that I think is pretty cool. It's
# things like this that make a library great and let you know you are on the
# right track.
#
# Just to clear up any confusion, Authlogic stores both the record id and
# the persistence token in the session. Why? So stale sessions can not be
# persisted. It stores the id so it can quickly find the record, and the
# persistence token to ensure no sessions are stale. So if the persistence
# token changes, the user must log back in.
#
# Well, the persistence token changes with the password. What happens if the
# user changes his own password? He shouldn't have to log back in, he's the
# one that made the change.
#
# That being said, wouldn't it be nice if their session and cookie
# information was automatically updated? Instead of cluttering up your
# controller with redundant session code. The same thing goes for new
# registrations.
#
# That's what this module is all about. This will automatically maintain the
# cookie and session values as records are saved.
module Authlogic::ActsAsAuthentic::SessionMaintenance
  mixes_in_class_methods ::Authlogic::ActsAsAuthentic::SessionMaintenance::Config

  class << self
    def included(klass); end
  end
end

# Configuration for the session maintenance aspect of acts_as_authentic.
# These methods become class methods of ::ActiveRecord::Base.
module Authlogic::ActsAsAuthentic::SessionMaintenance::Config
  # In order to turn off automatic maintenance of sessions
  # after create, just set this to false.
  #
  # * <tt>Default:</tt> true
  # * <tt>Accepts:</tt> Boolean
  def log_in_after_create(value = T.unsafe(nil)); end

  # In order to turn off automatic maintenance of sessions
  # after create, just set this to false.
  #
  # * <tt>Default:</tt> true
  # * <tt>Accepts:</tt> Boolean
  def log_in_after_create=(value = T.unsafe(nil)); end

  # In order to turn off automatic maintenance of sessions when updating
  # the password, just set this to false.
  #
  # * <tt>Default:</tt> true
  # * <tt>Accepts:</tt> Boolean
  def log_in_after_password_change(value = T.unsafe(nil)); end

  # In order to turn off automatic maintenance of sessions when updating
  # the password, just set this to false.
  #
  # * <tt>Default:</tt> true
  # * <tt>Accepts:</tt> Boolean
  def log_in_after_password_change=(value = T.unsafe(nil)); end

  # The name of the associated session class. This is inferred by the name
  # of the model.
  #
  # * <tt>Default:</tt> "#{klass.name}Session".constantize
  # * <tt>Accepts:</tt> Class
  def session_class(value = T.unsafe(nil)); end

  # The name of the associated session class. This is inferred by the name
  # of the model.
  #
  # * <tt>Default:</tt> "#{klass.name}Session".constantize
  # * <tt>Accepts:</tt> Class
  def session_class=(value = T.unsafe(nil)); end

  # As you may know, authlogic sessions can be separate by id (See
  # Authlogic::Session::Base#id). You can specify here what session ids
  # you want auto maintained. By default it is the main session, which has
  # an id of nil.
  #
  # * <tt>Default:</tt> [nil]
  # * <tt>Accepts:</tt> Array
  def session_ids(value = T.unsafe(nil)); end

  # As you may know, authlogic sessions can be separate by id (See
  # Authlogic::Session::Base#id). You can specify here what session ids
  # you want auto maintained. By default it is the main session, which has
  # an id of nil.
  #
  # * <tt>Default:</tt> [nil]
  # * <tt>Accepts:</tt> Array
  def session_ids=(value = T.unsafe(nil)); end
end

# This module, as one of the `acts_as_authentic_modules`, is only included
# into an ActiveRecord model if that model calls `acts_as_authentic`.
module Authlogic::ActsAsAuthentic::SessionMaintenance::Methods
  # Save the record and skip session maintenance all together.
  def save_without_session_maintenance(**options); end

  private

  def create_session; end
  def get_session_information; end
  def log_in_after_create?; end
  def log_in_after_password_change?; end
  def maintain_session?; end
  def maintain_sessions; end
  def session_class; end
  def session_ids; end
  def skip_session_maintenance; end
  def skip_session_maintenance=(value); end
  def update_sessions; end
  def update_sessions?; end

  class << self
    def included(klass); end
  end
end

# This module is responsible for maintaining the single_access token. For
# more information the single access token and how to use it, see "Params"
# in `Session::Base`.
module Authlogic::ActsAsAuthentic::SingleAccessToken
  mixes_in_class_methods ::Authlogic::ActsAsAuthentic::SingleAccessToken::Config

  class << self
    def included(klass); end
  end
end

# All configuration for the single_access token aspect of acts_as_authentic.
#
# These methods become class methods of ::ActiveRecord::Base.
module Authlogic::ActsAsAuthentic::SingleAccessToken::Config
  # The single access token is used for authentication via URLs, such as a private
  # feed. That being said, if the user changes their password, that token probably
  # shouldn't change. If it did, the user would have to update all of their URLs. So
  # be default this is option is disabled, if you need it, feel free to turn it on.
  #
  # * <tt>Default:</tt> false
  # * <tt>Accepts:</tt> Boolean
  def change_single_access_token_with_password(value = T.unsafe(nil)); end

  # The single access token is used for authentication via URLs, such as a private
  # feed. That being said, if the user changes their password, that token probably
  # shouldn't change. If it did, the user would have to update all of their URLs. So
  # be default this is option is disabled, if you need it, feel free to turn it on.
  #
  # * <tt>Default:</tt> false
  # * <tt>Accepts:</tt> Boolean
  def change_single_access_token_with_password=(value = T.unsafe(nil)); end
end

# All method, for the single_access token aspect of acts_as_authentic.
#
# This module, as one of the `acts_as_authentic_modules`, is only included
# into an ActiveRecord model if that model calls `acts_as_authentic`.
module Authlogic::ActsAsAuthentic::SingleAccessToken::Methods
  class << self
    def included(klass); end
  end
end

module Authlogic::ActsAsAuthentic::SingleAccessToken::Methods::InstanceMethods
  # Resets the single_access_token to a random friendly token.
  def reset_single_access_token; end

  # same as reset_single_access_token, but then saves the record.
  def reset_single_access_token!; end

  protected

  def change_single_access_token_with_password?; end
  def reset_single_access_token?; end
end

# Mixed into `Authlogic::ActsAsAuthentic::Base` and
# `Authlogic::Session::Base`.
module Authlogic::Config
  private

  def deprecate_authlogic_config(method_name); end

  # This is a one-liner method to write a config setting, read the config
  # setting, and also set a default value for the setting.
  def rw_config(key, value, default_value = T.unsafe(nil)); end

  class << self
    def extended(klass); end
  end
end

Authlogic::Config::E_USE_NORMAL_RAILS_VALIDATION = T.let(T.unsafe(nil), String)
module Authlogic::ControllerAdapters; end

# Allows you to use Authlogic in any framework you want, not just rails. See
# the RailsAdapter for an example of how to adapt Authlogic to work with
# your framework.
class Authlogic::ControllerAdapters::AbstractAdapter
  def initialize(controller); end

  def authenticate_with_http_basic; end

  # Returns the value of attribute controller.
  def controller; end

  # Sets the attribute controller
  def controller=(_arg0); end

  def cookie_domain; end
  def cookies; end

  # You can disable the updating of `last_request_at`
  # on a per-controller basis.
  #
  # # in your controller
  # def last_request_update_allowed?
  # false
  # end
  #
  # For example, what if you had a javascript function that polled the
  # server updating how much time is left in their session before it
  # times out. Obviously you would want to ignore this request, because
  # then the user would never time out. So you can do something like
  # this in your controller:
  #
  # def last_request_update_allowed?
  # action_name != "update_session_time_left"
  # end
  #
  # See `authlogic/session/magic_columns.rb` to learn more about the
  # `last_request_at` column itself.
  def last_request_update_allowed?; end

  def params; end

  # Inform Rack that we would like a new session ID to be assigned. Changes
  # the ID, but not the contents of the session.
  #
  # The `:renew` option is read by `rack/session/abstract/id.rb`.
  #
  # This is how Devise (via warden) implements defense against Session
  # Fixation. Our implementation is copied directly from the warden gem
  # (set_user in warden/proxy.rb)
  def renew_session_id; end

  def request; end
  def request_content_type; end
  def responds_to_single_access_allowed?; end
  def session; end
  def single_access_allowed?; end

  private

  def method_missing(id, *args, &block); end
  def respond_to_missing?(*args); end
end

Authlogic::ControllerAdapters::AbstractAdapter::ENV_SESSION_OPTIONS = T.let(T.unsafe(nil), String)
Authlogic::ControllerAdapters::AbstractAdapter::E_COOKIE_DOMAIN_ADAPTER = T.let(T.unsafe(nil), String)

# Adapts authlogic to work with rails. The point is to close the gap between
# what authlogic expects and what the rails controller object provides.
# Similar to how ActiveRecord has an adapter for MySQL, PostgreSQL, SQLite,
# etc.
class Authlogic::ControllerAdapters::RailsAdapter < ::Authlogic::ControllerAdapters::AbstractAdapter
  def authenticate_with_http_basic(&block); end
  def cookie_domain; end

  # Returns a `ActionDispatch::Cookies::CookieJar`. See the AC guide
  # http://guides.rubyonrails.org/action_controller_overview.html#cookies
  def cookies; end

  def request_content_type; end
end

# Lets Authlogic know about the controller object via a before filter, AKA
# "activates" authlogic.
module Authlogic::ControllerAdapters::RailsAdapter::RailsImplementation
  private

  def activate_authlogic; end

  class << self
    def included(klass); end
  end
end

# Represents the credentials *in* the cookie. The value of the cookie.
# This is primarily a data object. It doesn't interact with controllers.
# It doesn't know about eg. cookie expiration.
class Authlogic::CookieCredentials
  def initialize(persistence_token, record_id, remember_me_until); end

  def persistence_token; end
  def record_id; end
  def remember_me?; end
  def remember_me_until; end
  def to_s; end

  class << self
    def parse(string); end

    private

    def parse_time(string); end
  end
end

Authlogic::CookieCredentials::DELIMITER = T.let(T.unsafe(nil), String)
class Authlogic::CookieCredentials::ParseError < ::RuntimeError; end

# The acts_as_authentic method has a crypto_provider option. This allows you
# to use any type of encryption you like. Just create a class with a class
# level encrypt and matches? method. See example below.
#
# === Example
#
# class MyAwesomeEncryptionMethod
# def self.encrypt(*tokens)
# # The tokens passed will be an array of objects, what type of object
# # is irrelevant, just do what you need to do with them and return a
# # single encrypted string. For example, you will most likely join all
# # of the objects into a single string and then encrypt that string.
# end
#
# def self.matches?(crypted, *tokens)
# # Return true if the crypted string matches the tokens. Depending on
# # your algorithm you might decrypt the string then compare it to the
# # token, or you might encrypt the tokens and make sure it matches the
# # crypted string, its up to you.
# end
# end
module Authlogic::CryptoProviders; end

# Guide users to choose a better crypto provider.
class Authlogic::CryptoProviders::Guidance
  def initialize(provider); end

  def impart_wisdom; end
end

Authlogic::CryptoProviders::Guidance::BUILTIN_PROVIDER_PREFIX = T.let(T.unsafe(nil), String)
Authlogic::CryptoProviders::Guidance::NONADAPTIVE_ALGORITHM = T.let(T.unsafe(nil), String)
Authlogic::CryptoProviders::Guidance::VULNERABLE_ALGORITHM = T.let(T.unsafe(nil), String)

# A poor choice. There are known attacks against this algorithm.
class Authlogic::CryptoProviders::MD5
  class << self
    # Turns your raw password into a MD5 hash.
    def encrypt(*tokens); end

    # Returns the value of attribute join_token.
    def join_token; end

    # Sets the attribute join_token
    def join_token=(_arg0); end

    # Does the crypted password match the tokens? Uses the same tokens that
    # were used to encrypt.
    def matches?(crypted, *tokens); end

    # The number of times to loop through the encryption.
    def stretches; end

    # Sets the attribute stretches
    def stretches=(_arg0); end
  end
end

# A poor choice. There are known attacks against this algorithm.
class Authlogic::CryptoProviders::MD5::V2
  class << self
    # Turns your raw password into a MD5 hash.
    def encrypt(*tokens); end

    # Returns the value of attribute join_token.
    def join_token; end

    # Sets the attribute join_token
    def join_token=(_arg0); end

    # Does the crypted password match the tokens? Uses the same tokens that
    # were used to encrypt.
    def matches?(crypted, *tokens); end

    # The number of times to loop through the encryption.
    def stretches; end

    # Sets the attribute stretches
    def stretches=(_arg0); end
  end
end

# SCrypt is the default provider for Authlogic. It is the only
# choice in the adaptive hash family that accounts for hardware
# based attacks by compensating with memory bound as well as cpu
# bound computational constraints. It offers the same guarantees
# as BCrypt in the way of one-way, unique and slow.
#
# Decided SCrypt is for you? Just install the scrypt gem:
#
# gem install scrypt
#
# Tell acts_as_authentic to use it:
#
# acts_as_authentic do |c|
# c.crypto_provider = Authlogic::CryptoProviders::SCrypt
# end
class Authlogic::CryptoProviders::SCrypt
  class << self
    # Creates an SCrypt hash for the password passed.
    def encrypt(*tokens); end

    # Key length - length in bytes of generated key, from 16 to 512.
    def key_len; end

    # Sets the attribute key_len
    def key_len=(_arg0); end

    # Does the hash match the tokens? Uses the same tokens that were used to encrypt.
    def matches?(hash, *tokens); end

    # Max memory - maximum memory usage. The minimum is always 1MB
    def max_mem; end

    # Sets the attribute max_mem
    def max_mem=(_arg0); end

    # Max memory fraction - maximum memory out of all available. Always
    # greater than zero and <= 0.5.
    def max_memfrac; end

    # Sets the attribute max_memfrac
    def max_memfrac=(_arg0); end

    # Max time - maximum time spent in computation
    def max_time; end

    # Sets the attribute max_time
    def max_time=(_arg0); end

    # Salt size - size in bytes of random salt, from 8 to 32
    def salt_size; end

    # Sets the attribute salt_size
    def salt_size=(_arg0); end

    private

    def join_tokens(tokens); end
    def new_from_hash(hash); end
  end
end

# A poor choice. There are known attacks against this algorithm.
class Authlogic::CryptoProviders::Sha1
  class << self
    # Turns your raw password into a Sha1 hash.
    def encrypt(*tokens); end

    def join_token; end

    # Sets the attribute join_token
    def join_token=(_arg0); end

    # Does the crypted password match the tokens? Uses the same tokens that
    # were used to encrypt.
    def matches?(crypted, *tokens); end

    # The number of times to loop through the encryption.
    def stretches; end

    # Sets the attribute stretches
    def stretches=(_arg0); end
  end
end

# A poor choice. There are known attacks against this algorithm.
class Authlogic::CryptoProviders::Sha1::V2
  class << self
    # Turns your raw password into a Sha1 hash.
    def encrypt(*tokens); end

    def join_token; end

    # Sets the attribute join_token
    def join_token=(_arg0); end

    # Does the crypted password match the tokens? Uses the same tokens that
    # were used to encrypt.
    def matches?(crypted, *tokens); end

    # The number of times to loop through the encryption.
    def stretches; end

    # Sets the attribute stretches
    def stretches=(_arg0); end
  end
end

# = Sha256
#
# Uses the Sha256 hash algorithm to encrypt passwords.
class Authlogic::CryptoProviders::Sha256
  class << self
    # Turns your raw password into a Sha256 hash.
    def encrypt(*tokens); end

    # Returns the value of attribute join_token.
    def join_token; end

    # Sets the attribute join_token
    def join_token=(_arg0); end

    # Does the crypted password match the tokens? Uses the same tokens that
    # were used to encrypt.
    def matches?(crypted, *tokens); end

    # The number of times to loop through the encryption.
    def stretches; end

    # Sets the attribute stretches
    def stretches=(_arg0); end
  end
end

# = Sha256
#
# Uses the Sha256 hash algorithm to encrypt passwords.
class Authlogic::CryptoProviders::Sha256::V2
  class << self
    # Turns your raw password into a Sha256 hash.
    def encrypt(*tokens); end

    # Returns the value of attribute join_token.
    def join_token; end

    # Sets the attribute join_token
    def join_token=(_arg0); end

    # Does the crypted password match the tokens? Uses the same tokens that
    # were used to encrypt.
    def matches?(crypted, *tokens); end

    # The number of times to loop through the encryption.
    def stretches; end

    # Sets the attribute stretches
    def stretches=(_arg0); end
  end
end

# SHA-512 does not have any practical known attacks against it. However,
# there are better choices. We recommend transitioning to a more secure,
# adaptive hashing algorithm, like scrypt.
class Authlogic::CryptoProviders::Sha512
  class << self
    # Turns your raw password into a Sha512 hash.
    def encrypt(*tokens); end

    # Returns the value of attribute join_token.
    def join_token; end

    # Sets the attribute join_token
    def join_token=(_arg0); end

    # Does the crypted password match the tokens? Uses the same tokens that
    # were used to encrypt.
    def matches?(crypted, *tokens); end

    # The number of times to loop through the encryption.
    def stretches; end

    # Sets the attribute stretches
    def stretches=(_arg0); end
  end
end

# SHA-512 does not have any practical known attacks against it. However,
# there are better choices. We recommend transitioning to a more secure,
# adaptive hashing algorithm, like scrypt.
class Authlogic::CryptoProviders::Sha512::V2
  class << self
    # Turns your raw password into a Sha512 hash.
    def encrypt(*tokens); end

    # Returns the value of attribute join_token.
    def join_token; end

    # Sets the attribute join_token
    def join_token=(_arg0); end

    # Does the crypted password match the tokens? Uses the same tokens that
    # were used to encrypt.
    def matches?(crypted, *tokens); end

    # The number of times to loop through the encryption.
    def stretches; end

    # Sets the attribute stretches
    def stretches=(_arg0); end
  end
end

# Parent class of all Authlogic errors.
class Authlogic::Error < ::StandardError; end

# This class allows any message in Authlogic to use internationalization. In
# earlier versions of Authlogic each message was translated via configuration.
# This cluttered up the configuration and cluttered up Authlogic. So all
# translation has been extracted out into this class. Now all messages pass
# through this class, making it much easier to implement in I18n library /
# plugin you want. Use this as a layer that sits between Authlogic and
# whatever I18n library you want to use.
#
# By default this uses the rails I18n library, if it exists. If it doesn't
# exist it just returns the default English message. The Authlogic I18n class
# works EXACTLY like the rails I18n class. This is because the arguments are
# delegated to this class.
#
# Here is how all messages are translated internally with Authlogic:
#
# Authlogic::I18n.t('error_messages.password_invalid', :default => "is invalid")
#
# If you use a different I18n library just replace the build-in
# I18n::Translator class with your own. For example:
#
# class MyAuthlogicI18nTranslator
# def translate(key, options = {})
# # you will have key which will be something like:
# # "error_messages.password_invalid"
# # you will also have options[:default], which will be the default
# # English version of the message
# # do whatever you want here with the arguments passed to you.
# end
# end
#
# Authlogic::I18n.translator = MyAuthlogicI18nTranslator.new
#
# That it's! Here is a complete list of the keys that are passed. Just define
# these however you wish:
#
# authlogic:
# error_messages:
# login_blank: can not be blank
# login_not_found: is not valid
# login_invalid: should use only letters, numbers, spaces, and .-_@+ please.
# consecutive_failed_logins_limit_exceeded: >
# Consecutive failed logins limit exceeded, account is disabled.
# email_invalid: should look like an email address.
# email_invalid_international: should look like an international email address.
# password_blank: can not be blank
# password_invalid: is not valid
# not_active: Your account is not active
# not_confirmed: Your account is not confirmed
# not_approved: Your account is not approved
# no_authentication_details: You did not provide any details for authentication.
# general_credentials_error: Login/Password combination is not valid
# session_invalid: Your session is invalid and has the following errors:
# models:
# user_session: UserSession (or whatever name you are using)
# attributes:
# user_session: (or whatever name you are using)
# login: login
# email: email
# password: password
# remember_me: remember me
module Authlogic::I18n
  class << self
    # Returns the current scope. Defaults to :authlogic
    def scope; end

    # Sets the current scope. Used to set a custom scope.
    def scope=(scope); end

    # All message translation is passed to this method. The first argument is
    # the key for the message. The second is options, see the rails I18n
    # library for a list of options used.
    def t(key, options = T.unsafe(nil)); end

    # All message translation is passed to this method. The first argument is
    # the key for the message. The second is options, see the rails I18n
    # library for a list of options used.
    def translate(key, options = T.unsafe(nil)); end

    # Returns the current translator. Defaults to +Translator+.
    def translator; end

    # Sets the current translator. Used to set a custom translator.
    def translator=(translator); end
  end
end

# The default translator used by authlogic/i18n.rb
class Authlogic::I18n::Translator
  # If the I18n gem is present, calls +I18n.translate+ passing all
  # arguments, else returns +options[:default]+.
  def translate(key, options = T.unsafe(nil)); end
end

class Authlogic::InvalidCryptoProvider < ::Authlogic::Error; end

class Authlogic::ModelSetupError < ::Authlogic::Error
  def message; end
end

class Authlogic::NilCryptoProvider < ::Authlogic::InvalidCryptoProvider
  def message; end
end

# Generates random strings using ruby's SecureRandom library.
module Authlogic::Random
  class << self
    # Returns a string in base64url format as defined by RFC-3548 and RFC-4648.
    # We call this a "friendly" token because it is short and safe for URLs.
    def friendly_token; end

    def hex_token; end
  end
end

module Authlogic::Session; end
module Authlogic::Session::Activation; end

class Authlogic::Session::Activation::NotActivatedError < ::StandardError
  def initialize; end
end

# This is the most important class in Authlogic. You will inherit this class
# for your own eg. `UserSession`.
#
# Ongoing consolidation of modules
# ================================
#
# We are consolidating modules into this class (inlining mixins). When we
# are done, there will only be this one file. It will be quite large, but it
# will be easier to trace execution.
#
# Once consolidation is complete, we hope to identify and extract
# collaborating objects. For example, there may be a "session adapter" that
# connects this class with the existing `ControllerAdapters`. Perhaps a
# data object or a state machine will reveal itself.
#
# Activation
# ==========
#
# Activating Authlogic requires that you pass it an
# Authlogic::ControllerAdapters::AbstractAdapter object, or a class that
# extends it. This is sort of like a database connection for an ORM library,
# Authlogic can't do anything until it is "connected" to a controller. If
# you are using a supported framework, Authlogic takes care of this for you.
#
# ActiveRecord Trickery
# =====================
#
# Authlogic looks like ActiveRecord, sounds like ActiveRecord, but its not
# ActiveRecord. That's the goal here. This is useful for the various rails
# helper methods such as form_for, error_messages_for, or any method that
# expects an ActiveRecord object. The point is to disguise the object as an
# ActiveRecord object so we can take advantage of the many ActiveRecord
# tools.
#
# Brute Force Protection
# ======================
#
# A brute force attacks is executed by hammering a login with as many password
# combinations as possible, until one works. A brute force attacked is generally
# combated with a slow hashing algorithm such as BCrypt. You can increase the cost,
# which makes the hash generation slower, and ultimately increases the time it takes
# to execute a brute force attack. Just to put this into perspective, if a hacker was
# to gain access to your server and execute a brute force attack locally, meaning
# there is no network lag, it would probably take decades to complete. Now throw in
# network lag and it would take MUCH longer.
#
# But for those that are extra paranoid and can't get enough protection, why not stop
# them as soon as you realize something isn't right? That's what this module is all
# about. By default the consecutive_failed_logins_limit configuration option is set to
# 50, if someone consecutively fails to login after 50 attempts their account will be
# suspended. This is a very liberal number and at this point it should be obvious that
# something is not right. If you wish to lower this number just set the configuration
# to a lower number:
#
# class UserSession < Authlogic::Session::Base
# consecutive_failed_logins_limit 10
# end
#
# Callbacks
# =========
#
# Between these callbacks and the configuration, this is the contract between me and
# you to safely modify Authlogic's behavior. I will do everything I can to make sure
# these do not change.
#
# Check out the sub modules of Authlogic::Session. They are very concise, clear, and
# to the point. More importantly they use the same API that you would use to extend
# Authlogic. That being said, they are great examples of how to extend Authlogic and
# add / modify behavior to Authlogic. These modules could easily be pulled out into
# their own plugin and become an "add on" without any change.
#
# Now to the point of this module. Just like in ActiveRecord you have before_save,
# before_validation, etc. You have similar callbacks with Authlogic, see the METHODS
# constant below. The order of execution is as follows:
#
# before_persisting
# persist
# after_persisting
# [save record if record.has_changes_to_save?]
#
# before_validation
# before_validation_on_create
# before_validation_on_update
# validate
# after_validation_on_update
# after_validation_on_create
# after_validation
# [save record if record.has_changes_to_save?]
#
# before_save
# before_create
# before_update
# after_update
# after_create
# after_save
# [save record if record.has_changes_to_save?]
#
# before_destroy
# [save record if record.has_changes_to_save?]
# after_destroy
#
# Notice the "save record if has_changes_to_save" lines above. This helps with performance. If
# you need to make changes to the associated record, there is no need to save the
# record, Authlogic will do it for you. This allows multiple modules to modify the
# record and execute as few queries as possible.
#
# **WARNING**: unlike ActiveRecord, these callbacks must be set up on the class level:
#
# class UserSession < Authlogic::Session::Base
# before_validation :my_method
# validate :another_method
# # ..etc
# end
#
# You can NOT define a "before_validation" method, this is bad practice and does not
# allow Authlogic to extend properly with multiple extensions. Please ONLY use the
# method above.
#
# HTTP Basic Authentication
# =========================
#
# Handles all authentication that deals with basic HTTP auth. Which is
# authentication built into the HTTP protocol:
#
# http://username:password@whatever.com
#
# Also, if you are not comfortable letting users pass their raw username and
# password you can use a single access token, as described below.
#
# Magic Columns
# =============
#
# Just like ActiveRecord has "magic" columns, such as: created_at and updated_at.
# Authlogic has its own "magic" columns too:
#
# * login_count - Increased every time an explicit login is made. This will *NOT*
# increase if logging in by a session, cookie, or basic http auth
# * failed_login_count - This increases for each consecutive failed login. See
# the consecutive_failed_logins_limit option for details.
# * last_request_at - Updates every time the user logs in, either by explicitly
# logging in, or logging in by cookie, session, or http auth
# * current_login_at - Updates with the current time when an explicit login is made.
# * last_login_at - Updates with the value of current_login_at before it is reset.
# * current_login_ip - Updates with the request ip when an explicit login is made.
# * last_login_ip - Updates with the value of current_login_ip before it is reset.
#
# Multiple Simultaneous Sessions
# ==============================
#
# See `id`. Allows you to separate sessions with an id, ultimately letting
# you create multiple sessions for the same user.
#
# Timeout
# =======
#
# Think about financial websites, if you are inactive for a certain period
# of time you will be asked to log back in on your next request. You can do
# this with Authlogic easily, there are 2 parts to this:
#
# 1. Define the timeout threshold:
#
# acts_as_authentic do |c|
# c.logged_in_timeout = 10.minutes # default is 10.minutes
# end
#
# 2. Enable logging out on timeouts
#
# class UserSession < Authlogic::Session::Base
# logout_on_timeout true # default is false
# end
#
# This will require a user to log back in if they are inactive for more than
# 10 minutes. In order for this feature to be used you must have a
# last_request_at datetime column in your table for whatever model you are
# authenticating with.
#
# Params
# ======
#
# This module is responsible for authenticating the user via params, which ultimately
# allows the user to log in using a URL like the following:
#
# https://www.domain.com?user_credentials=4LiXF7FiGUppIPubBPey
#
# Notice the token in the URL, this is a single access token. A single access token is
# used for single access only, it is not persisted. Meaning the user provides it,
# Authlogic grants them access, and that's it. If they want access again they need to
# provide the token again. Authlogic will *NEVER* try to persist the session after
# authenticating through this method.
#
# For added security, this token is *ONLY* allowed for RSS and ATOM requests. You can
# change this with the configuration. You can also define if it is allowed dynamically
# by defining a single_access_allowed? method in your controller. For example:
#
# class UsersController < ApplicationController
# private
# def single_access_allowed?
# action_name == "index"
# end
#
# Also, by default, this token is permanent. Meaning if the user changes their
# password, this token will remain the same. It will only change when it is explicitly
# reset.
#
# You can modify all of this behavior with the Config sub module.
#
# Perishable Token
# ================
#
# Maintains the perishable token, which is helpful for confirming records or
# authorizing records to reset their password. All that this module does is
# reset it after a session have been saved, just keep it changing. The more
# it changes, the tighter the security.
#
# See Authlogic::ActsAsAuthentic::PerishableToken for more information.
#
# Scopes
# ======
#
# Authentication can be scoped, and it's easy, you just need to define how you want to
# scope everything. See `.with_scope`.
#
# Unauthorized Record
# ===================
#
# Allows you to create session with an object. Ex:
#
# UserSession.create(my_user_object)
#
# Be careful with this, because Authlogic is assuming that you have already
# confirmed that the user is who he says he is.
#
# For example, this is the method used to persist the session internally.
# Authlogic finds the user with the persistence token. At this point we know
# the user is who he says he is, so Authlogic just creates a session with
# the record. This is particularly useful for 3rd party authentication
# methods, such as OpenID. Let that method verify the identity, once it's
# verified, pass the object and create a session.
#
# Magic States
# ============
#
# Authlogic tries to check the state of the record before creating the session. If
# your record responds to the following methods and any of them return false,
# validation will fail:
#
# Method name           Description
# active?               Is the record marked as active?
# approved?             Has the record been approved?
# confirmed?            Has the record been confirmed?
#
# Authlogic does nothing to define these methods for you, its up to you to define what
# they mean. If your object responds to these methods Authlogic will use them,
# otherwise they are ignored.
#
# What's neat about this is that these are checked upon any type of login. When
# logging in explicitly, by cookie, session, or basic http auth. So if you mark a user
# inactive in the middle of their session they wont be logged back in next time they
# refresh the page. Giving you complete control.
#
# Need Authlogic to check your own "state"? No problem, check out the hooks section
# below. Add in a before_validation to do your own checking. The sky is the limit.
#
# Validation
# ==========
#
# The errors in Authlogic work just like ActiveRecord. In fact, it uses
# the `ActiveModel::Errors` class. Use it the same way:
#
# ```
# class UserSession
# validate :check_if_awesome
#
# private
#
# def check_if_awesome
# if login && !login.include?("awesome")
# errors.add(:login, "must contain awesome")
# end
# unless attempted_record.awesome?
# errors.add(:base, "You must be awesome to log in")
# end
# end
# end
# ```
class Authlogic::Session::Base
  include ::ActiveSupport::Callbacks
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Translation
  extend ::Authlogic::Config
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker

  # Constructor
  # ===========
  def initialize(*args); end

  def __callbacks; end
  def __callbacks?; end
  def _after_create_callbacks; end
  def _after_destroy_callbacks; end
  def _after_persisting_callbacks; end
  def _after_save_callbacks; end
  def _after_update_callbacks; end
  def _after_validation_callbacks; end
  def _after_validation_on_create_callbacks; end
  def _after_validation_on_update_callbacks; end
  def _before_create_callbacks; end
  def _before_destroy_callbacks; end
  def _before_persisting_callbacks; end
  def _before_save_callbacks; end
  def _before_update_callbacks; end
  def _before_validation_callbacks; end
  def _before_validation_on_create_callbacks; end
  def _before_validation_on_update_callbacks; end
  def _persist_callbacks; end
  def _run_after_create_callbacks(&block); end
  def _run_after_destroy_callbacks(&block); end
  def _run_after_persisting_callbacks(&block); end
  def _run_after_save_callbacks(&block); end
  def _run_after_update_callbacks(&block); end
  def _run_after_validation_callbacks(&block); end
  def _run_after_validation_on_create_callbacks(&block); end
  def _run_after_validation_on_update_callbacks(&block); end
  def _run_before_create_callbacks(&block); end
  def _run_before_destroy_callbacks(&block); end
  def _run_before_persisting_callbacks(&block); end
  def _run_before_save_callbacks(&block); end
  def _run_before_update_callbacks(&block); end
  def _run_before_validation_callbacks(&block); end
  def _run_before_validation_on_create_callbacks(&block); end
  def _run_before_validation_on_update_callbacks(&block); end
  def _run_persist_callbacks(&block); end
  def _run_validate_callbacks(&block); end
  def _validate_callbacks; end
  def acts_as_authentic_config; end
  def acts_as_authentic_config=(_arg0); end
  def acts_as_authentic_config?; end

  # You should use this as a place holder for any records that you find
  # during validation. The main reason for this is to allow other modules to
  # use it if needed. Take the failed_login_count feature, it needs this in
  # order to increase the failed login count.
  def attempted_record; end

  # See attempted_record
  def attempted_record=(value); end

  # Returns true when the consecutive_failed_logins_limit has been
  # exceeded and is being temporarily banned. Notice the word temporary,
  # the user will not be permanently banned unless you choose to do so
  # with configuration. By default they will be banned for 2 hours. During
  # that 2 hour period this method will return true.
  def being_brute_force_protected?; end

  # The credentials you passed to create your session, in a redacted format
  # intended for output (debugging, logging). See credentials= for more
  # info.
  def credentials; end

  # Set your credentials before you save your session. There are many
  # method signatures.
  #
  # ```
  # # A hash of credentials is most common
  # session.credentials = { login: "foo", password: "bar", remember_me: true }
  #
  # # You must pass an actual Hash, `ActionController::Parameters` is
  # # specifically not allowed.
  #
  # # You can pass an array of objects:
  # session.credentials = [my_user_object, true]
  #
  # # If you need to set an id (see `#id`) pass it last.
  # session.credentials = [
  # {:login => "foo", :password => "bar", :remember_me => true},
  # :my_id
  # ]
  # session.credentials = [my_user_object, true, :my_id]
  #
  # The `id` is something that you control yourself, it should never be
  # set from a hash or a form.
  #
  # # Finally, there's priority_record
  # [{ priority_record: my_object }, :my_id]
  # ```
  #
  def credentials=(value); end

  # Clears all errors and the associated record, you should call this
  # terminate a session, thus requiring the user to authenticate again if
  # it is needed.
  def destroy; end

  def destroyed?; end

  # If the cookie should be encrypted
  def encrypt_cookie; end

  # Accepts a boolean as to whether the cookie should be encrypted.  If true
  # the cookie will be saved in an encrypted state.
  def encrypt_cookie=(value); end

  # See encrypt_cookie
  def encrypt_cookie?; end

  def errors; end

  # If the cookie should be marked as httponly (not accessible via javascript)
  def httponly; end

  # Accepts a boolean as to whether the cookie should be marked as
  # httponly.  If true, the cookie will not be accessible from javascript
  def httponly=(value); end

  # See httponly
  def httponly?; end

  # Allows you to set a unique identifier for your session, so that you can
  # have more than 1 session at a time.
  #
  # For example, you may want to have simultaneous private and public
  # sessions. Or, a normal user session and a "secure" user session. The
  # secure user session would be created only when they want to modify their
  # billing information, or other sensitive information.
  #
  # You can set the id during initialization (see initialize for more
  # information), or as an attribute:
  #
  # session.id = :my_id
  #
  # Set your id before you save your session.
  #
  # Lastly, to retrieve your session with the id, use the `.find` method.
  def id; end

  # Sets the attribute id
  def id=(_arg0); end

  def inspect; end

  # Returns the value of attribute invalid_password.
  def invalid_password; end

  # Sets the attribute invalid_password
  def invalid_password=(_arg0); end

  def invalid_password?; end
  def model_name(*_arg0, &_arg1); end

  # Don't use this yourself, this is to just trick some of the helpers
  # since this is the method it calls.
  def new_record?; end

  # Returns the value of attribute new_session.
  def new_session; end

  # Sets the attribute new_session
  def new_session=(_arg0); end

  # Returns true if the session is new, meaning no action has been taken
  # on it and a successful save has not taken place.
  def new_session?; end

  def persisted?; end

  # Returns boolean indicating if the session is being persisted or not,
  # meaning the user does not have to explicitly log in in order to be
  # logged in.
  #
  # If the session has no associated record, it will try to find a record
  # and persist the session.
  #
  # This is the method that the class level method find uses to ultimately
  # persist the session.
  def persisting?; end

  # Returns the value of attribute priority_record.
  def priority_record; end

  # Sets the attribute priority_record
  def priority_record=(_arg0); end

  # Returns the value of attribute record.
  def record; end

  # Sets the attribute record
  def record=(_arg0); end

  # Is the cookie going to expire after the session is over, or will it stick around?
  def remember_me; end

  # Accepts a boolean as a flag to remember the session or not. Basically
  # to expire the cookie at the end of the session or keep it for
  # "remember_me_until".
  def remember_me=(value); end

  # See remember_me
  def remember_me?; end

  # Has the cookie expired due to current time being greater than remember_me_until.
  def remember_me_expired?; end

  # How long to remember the user if remember_me is true. This is based on the class
  # level configuration: remember_me_for
  def remember_me_for; end

  # When to expire the cookie. See remember_me_for configuration option to change
  # this.
  def remember_me_until; end

  # If the cookie should be marked as SameSite with 'Lax' or 'Strict' flag.
  def same_site; end

  # Accepts nil, 'Lax' or 'Strict' as possible flags.
  def same_site=(value); end

  # After you have specified all of the details for your session you can
  # try to save it. This will run validation checks and find the
  # associated record, if all validation passes. If validation does not
  # pass, the save will fail and the errors will be stored in the errors
  # object.
  def save; end

  # Same as save but raises an exception of validation errors when
  # validation fails
  def save!; end

  def save_record(alternate_record = T.unsafe(nil)); end

  # The scope of the current object
  def scope; end

  # Sets the attribute scope
  def scope=(_arg0); end

  # If the cookie should be marked as secure (SSL only)
  def secure; end

  # Accepts a boolean as to whether the cookie should be marked as secure.  If true
  # the cookie will only ever be sent over an SSL connection.
  def secure=(value); end

  # See secure
  def secure?; end

  # If the cookie should be signed
  def sign_cookie; end

  # Accepts a boolean as to whether the cookie should be signed.  If true
  # the cookie will be saved and verified using a signature.
  def sign_cookie=(value); end

  # See sign_cookie
  def sign_cookie?; end

  # Returns the value of attribute single_access.
  def single_access; end

  # Sets the attribute single_access
  def single_access=(_arg0); end

  # Tells you if the record is stale or not. Meaning the record has timed
  # out. This will only return true if you set logout_on_timeout to true
  # in your configuration. Basically how a bank website works. If you
  # aren't active over a certain period of time your session becomes stale
  # and requires you to log back in.
  def stale?; end

  # Returns the value of attribute stale_record.
  def stale_record; end

  # Sets the attribute stale_record
  def stale_record=(_arg0); end

  def to_key; end

  # For rails >= 3.0
  def to_model; end

  # Returns the value of attribute unauthorized_record.
  def unauthorized_record; end

  # Sets the attribute unauthorized_record
  def unauthorized_record=(_arg0); end

  # Determines if the information you provided for authentication is valid
  # or not. If there is a problem with the information provided errors will
  # be added to the errors object and this method will return false.
  def valid?; end

  private

  def add_general_credentials_error; end
  def add_invalid_password_error; end
  def add_login_not_found_error; end
  def allow_http_basic_auth?; end
  def authenticating_with_password?; end
  def authenticating_with_unauthorized_record?; end

  # Used for things like cookie_key, session_key, etc.
  # Examples:
  # - user_credentials
  # - ziggity_zack_user_credentials
  # - ziggity_zack is an "id"
  # - see persistence_token_test.rb
  def build_key(last_part); end

  def clear_failed_login_count; end
  def configure_password_methods; end
  def consecutive_failed_logins_limit; end
  def controller; end

  # Look in the `cookie_jar`, find the cookie that contains authlogic
  # credentials (`cookie_key`).
  def cookie_credentials; end

  def cookie_enabled?; end
  def cookie_jar; end
  def cookie_key; end
  def define_login_field_methods; end
  def define_password_field_methods; end

  # The password should not be accessible publicly. This way forms using
  # form_for don't fill the password with the attempted password. To prevent
  # this we just create this method that is private.
  def define_password_field_reader_methods; end

  def define_password_field_writer_method; end

  # Creating an alias method for the "record" method based on the klass
  # name, so that we can do:
  #
  # session.user
  #
  # instead of:
  #
  # session.record
  def define_record_alias_method; end

  def destroy_cookie; end
  def disable_magic_states?; end
  def enforce_timeout; end
  def ensure_authentication_attempted; end
  def exceeded_failed_logins_limit?; end
  def failed_login_ban_for; end
  def find_by_login_method; end
  def generalize_credentials_error_messages?; end
  def generate_cookie_for_saving; end
  def generate_cookie_value; end

  # Returns a Proc to be executed by
  # `ActionController::HttpAuthentication::Basic` when credentials are
  # present in the HTTP request.
  def http_auth_login_proc; end

  def increase_failed_login_count; end
  def increment_login_count; end
  def klass; end
  def klass_name; end
  def last_request_at_threshold; end
  def login_field; end
  def logout_on_timeout?; end
  def params_credentials; end
  def params_enabled?; end
  def params_enabled_by_allowed_request_types?; end
  def params_key; end
  def password_field; end

  # Tries to validate the session from information in the cookie
  def persist_by_cookie; end

  def persist_by_http_auth; end
  def persist_by_http_auth?; end
  def persist_by_params; end

  # Tries to validate the session from information in the session
  def persist_by_session; end

  # Allow finding by persistence token, because when records are created
  # the session is maintained in a before_save, when there is no id.
  # This is done for performance reasons and to save on queries.
  def persist_by_session_search(persistence_token, record_id); end

  # Assign a new controller-session ID, to defend against Session Fixation.
  # https://guides.rubyonrails.org/v6.0/security.html#session-fixation
  def renew_session_id; end

  def required_magic_states_for(record); end
  def reset_failed_login_count; end
  def reset_failed_login_count?; end
  def reset_perishable_token!; end
  def reset_stale_state; end
  def run_the_after_validation_callbacks; end
  def run_the_before_validation_callbacks; end
  def save_cookie; end

  # `args[0]` is the name of a model method, like
  # `find_by_single_access_token` or `find_by_smart_case_login_field`.
  def search_for_record(*args); end

  # Returns an AR relation representing the scope of the search. The
  # relation is either provided directly by, or defined by
  # `find_options`.
  def search_scope; end

  # - user_credentials_id
  # - ziggity_zack_user_credentials_id
  # - ziggity_zack is an "id", see `#id`
  # - see persistence_token_test.rb
  def session_compound_key; end

  def session_credentials; end

  # - user_credentials
  # - ziggity_zack_user_credentials
  # - ziggity_zack is an "id", see `#id`
  # - see persistence_token_test.rb
  def session_key; end

  def set_last_request_at; end
  def single_access?; end
  def single_access_allowed_request_types; end
  def update_info; end
  def update_login_ip_addresses; end
  def update_login_timestamps; end
  def update_session; end

  # Updates the session, setting the `persistence_token` of the record.
  def update_session_set_persistence_token; end

  # Updates the session, setting the primary key (usually `id`) of the
  # record.
  def update_session_set_primary_key; end

  # In keeping with the metaphor of ActiveRecord, verification of the
  # password is referred to as a "validation".
  def validate_by_password; end

  def validate_by_password__blank_fields; end

  # Verify the password, usually using `valid_password?` in
  # `acts_as_authentic/password.rb`. If it cannot be verified, we
  # refer to it as "invalid".
  def validate_by_password__invalid_password; end

  def validate_by_unauthorized_record; end
  def validate_failed_logins; end
  def validate_magic_states; end
  def verify_password_method; end

  class << self
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _after_create_callbacks; end
    def _after_create_callbacks=(value); end
    def _after_destroy_callbacks; end
    def _after_destroy_callbacks=(value); end
    def _after_persisting_callbacks; end
    def _after_persisting_callbacks=(value); end
    def _after_save_callbacks; end
    def _after_save_callbacks=(value); end
    def _after_update_callbacks; end
    def _after_update_callbacks=(value); end
    def _after_validation_callbacks; end
    def _after_validation_callbacks=(value); end
    def _after_validation_on_create_callbacks; end
    def _after_validation_on_create_callbacks=(value); end
    def _after_validation_on_update_callbacks; end
    def _after_validation_on_update_callbacks=(value); end
    def _before_create_callbacks; end
    def _before_create_callbacks=(value); end
    def _before_destroy_callbacks; end
    def _before_destroy_callbacks=(value); end
    def _before_persisting_callbacks; end
    def _before_persisting_callbacks=(value); end
    def _before_save_callbacks; end
    def _before_save_callbacks=(value); end
    def _before_update_callbacks; end
    def _before_update_callbacks=(value); end
    def _before_validation_callbacks; end
    def _before_validation_callbacks=(value); end
    def _before_validation_on_create_callbacks; end
    def _before_validation_on_create_callbacks=(value); end
    def _before_validation_on_update_callbacks; end
    def _before_validation_on_update_callbacks=(value); end
    def _persist_callbacks; end
    def _persist_callbacks=(value); end
    def _validate_callbacks; end
    def _validate_callbacks=(value); end

    # Returns true if a controller has been set and can be used properly.
    # This MUST be set before anything can be done. Similar to how
    # ActiveRecord won't allow you to do anything without establishing a DB
    # connection. In your framework environment this is done for you, but if
    # you are using Authlogic outside of your framework, you need to assign
    # a controller object to Authlogic via
    # Authlogic::Session::Base.controller = obj. See the controller= method
    # for more information.
    def activated?; end

    def acts_as_authentic_config; end
    def acts_as_authentic_config=(value); end
    def acts_as_authentic_config?; end
    def after_create(*filter_list, &block); end
    def after_destroy(*filter_list, &block); end
    def after_persisting(*filter_list, &block); end
    def after_save(*filter_list, &block); end
    def after_update(*filter_list, &block); end
    def after_validation(*filter_list, &block); end
    def after_validation_on_create(*filter_list, &block); end
    def after_validation_on_update(*filter_list, &block); end

    # Allow users to log in via HTTP basic authentication.
    #
    # * <tt>Default:</tt> false
    # * <tt>Accepts:</tt> Boolean
    def allow_http_basic_auth(value = T.unsafe(nil)); end

    # Allow users to log in via HTTP basic authentication.
    #
    # * <tt>Default:</tt> false
    # * <tt>Accepts:</tt> Boolean
    def allow_http_basic_auth=(value = T.unsafe(nil)); end

    # Lets you change which model to use for authentication.
    #
    # * <tt>Default:</tt> inferred from the class name. UserSession would
    # automatically try User
    # * <tt>Accepts:</tt> an ActiveRecord class
    def authenticate_with(klass); end

    # Lets you change which model to use for authentication.
    #
    # * <tt>Default:</tt> inferred from the class name. UserSession would
    # automatically try User
    # * <tt>Accepts:</tt> an ActiveRecord class
    def authenticate_with=(klass); end

    def before_create(*filter_list, &block); end
    def before_destroy(*filter_list, &block); end
    def before_persisting(*filter_list, &block); end
    def before_save(*filter_list, &block); end
    def before_update(*filter_list, &block); end
    def before_validation(*filter_list, &block); end
    def before_validation_on_create(*filter_list, &block); end
    def before_validation_on_update(*filter_list, &block); end

    # Returns the value of attribute configured_password_methods.
    def configured_password_methods; end

    # Sets the attribute configured_password_methods
    def configured_password_methods=(_arg0); end

    # To help protect from brute force attacks you can set a limit on the
    # allowed number of consecutive failed logins. By default this is 50,
    # this is a very liberal number, and if someone fails to login after 50
    # tries it should be pretty obvious that it's a machine trying to login
    # in and very likely a brute force attack.
    #
    # In order to enable this field your model MUST have a
    # failed_login_count (integer) field.
    #
    # If you don't know what a brute force attack is, it's when a machine
    # tries to login into a system using every combination of character
    # possible. Thus resulting in possibly millions of attempts to log into
    # an account.
    #
    # * <tt>Default:</tt> 50
    # * <tt>Accepts:</tt> Integer, set to 0 to disable
    def consecutive_failed_logins_limit(value = T.unsafe(nil)); end

    # To help protect from brute force attacks you can set a limit on the
    # allowed number of consecutive failed logins. By default this is 50,
    # this is a very liberal number, and if someone fails to login after 50
    # tries it should be pretty obvious that it's a machine trying to login
    # in and very likely a brute force attack.
    #
    # In order to enable this field your model MUST have a
    # failed_login_count (integer) field.
    #
    # If you don't know what a brute force attack is, it's when a machine
    # tries to login into a system using every combination of character
    # possible. Thus resulting in possibly millions of attempts to log into
    # an account.
    #
    # * <tt>Default:</tt> 50
    # * <tt>Accepts:</tt> Integer, set to 0 to disable
    def consecutive_failed_logins_limit=(value = T.unsafe(nil)); end

    # The current controller object
    def controller; end

    # This accepts a controller object wrapped with the Authlogic controller
    # adapter. The controller adapters close the gap between the different
    # controllers in each framework. That being said, Authlogic is expecting
    # your object's class to extend
    # Authlogic::ControllerAdapters::AbstractAdapter. See
    # Authlogic::ControllerAdapters for more info.
    #
    # Lastly, this is thread safe.
    def controller=(value); end

    # The name of the cookie or the key in the cookies hash. Be sure and use
    # a unique name. If you have multiple sessions and they use the same
    # cookie it will cause problems. Also, if a id is set it will be
    # inserted into the beginning of the string. Example:
    #
    # session = UserSession.new
    # session.cookie_key => "user_credentials"
    #
    # session = UserSession.new(:super_high_secret)
    # session.cookie_key => "super_high_secret_user_credentials"
    #
    # * <tt>Default:</tt> "#{klass_name.underscore}_credentials"
    # * <tt>Accepts:</tt> String
    def cookie_key(value = T.unsafe(nil)); end

    # The name of the cookie or the key in the cookies hash. Be sure and use
    # a unique name. If you have multiple sessions and they use the same
    # cookie it will cause problems. Also, if a id is set it will be
    # inserted into the beginning of the string. Example:
    #
    # session = UserSession.new
    # session.cookie_key => "user_credentials"
    #
    # session = UserSession.new(:super_high_secret)
    # session.cookie_key => "super_high_secret_user_credentials"
    #
    # * <tt>Default:</tt> "#{klass_name.underscore}_credentials"
    # * <tt>Accepts:</tt> String
    def cookie_key=(value = T.unsafe(nil)); end

    # A convenience method. The same as:
    #
    # session = UserSession.new(*args)
    # session.save
    #
    # Instead you can do:
    #
    # UserSession.create(*args)
    def create(*args, &block); end

    # Same as create but calls create!, which raises an exception when
    # validation fails.
    def create!(*args); end

    # Set this to true if you want to disable the checking of active?, approved?, and
    # confirmed? on your record. This is more or less of a convenience feature, since
    # 99% of the time if those methods exist and return false you will not want the
    # user logging in. You could easily accomplish this same thing with a
    # before_validation method or other callbacks.
    #
    # * <tt>Default:</tt> false
    # * <tt>Accepts:</tt> Boolean
    def disable_magic_states(value = T.unsafe(nil)); end

    # Set this to true if you want to disable the checking of active?, approved?, and
    # confirmed? on your record. This is more or less of a convenience feature, since
    # 99% of the time if those methods exist and return false you will not want the
    # user logging in. You could easily accomplish this same thing with a
    # before_validation method or other callbacks.
    #
    # * <tt>Default:</tt> false
    # * <tt>Accepts:</tt> Boolean
    def disable_magic_states=(value = T.unsafe(nil)); end

    # Should the cookie be encrypted? If the controller adapter supports it, this is a
    # measure to hide the contents of the cookie (e.g. persistence_token)
    def encrypt_cookie(value = T.unsafe(nil)); end

    # Should the cookie be encrypted? If the controller adapter supports it, this is a
    # measure to hide the contents of the cookie (e.g. persistence_token)
    def encrypt_cookie=(value = T.unsafe(nil)); end

    # Once the failed logins limit has been exceed, how long do you want to
    # ban the user? This can be a temporary or permanent ban.
    #
    # * <tt>Default:</tt> 2.hours
    # * <tt>Accepts:</tt> Fixnum, set to 0 for permanent ban
    def failed_login_ban_for(value = T.unsafe(nil)); end

    # Once the failed logins limit has been exceed, how long do you want to
    # ban the user? This can be a temporary or permanent ban.
    #
    # * <tt>Default:</tt> 2.hours
    # * <tt>Accepts:</tt> Fixnum, set to 0 for permanent ban
    def failed_login_ban_for=(value = T.unsafe(nil)); end

    # This is how you persist a session. This finds the record for the
    # current session using a variety of methods. It basically tries to "log
    # in" the user without the user having to explicitly log in. Check out
    # the other Authlogic::Session modules for more information.
    #
    # The best way to use this method is something like:
    #
    # helper_method :current_user_session, :current_user
    #
    # def current_user_session
    # return @current_user_session if defined?(@current_user_session)
    # @current_user_session = UserSession.find
    # end
    #
    # def current_user
    # return @current_user if defined?(@current_user)
    # @current_user = current_user_session && current_user_session.user
    # end
    #
    # Also, this method accepts a single parameter as the id, to find
    # session that you marked with an id:
    #
    # UserSession.find(:secure)
    #
    # See the id method for more information on ids.
    #
    # Priority Record
    # ===============
    #
    # This internal feature supports ActiveRecord's optimistic locking feature,
    # which is automatically enabled when a table has a `lock_version` column.
    #
    # ```
    # # https://api.rubyonrails.org/classes/ActiveRecord/Locking/Optimistic.html
    # p1 = Person.find(1)
    # p2 = Person.find(1)
    # p1.first_name = "Michael"
    # p1.save
    # p2.first_name = "should fail"
    # p2.save # Raises an ActiveRecord::StaleObjectError
    # ```
    #
    # Now, consider the following Authlogic scenario:
    #
    # ```
    # User.log_in_after_password_change = true
    # ben = User.find(1)
    # UserSession.create(ben)
    # ben.password = "newpasswd"
    # ben.password_confirmation = "newpasswd"
    # ben.save
    # ```
    #
    # We've used one of Authlogic's session maintenance features,
    # `log_in_after_password_change`. So, when we call `ben.save`, there is a
    # `before_save` callback that logs Ben in (`UserSession.find`). Well, when
    # we log Ben in, we update his user record, eg. `login_count`. When we're
    # done logging Ben in, then the normal `ben.save` happens. So, there were
    # two `update` queries. If those two updates came from different User
    # instances, we would get a `StaleObjectError`.
    #
    # Our solution is to carefully pass around a single `User` instance, using
    # it for all `update` queries, thus avoiding the `StaleObjectError`.
    def find(id = T.unsafe(nil), priority_record = T.unsafe(nil)); end

    def find_by_login_method(value = T.unsafe(nil)); end
    def find_by_login_method=(value = T.unsafe(nil)); end

    # The text used to identify credentials (username/password) combination
    # when a bad login attempt occurs. When you show error messages for a
    # bad login, it's considered good security practice to hide which field
    # the user has entered incorrectly (the login field or the password
    # field). For a full explanation, see
    # http://www.gnucitizen.org/blog/username-enumeration-vulnerabilities/
    #
    # Example of use:
    #
    # class UserSession < Authlogic::Session::Base
    # generalize_credentials_error_messages true
    # end
    #
    # This would make the error message for bad logins and bad passwords
    # look identical:
    #
    # Login/Password combination is not valid
    #
    # Alternatively you may use a custom message:
    #
    # class UserSession < AuthLogic::Session::Base
    # generalize_credentials_error_messages "Your login information is invalid"
    # end
    #
    # This will instead show your custom error message when the UserSession is invalid.
    #
    # The downside to enabling this is that is can be too vague for a user
    # that has a hard time remembering their username and password
    # combinations. It also disables the ability to to highlight the field
    # with the error when you use form_for.
    #
    # If you are developing an app where security is an extreme priority
    # (such as a financial application), then you should enable this.
    # Otherwise, leaving this off is fine.
    #
    # * <tt>Default</tt> false
    # * <tt>Accepts:</tt> Boolean
    def generalize_credentials_error_messages(value = T.unsafe(nil)); end

    # The text used to identify credentials (username/password) combination
    # when a bad login attempt occurs. When you show error messages for a
    # bad login, it's considered good security practice to hide which field
    # the user has entered incorrectly (the login field or the password
    # field). For a full explanation, see
    # http://www.gnucitizen.org/blog/username-enumeration-vulnerabilities/
    #
    # Example of use:
    #
    # class UserSession < Authlogic::Session::Base
    # generalize_credentials_error_messages true
    # end
    #
    # This would make the error message for bad logins and bad passwords
    # look identical:
    #
    # Login/Password combination is not valid
    #
    # Alternatively you may use a custom message:
    #
    # class UserSession < AuthLogic::Session::Base
    # generalize_credentials_error_messages "Your login information is invalid"
    # end
    #
    # This will instead show your custom error message when the UserSession is invalid.
    #
    # The downside to enabling this is that is can be too vague for a user
    # that has a hard time remembering their username and password
    # combinations. It also disables the ability to to highlight the field
    # with the error when you use form_for.
    #
    # If you are developing an app where security is an extreme priority
    # (such as a financial application), then you should enable this.
    # Otherwise, leaving this off is fine.
    #
    # * <tt>Default</tt> false
    # * <tt>Accepts:</tt> Boolean
    def generalize_credentials_error_messages=(value = T.unsafe(nil)); end

    # HTTP authentication realm
    #
    # Sets the HTTP authentication realm.
    #
    # Note: This option has no effect unless request_http_basic_auth is true
    #
    # * <tt>Default:</tt> 'Application'
    # * <tt>Accepts:</tt> String
    def http_basic_auth_realm(value = T.unsafe(nil)); end

    # HTTP authentication realm
    #
    # Sets the HTTP authentication realm.
    #
    # Note: This option has no effect unless request_http_basic_auth is true
    #
    # * <tt>Default:</tt> 'Application'
    # * <tt>Accepts:</tt> String
    def http_basic_auth_realm=(value = T.unsafe(nil)); end

    # Should the cookie be set as httponly?  If true, the cookie will not be
    # accessible from javascript
    #
    # * <tt>Default:</tt> true
    # * <tt>Accepts:</tt> Boolean
    def httponly(value = T.unsafe(nil)); end

    # Should the cookie be set as httponly?  If true, the cookie will not be
    # accessible from javascript
    #
    # * <tt>Default:</tt> true
    # * <tt>Accepts:</tt> Boolean
    def httponly=(value = T.unsafe(nil)); end

    # How to name the class, works JUST LIKE ActiveRecord, except it uses
    # the following namespace:
    #
    # authlogic.models.user_session
    def human_name(*_arg0); end

    def i18n_scope; end

    # The name of the class that this session is authenticating with. For
    # example, the UserSession class will authenticate with the User class
    # unless you specify otherwise in your configuration. See
    # authenticate_with for information on how to change this value.
    def klass; end

    # The model name, guessed from the session class name, e.g. "User",
    # from "UserSession".
    #
    # TODO: This method can return nil. We should explore this. It seems
    # likely to cause a NoMethodError later, so perhaps we should raise an
    # error instead.
    def klass_name; end

    # Every time a session is found the last_request_at field for that record is
    # updated with the current time, if that field exists. If you want to limit how
    # frequent that field is updated specify the threshold here. For example, if your
    # user is making a request every 5 seconds, and you feel this is too frequent, and
    # feel a minute is a good threshold. Set this to 1.minute. Once a minute has
    # passed in between requests the field will be updated.
    #
    # * <tt>Default:</tt> 0
    # * <tt>Accepts:</tt> integer representing time in seconds
    def last_request_at_threshold(value = T.unsafe(nil)); end

    # Every time a session is found the last_request_at field for that record is
    # updated with the current time, if that field exists. If you want to limit how
    # frequent that field is updated specify the threshold here. For example, if your
    # user is making a request every 5 seconds, and you feel this is too frequent, and
    # feel a minute is a good threshold. Set this to 1.minute. Once a minute has
    # passed in between requests the field will be updated.
    #
    # * <tt>Default:</tt> 0
    # * <tt>Accepts:</tt> integer representing time in seconds
    def last_request_at_threshold=(value = T.unsafe(nil)); end

    # The name of the method you want Authlogic to create for storing the
    # login / username. Keep in mind this is just for your
    # Authlogic::Session, if you want it can be something completely
    # different than the field in your model. So if you wanted people to
    # login with a field called "login" and then find users by email this is
    # completely doable. See the `record_selection_method` configuration
    # option for details.
    #
    # * <tt>Default:</tt> klass.login_field || klass.email_field
    # * <tt>Accepts:</tt> Symbol or String
    def login_field(value = T.unsafe(nil)); end

    # The name of the method you want Authlogic to create for storing the
    # login / username. Keep in mind this is just for your
    # Authlogic::Session, if you want it can be something completely
    # different than the field in your model. So if you wanted people to
    # login with a field called "login" and then find users by email this is
    # completely doable. See the `record_selection_method` configuration
    # option for details.
    #
    # * <tt>Default:</tt> klass.login_field || klass.email_field
    # * <tt>Accepts:</tt> Symbol or String
    def login_field=(value = T.unsafe(nil)); end

    # With acts_as_authentic you get a :logged_in_timeout configuration
    # option. If this is set, after this amount of time has passed the user
    # will be marked as logged out. Obviously, since web based apps are on a
    # per request basis, we have to define a time limit threshold that
    # determines when we consider a user to be "logged out". Meaning, if
    # they login and then leave the website, when do mark them as logged
    # out? I recommend just using this as a fun feature on your website or
    # reports, giving you a ballpark number of users logged in and active.
    # This is not meant to be a dead accurate representation of a user's
    # logged in state, since there is really no real way to do this with web
    # based apps. Think about a user that logs in and doesn't log out. There
    # is no action that tells you that the user isn't technically still
    # logged in and active.
    #
    # That being said, you can use that feature to require a new login if
    # their session times out. Similar to how financial sites work. Just set
    # this option to true and if your record returns true for stale? then
    # they will be required to log back in.
    #
    # Lastly, UserSession.find will still return an object if the session is
    # stale, but you will not get a record. This allows you to determine if
    # the user needs to log back in because their session went stale, or
    # because they just aren't logged in. Just call
    # current_user_session.stale? as your flag.
    #
    # * <tt>Default:</tt> false
    # * <tt>Accepts:</tt> Boolean
    def logout_on_timeout(value = T.unsafe(nil)); end

    # With acts_as_authentic you get a :logged_in_timeout configuration
    # option. If this is set, after this amount of time has passed the user
    # will be marked as logged out. Obviously, since web based apps are on a
    # per request basis, we have to define a time limit threshold that
    # determines when we consider a user to be "logged out". Meaning, if
    # they login and then leave the website, when do mark them as logged
    # out? I recommend just using this as a fun feature on your website or
    # reports, giving you a ballpark number of users logged in and active.
    # This is not meant to be a dead accurate representation of a user's
    # logged in state, since there is really no real way to do this with web
    # based apps. Think about a user that logs in and doesn't log out. There
    # is no action that tells you that the user isn't technically still
    # logged in and active.
    #
    # That being said, you can use that feature to require a new login if
    # their session times out. Similar to how financial sites work. Just set
    # this option to true and if your record returns true for stale? then
    # they will be required to log back in.
    #
    # Lastly, UserSession.find will still return an object if the session is
    # stale, but you will not get a record. This allows you to determine if
    # the user needs to log back in because their session went stale, or
    # because they just aren't logged in. Just call
    # current_user_session.stale? as your flag.
    #
    # * <tt>Default:</tt> false
    # * <tt>Accepts:</tt> Boolean
    def logout_on_timeout=(value = T.unsafe(nil)); end

    # Works exactly like cookie_key, but for params. So a user can login via
    # params just like a cookie or a session. Your URL would look like:
    #
    # http://www.domain.com?user_credentials=my_single_access_key
    #
    # You can change the "user_credentials" key above with this
    # configuration option. Keep in mind, just like cookie_key, if you
    # supply an id the id will be appended to the front. Check out
    # cookie_key for more details. Also checkout the "Single Access /
    # Private Feeds Access" section in the README.
    #
    # * <tt>Default:</tt> cookie_key
    # * <tt>Accepts:</tt> String
    def params_key(value = T.unsafe(nil)); end

    # Works exactly like cookie_key, but for params. So a user can login via
    # params just like a cookie or a session. Your URL would look like:
    #
    # http://www.domain.com?user_credentials=my_single_access_key
    #
    # You can change the "user_credentials" key above with this
    # configuration option. Keep in mind, just like cookie_key, if you
    # supply an id the id will be appended to the front. Check out
    # cookie_key for more details. Also checkout the "Single Access /
    # Private Feeds Access" section in the README.
    #
    # * <tt>Default:</tt> cookie_key
    # * <tt>Accepts:</tt> String
    def params_key=(value = T.unsafe(nil)); end

    # Works exactly like login_field, but for the password instead. Returns
    # :password if a login_field exists.
    #
    # * <tt>Default:</tt> :password
    # * <tt>Accepts:</tt> Symbol or String
    def password_field(value = T.unsafe(nil)); end

    # Works exactly like login_field, but for the password instead. Returns
    # :password if a login_field exists.
    #
    # * <tt>Default:</tt> :password
    # * <tt>Accepts:</tt> Symbol or String
    def password_field=(value = T.unsafe(nil)); end

    def persist(*filter_list, &block); end

    # Authlogic tries to validate the credentials passed to it. One part of
    # validation is actually finding the user and making sure it exists.
    # What method it uses the do this is up to you.
    #
    # ```
    # # user_session.rb
    # record_selection_method :find_by_email
    # ```
    #
    # This is the recommended way to find the user by email address.
    # The resulting query will be `User.find_by_email(send(login_field))`.
    # (`login_field` will fall back to `email_field` if there's no `login`
    # or `username` column).
    #
    # In your User model you can make that method do anything you want,
    # giving you complete control of how users are found by the UserSession.
    #
    # Let's take an example: You want to allow users to login by username or
    # email. Set this to the name of the class method that does this in the
    # User model. Let's call it "find_by_username_or_email"
    #
    # ```
    # class User < ActiveRecord::Base
    # def self.find_by_username_or_email(login)
    # find_by_username(login) || find_by_email(login)
    # end
    # end
    # ```
    #
    # Now just specify the name of this method for this configuration option
    # and you are all set. You can do anything you want here. Maybe you
    # allow users to have multiple logins and you want to search a has_many
    # relationship, etc. The sky is the limit.
    #
    # * <tt>Default:</tt> "find_by_smart_case_login_field"
    # * <tt>Accepts:</tt> Symbol or String
    def record_selection_method(value = T.unsafe(nil)); end

    # Authlogic tries to validate the credentials passed to it. One part of
    # validation is actually finding the user and making sure it exists.
    # What method it uses the do this is up to you.
    #
    # ```
    # # user_session.rb
    # record_selection_method :find_by_email
    # ```
    #
    # This is the recommended way to find the user by email address.
    # The resulting query will be `User.find_by_email(send(login_field))`.
    # (`login_field` will fall back to `email_field` if there's no `login`
    # or `username` column).
    #
    # In your User model you can make that method do anything you want,
    # giving you complete control of how users are found by the UserSession.
    #
    # Let's take an example: You want to allow users to login by username or
    # email. Set this to the name of the class method that does this in the
    # User model. Let's call it "find_by_username_or_email"
    #
    # ```
    # class User < ActiveRecord::Base
    # def self.find_by_username_or_email(login)
    # find_by_username(login) || find_by_email(login)
    # end
    # end
    # ```
    #
    # Now just specify the name of this method for this configuration option
    # and you are all set. You can do anything you want here. Maybe you
    # allow users to have multiple logins and you want to search a has_many
    # relationship, etc. The sky is the limit.
    #
    # * <tt>Default:</tt> "find_by_smart_case_login_field"
    # * <tt>Accepts:</tt> Symbol or String
    def record_selection_method=(value = T.unsafe(nil)); end

    # If sessions should be remembered by default or not.
    #
    # * <tt>Default:</tt> false
    # * <tt>Accepts:</tt> Boolean
    def remember_me(value = T.unsafe(nil)); end

    # If sessions should be remembered by default or not.
    #
    # * <tt>Default:</tt> false
    # * <tt>Accepts:</tt> Boolean
    def remember_me=(value = T.unsafe(nil)); end

    # The length of time until the cookie expires.
    #
    # * <tt>Default:</tt> 3.months
    # * <tt>Accepts:</tt> Integer, length of time in seconds, such as 60 or 3.months
    def remember_me_for(value = T.unsafe(nil)); end

    # The length of time until the cookie expires.
    #
    # * <tt>Default:</tt> 3.months
    # * <tt>Accepts:</tt> Integer, length of time in seconds, such as 60 or 3.months
    def remember_me_for=(value = T.unsafe(nil)); end

    # Whether or not to request HTTP authentication
    #
    # If set to true and no HTTP authentication credentials are sent with
    # the request, the Rails controller method
    # authenticate_or_request_with_http_basic will be used and a '401
    # Authorization Required' header will be sent with the response.  In
    # most cases, this will cause the classic HTTP authentication popup to
    # appear in the users browser.
    #
    # If set to false, the Rails controller method
    # authenticate_with_http_basic is used and no 401 header is sent.
    #
    # Note: This parameter has no effect unless allow_http_basic_auth is
    # true
    #
    # * <tt>Default:</tt> false
    # * <tt>Accepts:</tt> Boolean
    def request_http_basic_auth(value = T.unsafe(nil)); end

    # Whether or not to request HTTP authentication
    #
    # If set to true and no HTTP authentication credentials are sent with
    # the request, the Rails controller method
    # authenticate_or_request_with_http_basic will be used and a '401
    # Authorization Required' header will be sent with the response.  In
    # most cases, this will cause the classic HTTP authentication popup to
    # appear in the users browser.
    #
    # If set to false, the Rails controller method
    # authenticate_with_http_basic is used and no 401 header is sent.
    #
    # Note: This parameter has no effect unless allow_http_basic_auth is
    # true
    #
    # * <tt>Default:</tt> false
    # * <tt>Accepts:</tt> Boolean
    def request_http_basic_auth=(value = T.unsafe(nil)); end

    # Should the cookie be prevented from being send along with cross-site
    # requests?
    #
    # * <tt>Default:</tt> nil
    # * <tt>Accepts:</tt> String, one of nil, 'Lax' or 'Strict'
    def same_site(value = T.unsafe(nil)); end

    # Should the cookie be prevented from being send along with cross-site
    # requests?
    #
    # * <tt>Default:</tt> nil
    # * <tt>Accepts:</tt> String, one of nil, 'Lax' or 'Strict'
    def same_site=(value = T.unsafe(nil)); end

    # The current scope set, should be used in the block passed to with_scope.
    def scope; end

    # Should the cookie be set as secure?  If true, the cookie will only be sent over
    # SSL connections
    #
    # * <tt>Default:</tt> true
    # * <tt>Accepts:</tt> Boolean
    def secure(value = T.unsafe(nil)); end

    # Should the cookie be set as secure?  If true, the cookie will only be sent over
    # SSL connections
    #
    # * <tt>Default:</tt> true
    # * <tt>Accepts:</tt> Boolean
    def secure=(value = T.unsafe(nil)); end

    # Should the Rack session ID be reset after authentication, to protect
    # against Session Fixation attacks?
    #
    # * <tt>Default:</tt> true
    # * <tt>Accepts:</tt> Boolean
    def session_fixation_defense(value = T.unsafe(nil)); end

    # Should the Rack session ID be reset after authentication, to protect
    # against Session Fixation attacks?
    #
    # * <tt>Default:</tt> true
    # * <tt>Accepts:</tt> Boolean
    def session_fixation_defense=(value = T.unsafe(nil)); end

    # Works exactly like cookie_key, but for sessions. See cookie_key for more info.
    #
    # * <tt>Default:</tt> cookie_key
    # * <tt>Accepts:</tt> Symbol or String
    def session_key(value = T.unsafe(nil)); end

    # Works exactly like cookie_key, but for sessions. See cookie_key for more info.
    #
    # * <tt>Default:</tt> cookie_key
    # * <tt>Accepts:</tt> Symbol or String
    def session_key=(value = T.unsafe(nil)); end

    # Should the cookie be signed? If the controller adapter supports it, this is a
    # measure against cookie tampering.
    def sign_cookie(value = T.unsafe(nil)); end

    # Should the cookie be signed? If the controller adapter supports it, this is a
    # measure against cookie tampering.
    def sign_cookie=(value = T.unsafe(nil)); end

    # Authentication is allowed via a single access token, but maybe this is
    # something you don't want for your application as a whole. Maybe this
    # is something you only want for specific request types. Specify a list
    # of allowed request types and single access authentication will only be
    # allowed for the ones you specify.
    #
    # * <tt>Default:</tt> ["application/rss+xml", "application/atom+xml"]
    # * <tt>Accepts:</tt> String of a request type, or :all or :any to
    # allow single access authentication for any and all request types
    def single_access_allowed_request_types(value = T.unsafe(nil)); end

    # Authentication is allowed via a single access token, but maybe this is
    # something you don't want for your application as a whole. Maybe this
    # is something you only want for specific request types. Specify a list
    # of allowed request types and single access authentication will only be
    # allowed for the ones you specify.
    #
    # * <tt>Default:</tt> ["application/rss+xml", "application/atom+xml"]
    # * <tt>Accepts:</tt> String of a request type, or :all or :any to
    # allow single access authentication for any and all request types
    def single_access_allowed_request_types=(value = T.unsafe(nil)); end

    def validate(*filter_list, &block); end

    # The name of the method in your model used to verify the password. This
    # should be an instance method. It should also be prepared to accept a
    # raw password and a crytped password.
    #
    # * <tt>Default:</tt> "valid_password?" defined in acts_as_authentic/password.rb
    # * <tt>Accepts:</tt> Symbol or String
    def verify_password_method(value = T.unsafe(nil)); end

    # The name of the method in your model used to verify the password. This
    # should be an instance method. It should also be prepared to accept a
    # raw password and a crytped password.
    #
    # * <tt>Default:</tt> "valid_password?" defined in acts_as_authentic/password.rb
    # * <tt>Accepts:</tt> Symbol or String
    def verify_password_method=(value = T.unsafe(nil)); end

    # What with_scopes focuses on is scoping the query when finding the
    # object and the name of the cookie / session. It works very similar to
    # ActiveRecord::Base#with_scopes. It accepts a hash with any of the
    # following options:
    #
    # * <tt>find_options:</tt> any options you can pass into ActiveRecord::Base.find.
    # This is used when trying to find the record.
    # * <tt>id:</tt> The id of the session, this gets merged with the real id. For
    # information ids see the id method.
    #
    # Here is how you use it:
    #
    # ```
    # UserSession.with_scope(find_options: User.where(account_id: 2), id: "account_2") do
    # UserSession.find
    # end
    # ```
    #
    # Essentially what the above does is scope the searching of the object
    # with the sql you provided. So instead of:
    #
    # ```
    # User.where("login = 'ben'").first
    # ```
    #
    # it would effectively be:
    #
    # ```
    # User.where("login = 'ben' and account_id = 2").first
    # ```
    #
    # You will also notice the :id option. This works just like the id
    # method. It scopes your cookies. So the name of your cookie will be:
    #
    # account_2_user_credentials
    #
    # instead of:
    #
    # user_credentials
    #
    # What is also nifty about scoping with an :id is that it merges your
    # id's. So if you do:
    #
    # UserSession.with_scope(
    # find_options: { conditions: "account_id = 2"},
    # id: "account_2"
    # ) do
    # session = UserSession.new
    # session.id = :secure
    # end
    #
    # The name of your cookies will be:
    #
    # secure_account_2_user_credentials
    def with_scope(options = T.unsafe(nil)); end

    private

    def scope=(value); end
  end
end

Authlogic::Session::Base::E_AC_PARAMETERS = T.let(T.unsafe(nil), String)
Authlogic::Session::Base::E_DPR_FIND_BY_LOGIN_METHOD = T.let(T.unsafe(nil), String)

# Callbacks
# =========
Authlogic::Session::Base::METHODS = T.let(T.unsafe(nil), Array)

Authlogic::Session::Base::VALID_SAME_SITE_VALUES = T.let(T.unsafe(nil), Array)
module Authlogic::Session::Existence; end

class Authlogic::Session::Existence::SessionInvalidError < ::StandardError
  def initialize(session); end
end

module Authlogic::Session::MagicColumn; end

# Assigns the current time to the `last_request_at` attribute.
#
# 1. The `last_request_at` column must exist
# 2. Assignment can be disabled on a per-controller basis
# 3. Assignment will not happen more often than `last_request_at_threshold`
# seconds.
#
# - current_time - a `Time`
# - record - eg. a `User`
# - controller - an `Authlogic::ControllerAdapters::AbstractAdapter`
# - last_request_at_threshold - integer - seconds
class Authlogic::Session::MagicColumn::AssignsLastRequestAt
  def initialize(current_time, record, controller, last_request_at_threshold); end

  def assign; end

  private

  def assign?; end
end
