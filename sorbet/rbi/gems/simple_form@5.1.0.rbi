# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `simple_form` gem.
# Please instead update this file by running `bin/tapioca gem simple_form`.

module ActionView::Helpers
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CspHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RenderingHelper
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::Concern
  include ::ActionView::Helpers::UrlHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::FormTagHelper
  include ::ActionView::Helpers::FormHelper
  include ::ActionView::Helpers::TranslationHelper

  mixes_in_class_methods ::ActionView::Helpers::UrlHelper::ClassMethods
  mixes_in_class_methods ::ActionView::Helpers::SanitizeHelper::ClassMethods

  class << self
    def eager_load!; end
  end
end

class ActionView::Helpers::FormBuilder
  include ::ActionView::ModelNaming
  include ::SimpleForm::ActionViewExtensions::Builder

  def initialize(object_name, object, template, options); end

  def button(value = T.unsafe(nil), options = T.unsafe(nil), &block); end
  def check_box(method, options = T.unsafe(nil), checked_value = T.unsafe(nil), unchecked_value = T.unsafe(nil)); end
  def collection_check_boxes(method, collection, value_method, text_method, options = T.unsafe(nil), html_options = T.unsafe(nil), &block); end
  def collection_radio_buttons(method, collection, value_method, text_method, options = T.unsafe(nil), html_options = T.unsafe(nil), &block); end
  def collection_select(method, collection, value_method, text_method, options = T.unsafe(nil), html_options = T.unsafe(nil)); end
  def color_field(method, options = T.unsafe(nil)); end
  def date_field(method, options = T.unsafe(nil)); end
  def date_select(method, options = T.unsafe(nil), html_options = T.unsafe(nil)); end
  def datetime_field(method, options = T.unsafe(nil)); end
  def datetime_local_field(method, options = T.unsafe(nil)); end
  def datetime_select(method, options = T.unsafe(nil), html_options = T.unsafe(nil)); end
  def email_field(method, options = T.unsafe(nil)); end
  def emitted_hidden_id?; end
  def field_helpers; end
  def field_helpers=(_arg0); end
  def field_helpers?; end
  def field_id(method, *suffixes, namespace: T.unsafe(nil), index: T.unsafe(nil)); end
  def field_name(method, *methods, multiple: T.unsafe(nil), index: T.unsafe(nil)); end
  def fields(scope = T.unsafe(nil), model: T.unsafe(nil), **options, &block); end
  def fields_for(record_name, record_object = T.unsafe(nil), fields_options = T.unsafe(nil), &block); end
  def file_field(method, options = T.unsafe(nil)); end
  def grouped_collection_select(method, collection, group_method, group_label_method, option_key_method, option_value_method, options = T.unsafe(nil), html_options = T.unsafe(nil)); end
  def hidden_field(method, options = T.unsafe(nil)); end
  def id; end
  def index; end
  def label(method, text = T.unsafe(nil), options = T.unsafe(nil), &block); end
  def month_field(method, options = T.unsafe(nil)); end
  def multipart; end
  def multipart=(multipart); end
  def multipart?; end
  def number_field(method, options = T.unsafe(nil)); end
  def object; end
  def object=(_arg0); end
  def object_name; end
  def object_name=(_arg0); end
  def options; end
  def options=(_arg0); end
  def password_field(method, options = T.unsafe(nil)); end
  def phone_field(method, options = T.unsafe(nil)); end
  def radio_button(method, tag_value, options = T.unsafe(nil)); end
  def range_field(method, options = T.unsafe(nil)); end
  def rich_text_area(method, options = T.unsafe(nil)); end
  def search_field(method, options = T.unsafe(nil)); end
  def select(method, choices = T.unsafe(nil), options = T.unsafe(nil), html_options = T.unsafe(nil), &block); end
  def submit(value = T.unsafe(nil), options = T.unsafe(nil)); end
  def telephone_field(method, options = T.unsafe(nil)); end
  def text_area(method, options = T.unsafe(nil)); end
  def text_field(method, options = T.unsafe(nil)); end
  def time_field(method, options = T.unsafe(nil)); end
  def time_select(method, options = T.unsafe(nil), html_options = T.unsafe(nil)); end
  def time_zone_select(method, priority_zones = T.unsafe(nil), options = T.unsafe(nil), html_options = T.unsafe(nil)); end
  def to_model; end
  def to_partial_path; end
  def url_field(method, options = T.unsafe(nil)); end
  def week_field(method, options = T.unsafe(nil)); end
  def weekday_select(method, options = T.unsafe(nil), html_options = T.unsafe(nil)); end

  private

  def convert_to_legacy_options(options); end
  def fields_for_nested_model(name, object, fields_options, block); end
  def fields_for_with_nested_attributes(association_name, association, options, block); end
  def nested_attributes_association?(association_name); end
  def nested_child_index(name); end
  def objectify_options(options); end
  def submit_default_value; end

  class << self
    def _to_partial_path; end
    def field_helpers; end
    def field_helpers=(value); end
    def field_helpers?; end
  end
end

module SimpleForm
  extend ::ActiveSupport::Autoload

  def boolean_label_class; end
  def boolean_label_class=(val); end
  def boolean_style; end
  def boolean_style=(val); end
  def browser_validations; end
  def browser_validations=(val); end
  def button_class; end
  def button_class=(val); end
  def cache_discovery; end
  def cache_discovery=(val); end
  def collection_label_methods; end
  def collection_label_methods=(val); end
  def collection_value_methods; end
  def collection_value_methods=(val); end
  def collection_wrapper_class; end
  def collection_wrapper_class=(val); end
  def collection_wrapper_tag; end
  def collection_wrapper_tag=(val); end
  def country_priority; end
  def country_priority=(val); end
  def custom_inputs_namespaces; end
  def custom_inputs_namespaces=(val); end
  def default_form_class; end
  def default_form_class=(val); end

  # WRAPPER CONFIGURATION
  # The default wrapper to be used by the FormBuilder.
  def default_wrapper; end

  def default_wrapper=(val); end
  def error_method; end
  def error_method=(val); end
  def error_notification_class; end
  def error_notification_class=(val); end
  def error_notification_tag; end
  def error_notification_tag=(val); end
  def field_error_proc; end
  def field_error_proc=(val); end
  def form_class; end
  def generate_additional_classes_for; end
  def generate_additional_classes_for=(val); end
  def i18n_scope; end
  def i18n_scope=(val); end
  def include_default_input_wrapper_class; end
  def include_default_input_wrapper_class=(val); end
  def input_class; end
  def input_class=(val); end
  def input_field_error_class; end
  def input_field_error_class=(val); end
  def input_field_valid_class; end
  def input_field_valid_class=(val); end
  def input_mappings; end
  def input_mappings=(val); end
  def inputs_discovery; end
  def inputs_discovery=(val); end
  def item_wrapper_class; end
  def item_wrapper_class=(val); end
  def item_wrapper_tag; end
  def item_wrapper_tag=(val); end
  def label_class; end
  def label_class=(val); end
  def label_text; end
  def label_text=(val); end
  def required_by_default; end
  def required_by_default=(val); end
  def time_zone_priority; end
  def time_zone_priority=(val); end
  def translate_labels; end
  def translate_labels=(val); end
  def wrapper_mappings; end
  def wrapper_mappings=(val); end

  class << self
    def additional_classes_for(component); end
    def boolean_label_class; end
    def boolean_label_class=(val); end
    def boolean_style; end
    def boolean_style=(val); end
    def browser_validations; end
    def browser_validations=(val); end

    # Builds a new wrapper using SimpleForm::Wrappers::Builder.
    #
    # @yield [builder]
    def build(options = T.unsafe(nil)); end

    def button_class; end
    def button_class=(val); end
    def cache_discovery; end
    def cache_discovery=(val); end
    def collection_label_methods; end
    def collection_label_methods=(val); end
    def collection_value_methods; end
    def collection_value_methods=(val); end
    def collection_wrapper_class; end
    def collection_wrapper_class=(val); end
    def collection_wrapper_tag; end
    def collection_wrapper_tag=(val); end

    # @return [Boolean]
    def configured?; end

    def country_priority; end
    def country_priority=(val); end
    def custom_inputs_namespaces; end
    def custom_inputs_namespaces=(val); end
    def default_form_class; end
    def default_form_class=(val); end

    # SETUP
    def default_input_size=(*_arg0); end

    def default_wrapper; end
    def default_wrapper=(val); end
    def eager_load!; end
    def error_method; end
    def error_method=(val); end
    def error_notification_class; end
    def error_notification_class=(val); end
    def error_notification_tag; end
    def error_notification_tag=(val); end
    def field_error_proc; end
    def field_error_proc=(val); end
    def file_methods; end
    def file_methods=(file_methods); end
    def form_class; end
    def form_class=(value); end
    def generate_additional_classes_for; end
    def generate_additional_classes_for=(val); end
    def i18n_scope; end
    def i18n_scope=(val); end

    # Includes a component to be used by Simple Form. Methods defined in a
    # component will be exposed to be used in the wrapper as Simple::Components
    #
    # Examples
    #
    #    # The application needs to tell where the components will be.
    #    Dir[Rails.root.join('lib/components/**/*.rb')].each { |f| require f }
    #
    #    # Create a custom component in the path specified above.
    #    # lib/components/input_group_component.rb
    #    module InputGroupComponent
    #      def prepend
    #        ...
    #      end
    #
    #      def append
    #        ...
    #      end
    #    end
    #
    #    SimpleForm.setup do |config|
    #      # Create a wrapper using the custom component.
    #      config.wrappers :input_group, tag: :div, error_class: :error do |b|
    #        b.use :label
    #        b.optional :prepend
    #        b.use :input
    #        b.use :append
    #      end
    #    end
    #
    #    # Using the custom component in the form.
    #    <%= simple_form_for @blog, wrapper: input_group do |f| %>
    #      <%= f.input :title, prepend: true %>
    #    <% end %>
    def include_component(component); end

    def include_default_input_wrapper_class; end
    def include_default_input_wrapper_class=(val); end
    def input_class; end
    def input_class=(val); end
    def input_field_error_class; end
    def input_field_error_class=(val); end
    def input_field_valid_class; end
    def input_field_valid_class=(val); end
    def input_mappings; end
    def input_mappings=(val); end
    def inputs_discovery; end
    def inputs_discovery=(val); end
    def item_wrapper_class; end
    def item_wrapper_class=(val); end
    def item_wrapper_tag; end
    def item_wrapper_tag=(val); end
    def label_class; end
    def label_class=(val); end
    def label_text; end
    def label_text=(val); end
    def required_by_default; end
    def required_by_default=(val); end

    # Default way to setup Simple Form. Run rails generate simple_form:install
    # to create a fresh initializer with all configuration values.
    #
    # @yield [_self]
    # @yieldparam _self [SimpleForm] the object that the method was called on
    def setup; end

    def time_zone_priority; end
    def time_zone_priority=(val); end
    def translate_labels; end
    def translate_labels=(val); end

    # Retrieves a given wrapper
    def wrapper(name); end

    def wrapper_mappings; end
    def wrapper_mappings=(val); end

    # Define a new wrapper using SimpleForm::Wrappers::Builder
    # and store it in the given name.
    def wrappers(*args, &block); end
  end
end

module SimpleForm::ActionViewExtensions; end

# A collection of methods required by simple_form but added to rails default form.
# This means that you can use such methods outside simple_form context.
module SimpleForm::ActionViewExtensions::Builder
  # Wrapper for using SimpleForm inside a default rails form.
  # Example:
  #
  #   form_for @user do |f|
  #     f.simple_fields_for :posts do |posts_form|
  #       # Here you have all simple_form methods available
  #       posts_form.input :title
  #     end
  #   end
  def simple_fields_for(*args, &block); end
end

# This module creates SimpleForm wrappers around default form_for and fields_for.
#
# Example:
#
#   simple_form_for @user do |f|
#     f.input :name, hint: 'My hint'
#   end
module SimpleForm::ActionViewExtensions::FormHelper
  def simple_fields_for(record_name, record_object = T.unsafe(nil), options = T.unsafe(nil), &block); end
  def simple_form_for(record, options = T.unsafe(nil), &block); end

  private

  def simple_form_css_class(record, options); end
  def with_simple_form_field_error_proc; end
end

SimpleForm::CUSTOM_INPUT_DEPRECATION_WARN = T.let(T.unsafe(nil), String)

# Components are a special type of helpers that can work on their own.
# For example, by using a component, it will automatically change the
# output under given circumstances without user input. For example,
# the disabled helper always need a disabled: true option given
# to the input in order to be enabled. On the other hand, things like
# hints can generate output automatically by doing I18n lookups.
module SimpleForm::Components
  extend ::ActiveSupport::Autoload
end

module SimpleForm::Components::Errors
  def error(wrapper_options = T.unsafe(nil)); end
  def full_error(wrapper_options = T.unsafe(nil)); end

  # @return [Boolean]
  def has_errors?; end

  # @return [Boolean]
  def has_value?; end

  # @return [Boolean]
  def valid?; end

  protected

  def error_method; end
  def error_text; end
  def errors; end
  def errors_on_association; end
  def errors_on_attribute; end
  def full_error_text; end
  def full_errors; end
  def full_errors_on_association; end
  def full_errors_on_attribute; end

  # @return [Boolean]
  def has_custom_error?; end

  # @return [Boolean]
  def object_with_errors?; end
end

module SimpleForm::Components::HTML5
  def initialize(*_arg0); end

  # @return [Boolean]
  def has_required?; end

  def html5(wrapper_options = T.unsafe(nil)); end

  # @return [Boolean]
  def html5?; end

  def input_html_aria_required_option; end
  def input_html_required_option; end
end

# Needs to be enabled in order to do automatic lookups.
module SimpleForm::Components::Hints
  # @return [Boolean]
  def has_hint?; end

  def hint(wrapper_options = T.unsafe(nil)); end
end

module SimpleForm::Components::LabelInput
  extend ::ActiveSupport::Concern
  include ::SimpleForm::Components::Labels

  mixes_in_class_methods ::SimpleForm::Components::Labels::ClassMethods

  def label_input(wrapper_options = T.unsafe(nil)); end

  private

  def deprecated_component(namespace, wrapper_options); end
end

module SimpleForm::Components::Labels
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::SimpleForm::Components::Labels::ClassMethods

  def label(wrapper_options = T.unsafe(nil)); end
  def label_html_options; end
  def label_target; end
  def label_text(wrapper_options = T.unsafe(nil)); end

  protected

  # @return [Boolean]
  def generate_label_for_attribute?; end

  # First check labels translation and then human attribute name.
  def label_translation; end

  def raw_label_text; end

  # Default required text when attribute is required.
  def required_label_text; end
end

module SimpleForm::Components::Labels::ClassMethods
  def translate_required_html; end
  def translate_required_mark; end
  def translate_required_text; end

  private

  def i18n_scope; end
end

# Needs to be enabled in order to do automatic lookups.
module SimpleForm::Components::Maxlength
  def maxlength(wrapper_options = T.unsafe(nil)); end

  private

  def find_length_validator; end
  def maximum_length_from_validation; end
  def maximum_length_value_from(length_validator); end
end

module SimpleForm::Components::MinMax
  def min_max(wrapper_options = T.unsafe(nil)); end

  private

  def evaluate_numericality_validator_option(option); end
  def find_numericality_validator; end

  # @return [Boolean]
  def integer?; end

  def maximum_value(validator_options); end
  def minimum_value(validator_options); end
end

# Needs to be enabled in order to do automatic lookups.
module SimpleForm::Components::Minlength
  def minlength(wrapper_options = T.unsafe(nil)); end

  private

  def find_length_validator; end
  def minimum_length_from_validation; end
  def minimum_length_value_from(length_validator); end
end

# Needs to be enabled in order to do automatic lookups.
module SimpleForm::Components::Pattern
  def pattern(wrapper_options = T.unsafe(nil)); end

  private

  def evaluate_format_validator_option(option); end
  def find_pattern_validator; end
  def pattern_source; end
end

# Needs to be enabled in order to do automatic lookups.
module SimpleForm::Components::Placeholders
  def placeholder(wrapper_options = T.unsafe(nil)); end
  def placeholder_text(wrapper_options = T.unsafe(nil)); end
end

# Needs to be enabled in order to do automatic lookups.
module SimpleForm::Components::Readonly
  def readonly(wrapper_options = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def readonly_attribute?; end
end

class SimpleForm::ErrorNotification
  # @return [ErrorNotification] a new instance of ErrorNotification
  def initialize(builder, options); end

  def object(*_arg0, **_arg1, &_arg2); end
  def object_name(*_arg0, **_arg1, &_arg2); end
  def render; end
  def template(*_arg0, **_arg1, &_arg2); end

  protected

  def error_message; end
  def error_notification_tag; end
  def errors; end

  # @return [Boolean]
  def has_errors?; end

  def html_options; end
  def translate_error_notification; end
end

SimpleForm::FILE_METHODS_DEPRECATION_WARN = T.let(T.unsafe(nil), String)

class SimpleForm::FormBuilder < ::ActionView::Helpers::FormBuilder
  include ::SimpleForm::Inputs
  extend ::SimpleForm::MapType

  # @return [FormBuilder] a new instance of FormBuilder
  def initialize(*_arg0); end

  # Helper for dealing with association selects/radios, generating the
  # collection automatically. It's just a wrapper to input, so all options
  # supported in input are also supported by association. Some extra options
  # can also be given:
  #
  # == Examples
  #
  #   simple_form_for @user do |f|
  #     f.association :company          # Company.all
  #   end
  #
  #   f.association :company, collection: Company.all(order: 'name')
  #   # Same as using :order option, but overriding collection
  #
  # == Block
  #
  # When a block is given, association simple behaves as a proxy to
  # simple_fields_for:
  #
  #   f.association :company do |c|
  #     c.input :name
  #     c.input :type
  #   end
  #
  # From the options above, only :collection can also be supplied.
  #
  # Please note that the association helper is currently only tested with Active Record. Depending on the ORM you are using your mileage may vary.
  #
  # @raise [ArgumentError]
  def association(association, options = T.unsafe(nil), &block); end

  # Basic input helper, combines all components in the stack to generate
  # input html based on options the user define and some guesses through
  # database column information. By default a call to input will generate
  # label + input + hint (when defined) + errors (when exists), and all can
  # be configured inside a wrapper html.
  #
  # If a block is given, the contents of the block will replace the input
  # field that would otherwise be generated automatically. The content will
  # be given a label and wrapper div to make it consistent with the other
  # elements in the form.
  #
  # == Examples
  #
  #   # Imagine @user has error "can't be blank" on name
  #   simple_form_for @user do |f|
  #     f.input :name, hint: 'My hint'
  #   end
  #
  # This is the output html (only the input portion, not the form):
  #
  #     <label class="string required" for="user_name">
  #       <abbr title="required">*</abbr> Super User Name!
  #     </label>
  #     <input class="string required" id="user_name" maxlength="100"
  #        name="user[name]" type="text" value="Carlos" />
  #     <span class="hint">My hint</span>
  #     <span class="error">can't be blank</span>
  #
  # Each database type will render a default input, based on some mappings and
  # heuristic to determine which is the best option.
  #
  # You have some options for the input to enable/disable some functions:
  #
  #   as: allows you to define the input type you want, for instance you
  #          can use it to generate a text field for a date column.
  #
  #   required: defines whether this attribute is required or not. True
  #               by default.
  #
  # The fact SimpleForm is built in components allow the interface to be unified.
  # So, for instance, if you need to disable :hint for a given input, you can pass
  # hint: false. The same works for :error, :label and :wrapper.
  #
  # Besides the html for any component can be changed. So, if you want to change
  # the label html you just need to give a hash to :label_html. To configure the
  # input html, supply :input_html instead and so on.
  #
  # == Options
  #
  # Some inputs, as datetime, time and select allow you to give extra options, like
  # prompt and/or include blank. Such options are given in plainly:
  #
  #    f.input :created_at, include_blank: true
  #
  # == Collection
  #
  # When playing with collections (:radio_buttons, :check_boxes and :select
  # inputs), you have three extra options:
  #
  #   collection: use to determine the collection to generate the radio or select
  #
  #   label_method: the method to apply on the array collection to get the label
  #
  #   value_method: the method to apply on the array collection to get the value
  #
  # == Priority
  #
  # Some inputs, as :time_zone and :country accepts a :priority option. If none is
  # given SimpleForm.time_zone_priority and SimpleForm.country_priority are used respectively.
  def attribute(attribute_name, options = T.unsafe(nil), &block); end

  def button(type, *args, &block); end

  # Creates a button:
  #
  #   form_for @user do |f|
  #     f.button :submit
  #   end
  #
  # It just acts as a proxy to method name given. We also alias original Rails
  # button implementation (3.2 forward (to delegate to the original when
  # calling `f.button :button`.
  def button_button(value = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # Creates a collection of check boxes for each item in the collection,
  # associated with a clickable label. Use value_method and text_method to
  # convert items in the collection for use as text/value in check boxes.
  # You can give a symbol or a proc to both value_method and text_method,
  # that will be evaluated for each item in the collection.
  #
  # == Examples
  #
  #   form_for @user do |f|
  #     f.collection_check_boxes :options, [[true, 'Yes'] ,[false, 'No']], :first, :last
  #   end
  #
  #   <input name="user[options][]" type="hidden" value="" />
  #   <input id="user_options_true" name="user[options][]" type="checkbox" value="true" />
  #   <label class="collection_check_boxes" for="user_options_true">Yes</label>
  #   <input name="user[options][]" type="hidden" value="" />
  #   <input id="user_options_false" name="user[options][]" type="checkbox" value="false" />
  #   <label class="collection_check_boxes" for="user_options_false">No</label>
  #
  # It is also possible to give a block that should generate the check box +
  # label. To wrap the check box with the label, for instance:
  #
  #   form_for @user do |f|
  #     f.collection_check_boxes(
  #       :options, [[true, 'Yes'] ,[false, 'No']], :first, :last
  #     ) do |b|
  #       b.label { b.check_box + b.text }
  #     end
  #   end
  #
  # == Options
  #
  # Collection check box accepts some extra options:
  #
  #   * checked  => the value or values that should be checked initially. Accepts
  #                 a single item or an array of items. It overrides existing associations.
  #
  #   * disabled => the value or values that should be disabled. Accepts a single
  #                 item or an array of items.
  #
  #   * collection_wrapper_tag   => the tag to wrap the entire collection.
  #
  #   * collection_wrapper_class => the CSS class to use for collection_wrapper_tag. This option
  #                                 is ignored if the :collection_wrapper_tag option is blank.
  #
  #   * item_wrapper_tag         => the tag to wrap each item in the collection.
  #
  #   * item_wrapper_class       => the CSS class to use for item_wrapper_tag
  #
  #   * a block                  => to generate the label + check box or any other component.
  def collection_check_boxes(method, collection, value_method, text_method, options = T.unsafe(nil), html_options = T.unsafe(nil), &block); end

  # Create a collection of radio inputs for the attribute. Basically this
  # helper will create a radio input associated with a label for each
  # text/value option in the collection, using value_method and text_method
  # to convert these text/value. You can give a symbol or a proc to both
  # value_method and text_method, that will be evaluated for each item in
  # the collection.
  #
  # == Examples
  #
  #   form_for @user do |f|
  #     f.collection_radio_buttons :options, [[true, 'Yes'] ,[false, 'No']], :first, :last
  #   end
  #
  #   <input id="user_options_true" name="user[options]" type="radio" value="true" />
  #   <label class="collection_radio_buttons" for="user_options_true">Yes</label>
  #   <input id="user_options_false" name="user[options]" type="radio" value="false" />
  #   <label class="collection_radio_buttons" for="user_options_false">No</label>
  #
  # It is also possible to give a block that should generate the radio +
  # label. To wrap the radio with the label, for instance:
  #
  #   form_for @user do |f|
  #     f.collection_radio_buttons(
  #       :options, [[true, 'Yes'] ,[false, 'No']], :first, :last
  #     ) do |b|
  #       b.label { b.radio_button + b.text }
  #     end
  #   end
  #
  # == Options
  #
  # Collection radio accepts some extra options:
  #
  #   * checked  => the value that should be checked initially.
  #
  #   * disabled => the value or values that should be disabled. Accepts a single
  #                 item or an array of items.
  #
  #   * collection_wrapper_tag   => the tag to wrap the entire collection.
  #
  #   * collection_wrapper_class => the CSS class to use for collection_wrapper_tag
  #
  #   * item_wrapper_tag         => the tag to wrap each item in the collection.
  #
  #   * item_wrapper_class       => the CSS class to use for item_wrapper_tag
  #
  #   * a block                  => to generate the label + radio or any other component.
  def collection_radio_buttons(method, collection, value_method, text_method, options = T.unsafe(nil), html_options = T.unsafe(nil), &block); end

  # Creates an error tag based on the given attribute, only when the attribute
  # contains errors. All the given options are sent as :error_html.
  #
  # == Examples
  #
  #    f.error :name
  #    f.error :name, id: "cool_error"
  def error(attribute_name, options = T.unsafe(nil)); end

  # Creates an error notification message that only appears when the form object
  # has some error. You can give a specific message with the :message option,
  # otherwise it will look for a message using I18n. All other options given are
  # passed straight as html options to the html tag.
  #
  # == Examples
  #
  #    f.error_notification
  #    f.error_notification message: 'Something went wrong'
  #    f.error_notification id: 'user_error_message', class: 'form_error'
  def error_notification(options = T.unsafe(nil)); end

  # Return the error but also considering its name. This is used
  # when errors for a hidden field need to be shown.
  #
  # == Examples
  #
  #    f.full_error :token #=> <span class="error">Token is invalid</span>
  def full_error(attribute_name, options = T.unsafe(nil)); end

  # Creates a hint tag for the given attribute. Accepts a symbol indicating
  # an attribute for I18n lookup or a string. All the given options are sent
  # as :hint_html.
  #
  # == Examples
  #
  #    f.hint :name # Do I18n lookup
  #    f.hint :name, id: "cool_hint"
  #    f.hint "Don't forget to accept this"
  def hint(attribute_name, options = T.unsafe(nil)); end

  # Basic input helper, combines all components in the stack to generate
  # input html based on options the user define and some guesses through
  # database column information. By default a call to input will generate
  # label + input + hint (when defined) + errors (when exists), and all can
  # be configured inside a wrapper html.
  #
  # If a block is given, the contents of the block will replace the input
  # field that would otherwise be generated automatically. The content will
  # be given a label and wrapper div to make it consistent with the other
  # elements in the form.
  #
  # == Examples
  #
  #   # Imagine @user has error "can't be blank" on name
  #   simple_form_for @user do |f|
  #     f.input :name, hint: 'My hint'
  #   end
  #
  # This is the output html (only the input portion, not the form):
  #
  #     <label class="string required" for="user_name">
  #       <abbr title="required">*</abbr> Super User Name!
  #     </label>
  #     <input class="string required" id="user_name" maxlength="100"
  #        name="user[name]" type="text" value="Carlos" />
  #     <span class="hint">My hint</span>
  #     <span class="error">can't be blank</span>
  #
  # Each database type will render a default input, based on some mappings and
  # heuristic to determine which is the best option.
  #
  # You have some options for the input to enable/disable some functions:
  #
  #   as: allows you to define the input type you want, for instance you
  #          can use it to generate a text field for a date column.
  #
  #   required: defines whether this attribute is required or not. True
  #               by default.
  #
  # The fact SimpleForm is built in components allow the interface to be unified.
  # So, for instance, if you need to disable :hint for a given input, you can pass
  # hint: false. The same works for :error, :label and :wrapper.
  #
  # Besides the html for any component can be changed. So, if you want to change
  # the label html you just need to give a hash to :label_html. To configure the
  # input html, supply :input_html instead and so on.
  #
  # == Options
  #
  # Some inputs, as datetime, time and select allow you to give extra options, like
  # prompt and/or include blank. Such options are given in plainly:
  #
  #    f.input :created_at, include_blank: true
  #
  # == Collection
  #
  # When playing with collections (:radio_buttons, :check_boxes and :select
  # inputs), you have three extra options:
  #
  #   collection: use to determine the collection to generate the radio or select
  #
  #   label_method: the method to apply on the array collection to get the label
  #
  #   value_method: the method to apply on the array collection to get the value
  #
  # == Priority
  #
  # Some inputs, as :time_zone and :country accepts a :priority option. If none is
  # given SimpleForm.time_zone_priority and SimpleForm.country_priority are used respectively.
  def input(attribute_name, options = T.unsafe(nil), &block); end

  # Creates a input tag for the given attribute. All the given options
  # are sent as :input_html.
  #
  # == Examples
  #
  #   simple_form_for @user do |f|
  #     f.input_field :name
  #   end
  #
  # This is the output html (only the input portion, not the form):
  #
  #     <input class="string required" id="user_name" maxlength="100"
  #        name="user[name]" type="text" value="Carlos" />
  #
  # It also support validation classes once it is configured.
  #
  #   # config/initializers/simple_form.rb
  #   SimpleForm.setup do |config|
  #     config.input_field_valid_class = 'is-valid'
  #     config.input_field_error_class = 'is-invalid'
  #   end
  #
  #   simple_form_for @user do |f|
  #     f.input_field :name
  #   end
  #
  # When the validation happens, the input will be rendered with
  # the class configured according to the validation:
  #
  # - when the input is valid:
  #
  #     <input class="is-valid string required" id="user_name" value="Carlos" />
  #
  # - when the input is invalid:
  #
  #     <input class="is-invalid string required" id="user_name" value="" />
  def input_field(attribute_name, options = T.unsafe(nil)); end

  # Creates a default label tag for the given attribute. You can give a label
  # through the :label option or using i18n. All the given options are sent
  # as :label_html.
  #
  # == Examples
  #
  #    f.label :name                     # Do I18n lookup
  #    f.label :name, "Name"             # Same behavior as Rails, do not add required tag
  #    f.label :name, label: "Name"      # Same as above, but adds required tag
  #
  #    f.label :name, required: false
  #    f.label :name, id: "cool_label"
  def label(attribute_name, *args); end

  # The action to be used in lookup.
  def lookup_action; end

  # Extract the model names from the object_name mess, ignoring numeric and
  # explicit child indexes.
  #
  # Example:
  #
  # route[blocks_attributes][0][blocks_learning_object_attributes][1][foo_attributes]
  # ["route", "blocks", "blocks_learning_object", "foo"]
  def lookup_model_names; end

  def mappings; end
  def mappings=(_arg0); end
  def mappings?; end

  # Returns the value of attribute object.
  def object; end

  # Returns the value of attribute object_name.
  def object_name; end

  # Returns the value of attribute template.
  def template; end

  # Returns the value of attribute wrapper.
  def wrapper; end

  private

  def attempt_mapping(mapping, at); end
  def attempt_mapping_with_custom_namespace(input_name); end
  def build_association_attribute(reflection, association, options); end
  def build_input_field_components(components); end
  def build_input_field_options; end

  # Attempt to guess the better input type given the defined options. By
  # default always fallback to the user :as option, or to a :select when a
  # collection is given.
  def default_input_type(attribute_name, column, options); end

  # If cache_discovery is enabled, use the class level cache that persists
  # between requests, otherwise use the instance one.
  def discovery_cache; end

  def fetch_association_collection(reflection, options); end

  # Internal: Try to discover whether an attribute corresponds to a file or not.
  #
  # Most upload Gems add some kind of attributes to the ActiveRecord's model they are included in.
  # This method tries to guess if an attribute belongs to some of these Gems by checking the presence
  # of their methods using `#respond_to?`.
  #
  # Note: This does not support multiple file upload inputs, as this is very application-specific.
  #
  # The order here was chosen based on the popularity of Gems:
  #
  # - `#{attribute_name}_attachment` - ActiveStorage >= `5.2` and Refile >= `0.2.0` <= `0.4.0`
  # - `remote_#{attribute_name}_url` - Refile >= `0.3.0` and CarrierWave >= `0.2.2`
  # - `#{attribute_name}_attacher` - Refile >= `0.4.0` and Shrine >= `0.9.0`
  # - `#{attribute_name}_file_name` - Paperclip ~> `2.0` (added for backwards compatibility)
  #
  # Returns a Boolean.
  #
  # @return [Boolean]
  def file_method?(attribute_name); end

  def find_association_reflection(association); end
  def find_attribute_column(attribute_name); end
  def find_custom_type(attribute_name); end

  # Find an input based on the attribute name.
  def find_input(attribute_name, options = T.unsafe(nil), &block); end

  # Attempts to find a mapping. It follows the following rules:
  #
  # 1) It tries to find a registered mapping, if succeeds:
  #    a) Try to find an alternative with the same name in the Object scope
  #    b) Or use the found mapping
  # 2) If not, fallbacks to #{input_type}Input
  # 3) If not, fallbacks to SimpleForm::Inputs::#{input_type}Input
  def find_mapping(input_type); end

  def find_wrapper(input_type, options); end

  # Attempts to find a wrapper mapping. It follows the following rules:
  #
  # 1) It tries to find a wrapper for the current form
  # 2) If not, it tries to find a config
  def find_wrapper_mapping(input_type); end

  def mapping_override(klass); end

  class << self
    def discovery_cache; end
    def mappings; end
    def mappings=(value); end
    def mappings?; end
  end
end

# When action is create or update, we still should use new and edit
SimpleForm::FormBuilder::ACTIONS = T.let(T.unsafe(nil), Hash)

SimpleForm::FormBuilder::ATTRIBUTE_COMPONENTS = T.let(T.unsafe(nil), Array)

# Helpers are made of several helpers that cannot be turned on automatically.
# For instance, disabled cannot be turned on automatically, it requires the
# user to explicitly pass the option disabled: true so it may work.
module SimpleForm::Helpers; end

module SimpleForm::Helpers::Autofocus
  private

  # @return [Boolean]
  def has_autofocus?; end
end

module SimpleForm::Helpers::Disabled
  private

  def disabled_class; end

  # @return [Boolean]
  def has_disabled?; end
end

module SimpleForm::Helpers::Readonly
  private

  # @return [Boolean]
  def has_readonly?; end

  def readonly_class; end
end

module SimpleForm::Helpers::Required
  private

  def calculate_required; end

  # @return [Boolean]
  def required_by_default?; end

  # @return [Boolean]
  def required_by_validators?; end

  # Do not use has_required? because we want to add the class
  # regardless of the required option.
  def required_class; end

  # @return [Boolean]
  def required_field?; end
end

module SimpleForm::Helpers::Validators
  # @return [Boolean]
  def has_validators?; end

  private

  # @return [Boolean]
  def action_validator_match?(validator); end

  def attribute_validators; end

  # @return [Boolean]
  def conditional_validators?(validator); end

  def find_validator(kind); end
  def reflection_validators; end

  # @return [Boolean]
  def valid_validator?(validator); end
end

module SimpleForm::Inputs
  extend ::ActiveSupport::Autoload
end

class SimpleForm::Inputs::Base
  include ::ERB::Util
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::TranslationHelper
  include ::SimpleForm::Helpers::Autofocus
  include ::SimpleForm::Helpers::Disabled
  include ::SimpleForm::Helpers::Readonly
  include ::SimpleForm::Helpers::Required
  include ::SimpleForm::Helpers::Validators
  include ::SimpleForm::Components::Errors
  include ::SimpleForm::Components::Hints
  include ::SimpleForm::Components::HTML5
  include ::SimpleForm::Components::LabelInput
  include ::SimpleForm::Components::Labels
  include ::SimpleForm::Components::Maxlength
  include ::SimpleForm::Components::Minlength
  include ::SimpleForm::Components::MinMax
  include ::SimpleForm::Components::Pattern
  include ::SimpleForm::Components::Placeholders
  include ::SimpleForm::Components::Readonly
  extend ::SimpleForm::Components::Labels::ClassMethods

  # @return [Base] a new instance of Base
  def initialize(builder, attribute_name, column, input_type, options = T.unsafe(nil)); end

  def additional_classes; end

  # Returns the value of attribute attribute_name.
  def attribute_name; end

  # Returns the value of attribute column.
  def column; end

  def debug_missing_translation; end
  def debug_missing_translation=(val); end
  def default_options; end
  def default_options=(_arg0); end
  def default_options?; end

  # Returns the value of attribute html_classes.
  def html_classes; end

  # @raise [NotImplementedError]
  def input(wrapper_options = T.unsafe(nil)); end

  def input_class; end

  # Returns the value of attribute input_html_classes.
  def input_html_classes; end

  # Returns the value of attribute input_html_options.
  def input_html_options; end

  def input_options; end

  # Returns the value of attribute input_type.
  def input_type; end

  def lookup_action(*_arg0, **_arg1, &_arg2); end
  def lookup_model_names(*_arg0, **_arg1, &_arg2); end
  def object(*_arg0, **_arg1, &_arg2); end
  def object_name(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute options.
  def options; end

  # Returns the value of attribute reflection.
  def reflection; end

  def template(*_arg0, **_arg1, &_arg2); end

  private

  def column_limit; end

  # Add one for decimal point
  def decimal_limit; end

  # @return [Boolean]
  def decimal_or_float?; end

  # Retrieve options for the given namespace from the options hash
  def html_options_for(namespace, css_classes); end

  def i18n_scope; end
  def limit; end
  def merge_wrapper_options(options, wrapper_options); end

  # @return [Boolean]
  def nested_boolean_style?; end

  # Find reflection name when available, otherwise use attribute
  def reflection_or_attribute_name; end

  def set_input_classes(wrapper_options); end

  # Lookup translations for the given namespace using I18n, based on object name,
  # actual action and attribute name. Lookup priority as follows:
  #
  #   simple_form.{namespace}.{model}.{action}.{attribute}
  #   simple_form.{namespace}.{model}.{attribute}
  #   simple_form.{namespace}.defaults.{attribute}
  #
  #  Namespace is used for :labels and :hints.
  #
  #  Model is the actual object name, for a @user object you'll have :user.
  #  Action is the action being rendered, usually :new or :edit.
  #  And attribute is the attribute itself, :name for example.
  #
  #  The lookup for nested attributes is also done in a nested format using
  #  both model and nested object names, such as follow:
  #
  #   simple_form.{namespace}.{model}.{nested}.{action}.{attribute}
  #   simple_form.{namespace}.{model}.{nested}.{attribute}
  #   simple_form.{namespace}.{nested}.{action}.{attribute}
  #   simple_form.{namespace}.{nested}.{attribute}
  #   simple_form.{namespace}.defaults.{attribute}
  #
  #  Example:
  #
  #    simple_form:
  #      labels:
  #        user:
  #          new:
  #            email: 'E-mail para efetuar o sign in.'
  #          edit:
  #            email: 'E-mail.'
  #
  #  Take a look at our locale example file.
  def translate_from_namespace(namespace, default = T.unsafe(nil)); end

  class << self
    def debug_missing_translation; end
    def debug_missing_translation=(val); end
    def default_options; end
    def default_options=(value); end
    def default_options?; end
    def disable(*keys); end
    def enable(*keys); end
  end
end

class SimpleForm::Inputs::BlockInput < ::SimpleForm::Inputs::Base
  # @return [BlockInput] a new instance of BlockInput
  def initialize(*args, &block); end

  def input(wrapper_options = T.unsafe(nil)); end
end

class SimpleForm::Inputs::BooleanInput < ::SimpleForm::Inputs::Base
  def input(wrapper_options = T.unsafe(nil)); end
  def label_input(wrapper_options = T.unsafe(nil)); end

  private

  def boolean_label_class; end

  # Build a checkbox tag using default unchecked value. This allows us to
  # reuse the method for nested boolean style, but with no unchecked value,
  # which won't generate the hidden checkbox. This is the default functionality
  # in Rails > 3.2.1, and is backported in SimpleForm AV helpers.
  def build_check_box(unchecked_value, options); end

  # Build a checkbox without generating the hidden field. See
  # #build_hidden_field_for_checkbox for more info.
  def build_check_box_without_hidden_field(options); end

  # Create a hidden field for the current checkbox, so we can simulate Rails
  # functionality with hidden + checkbox, but under a nested context, where
  # we need the hidden field to be *outside* the label (otherwise it
  # generates invalid html - html5 only).
  def build_hidden_field_for_checkbox; end

  def checked_value; end

  # @return [Boolean]
  def include_hidden?; end

  def inline_label; end

  # @return [Boolean]
  def inline_label?; end

  # Booleans are not required by default because in most of the cases
  # it makes no sense marking them as required. The only exception is
  # Terms of Use usually presented at most sites sign up screen.
  #
  # @return [Boolean]
  def required_by_default?; end

  def unchecked_value; end
end

class SimpleForm::Inputs::CollectionCheckBoxesInput < ::SimpleForm::Inputs::CollectionRadioButtonsInput
  protected

  def build_nested_boolean_style_item_tag(collection_builder); end

  # Checkbox components do not use the required html tag.
  # More info: https://github.com/heartcombo/simple_form/issues/340#issuecomment-2871956
  #
  # @return [Boolean]
  def has_required?; end

  def item_wrapper_class; end
end

class SimpleForm::Inputs::CollectionInput < ::SimpleForm::Inputs::Base
  # @raise [NotImplementedError]
  def input(wrapper_options = T.unsafe(nil)); end

  def input_options; end

  private

  def collection; end

  # @return [Boolean]
  def collection_includes_basic_objects?(collection_classes); end

  def detect_collection_classes(some_collection = T.unsafe(nil)); end

  # Detect the right method to find the label and value for a collection.
  # If no label or value method are defined, will attempt to find them based
  # on default label and value methods that can be configured through
  # SimpleForm.collection_label_methods and
  # SimpleForm.collection_value_methods.
  def detect_collection_methods; end

  def detect_common_display_methods(collection_classes = T.unsafe(nil)); end
  def detect_method_from_class(collection_classes); end

  # @return [Boolean]
  def has_required?; end

  # @return [Boolean]
  def multiple?; end

  # Check if :include_blank must be included by default.
  #
  # @return [Boolean]
  def skip_include_blank?; end

  def translate_collection; end
  def translate_option(options, key); end

  class << self
    # Default boolean collection for use with selects/radios when no
    # collection is given. Always fallback to this boolean collection.
    # Texts can be translated using i18n in "simple_form.yes" and
    # "simple_form.no" keys. See the example locale file.
    def boolean_collection; end
  end
end

SimpleForm::Inputs::CollectionInput::BASIC_OBJECT_CLASSES = T.let(T.unsafe(nil), Array)

class SimpleForm::Inputs::CollectionRadioButtonsInput < ::SimpleForm::Inputs::CollectionInput
  def input(wrapper_options = T.unsafe(nil)); end
  def input_options; end

  protected

  def apply_default_collection_options!(options); end
  def build_nested_boolean_style_item_tag(collection_builder); end
  def collection_block_for_nested_boolean_style; end

  # Do not attempt to generate label[for] attributes by default, unless an
  # explicit html option is given. This avoids generating labels pointing to
  # non existent fields.
  #
  # @return [Boolean]
  def generate_label_for_attribute?; end

  def item_wrapper_class; end
end

class SimpleForm::Inputs::CollectionSelectInput < ::SimpleForm::Inputs::CollectionInput
  def input(wrapper_options = T.unsafe(nil)); end
end

class SimpleForm::Inputs::ColorInput < ::SimpleForm::Inputs::Base
  def input(wrapper_options = T.unsafe(nil)); end
end

class SimpleForm::Inputs::DateTimeInput < ::SimpleForm::Inputs::Base
  def input(wrapper_options = T.unsafe(nil)); end

  private

  def label_target; end

  # @return [Boolean]
  def use_html5_inputs?; end
end

class SimpleForm::Inputs::FileInput < ::SimpleForm::Inputs::Base
  def input(wrapper_options = T.unsafe(nil)); end
end

class SimpleForm::Inputs::GroupedCollectionSelectInput < ::SimpleForm::Inputs::CollectionInput
  def input(wrapper_options = T.unsafe(nil)); end

  private

  # Sample collection
  def collection; end

  def detect_method_from_class(collection_classes); end
  def group_label_method; end
  def group_method; end
  def grouped_collection; end
end

class SimpleForm::Inputs::HiddenInput < ::SimpleForm::Inputs::Base
  def input(wrapper_options = T.unsafe(nil)); end

  private

  def required_class; end

  class << self
    def default_options; end
  end
end

class SimpleForm::Inputs::NumericInput < ::SimpleForm::Inputs::Base
  def input(wrapper_options = T.unsafe(nil)); end

  class << self
    def default_options; end
  end
end

class SimpleForm::Inputs::PasswordInput < ::SimpleForm::Inputs::Base
  def input(wrapper_options = T.unsafe(nil)); end

  class << self
    def default_options; end
  end
end

class SimpleForm::Inputs::PriorityInput < ::SimpleForm::Inputs::CollectionSelectInput
  def input(wrapper_options = T.unsafe(nil)); end
  def input_priority; end

  protected

  # @return [Boolean]
  def skip_include_blank?; end
end

class SimpleForm::Inputs::RangeInput < ::SimpleForm::Inputs::NumericInput
  def input(wrapper_options = T.unsafe(nil)); end
end

class SimpleForm::Inputs::RichTextAreaInput < ::SimpleForm::Inputs::Base
  def input(wrapper_options = T.unsafe(nil)); end
end

class SimpleForm::Inputs::StringInput < ::SimpleForm::Inputs::Base
  def input(wrapper_options = T.unsafe(nil)); end

  private

  # @return [Boolean]
  def string?; end

  class << self
    def default_options; end
  end
end

class SimpleForm::Inputs::TextInput < ::SimpleForm::Inputs::Base
  def input(wrapper_options = T.unsafe(nil)); end

  class << self
    def default_options; end
  end
end

module SimpleForm::MapType
  # @raise [ArgumentError]
  def map_type(*types); end

  class << self
    # @private
    def extended(base); end
  end
end

class SimpleForm::Railtie < ::Rails::Railtie; end
module SimpleForm::Tags; end

class SimpleForm::Tags::CollectionCheckBoxes < ::ActionView::Helpers::Tags::CollectionCheckBoxes
  include ::SimpleForm::Tags::CollectionExtensions

  def render; end

  private

  def render_component(builder); end
end

module SimpleForm::Tags::CollectionExtensions
  private

  def render_collection; end
  def wrap_rendered_collection(collection); end
end

class SimpleForm::Tags::CollectionRadioButtons < ::ActionView::Helpers::Tags::CollectionRadioButtons
  include ::SimpleForm::Tags::CollectionExtensions

  def render; end

  private

  def render_component(builder); end
end

# Raised when fails to find a given wrapper name
class SimpleForm::WrapperNotFound < ::StandardError; end

module SimpleForm::Wrappers; end

# Provides the builder syntax for components. The builder provides
# three methods `use`, `optional` and `wrapper` and they allow the following invocations:
#
#     config.wrappers do |b|
#       # Use a single component
#       b.use :html5
#
#       # Use the component, but do not automatically lookup. It will only be triggered when
#       # :placeholder is explicitly set.
#       b.optional :placeholder
#
#       # Use a component with specific wrapper options
#       b.use :error, wrap_with: { tag: "span", class: "error" }
#
#       # Use a set of components by wrapping them in a tag+class.
#       b.wrapper tag: "div", class: "another" do |ba|
#         ba.use :label
#         ba.use :input
#       end
#
#       # Use a set of components by wrapping them in a tag+class.
#       # This wrapper is identified by :label_input, which means it can
#       # be turned off on demand with `f.input :name, label_input: false`
#       b.wrapper :label_input, tag: "div", class: "another" do |ba|
#         ba.use :label
#         ba.use :input
#       end
#     end
#
# The builder also accepts default options at the root level. This is usually
# used if you want a component to be disabled by default:
#
#     config.wrappers hint: false do |b|
#       b.use :hint
#       b.use :label_input
#     end
#
# In the example above, hint defaults to false, which means it won't automatically
# do the lookup anymore. It will only be triggered when :hint is explicitly set.
class SimpleForm::Wrappers::Builder
  # @return [Builder] a new instance of Builder
  def initialize(options); end

  def optional(name, options = T.unsafe(nil), &block); end
  def to_a; end
  def use(name, options = T.unsafe(nil)); end
  def wrapper(name, options = T.unsafe(nil)); end
end

class SimpleForm::Wrappers::Leaf
  # @return [Leaf] a new instance of Leaf
  def initialize(namespace, options = T.unsafe(nil)); end

  def find(name); end

  # Returns the value of attribute namespace.
  def namespace; end

  def render(input); end
end

# A wrapper is an object that holds several components and render them.
# A component may be any object that responds to `render`.
# This API allows inputs/components to be easily wrapped, removing the
# need to modify the code only to wrap input in an extra tag.
#
# `Many` represents a wrapper around several components at the same time.
# It may optionally receive a namespace, allowing it to be configured
# on demand on input generation.
class SimpleForm::Wrappers::Many
  # @return [Many] a new instance of Many
  def initialize(namespace, components, defaults = T.unsafe(nil)); end

  # Returns the value of attribute components.
  def components; end

  # Returns the value of attribute defaults.
  def defaults; end

  def find(name); end

  # Returns the value of attribute namespace.
  def namespace; end

  def render(input); end

  private

  def html_classes(input, options); end
  def html_options(options); end
  def wrap(input, options, content); end
end

# `Root` is the root wrapper for all components. It is special cased to
# always have a namespace and to add special html classes.
class SimpleForm::Wrappers::Root < ::SimpleForm::Wrappers::Many
  # @return [Root] a new instance of Root
  def initialize(*args); end

  # Provide a fallback if name cannot be found.
  def find(name); end

  # Returns the value of attribute options.
  def options; end

  def render(input); end

  private

  def html_class(key, options); end
  def html_classes(input, options); end
end

# `Single` is an optimization for a wrapper that has only one component.
class SimpleForm::Wrappers::Single < ::SimpleForm::Wrappers::Many
  # @return [Single] a new instance of Single
  def initialize(name, wrapper_options = T.unsafe(nil), options = T.unsafe(nil)); end

  def render(input); end

  private

  def html_options(options); end
end
